<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="keywords" content="产品经理，软件工程师，区块链，互联网，流量变现">
<meta property="og:type" content="website">
<meta property="og:title" content="汤包个人页">
<meta property="og:url" content="http://ahtang.com//index.html">
<meta property="og:site_name" content="汤包个人页">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="汤包个人页">






  <link rel="canonical" href="http://ahtang.com//"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>汤包个人页</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-2155923-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-2155923-2');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">汤包个人页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ahtang.com//2018/09/13/面试刷题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤包个人页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/面试刷题/" itemprop="url">
                  面试刷题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-13 21:17:00" itemprop="dateCreated datePublished" datetime="2018-09-13T21:17:00+08:00">2018-09-13</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Binary-Search-amp-LogN-Algorithm"><a href="#Binary-Search-amp-LogN-Algorithm" class="headerlink" title="Binary Search &amp; LogN Algorithm"></a>Binary Search &amp; LogN Algorithm</h1><p>比O(n)更优的时间复杂度几乎只能是O(logn)的二分法<br>二分法模板: start + 1 &lt; end; start + (end - start) / 2; A[mid] ==, &lt;, &gt;; A[start] A[end] ? target</p>
<h3 id="704-Binary-Search-Easy"><a href="#704-Binary-Search-Easy" class="headerlink" title="704. Binary Search (Easy)"></a><a href="https://leetcode.com/problems/binary-search/description/" target="_blank" rel="noopener">704. Binary Search (Easy)</a></h3><p><a href="https://www.lintcode.com/problem/classical-binary-search/description" target="_blank" rel="noopener">lintcode’s version</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Find any position of a target number in a sorted array. Return -1 if target does not exist.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given [1, 2, 2, 4, 5, 5].</span><br><span class="line"></span><br><span class="line">For target = 2, return 1 or 2.</span><br><span class="line"></span><br><span class="line">For target = 5, return 4 or 5.</span><br><span class="line"></span><br><span class="line">For target = 6, return -1.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(logn) time</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: nums: An integer array sorted in ascending order</span></span><br><span class="line"><span class="string">    @param: target: An integer</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPosition</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (len(nums) == <span class="number">0</span>):</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span>     </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> (nums[mid] &lt; target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid    </span><br><span class="line">        <span class="keyword">if</span> (nums[start] == target):</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> (nums[end] == target):</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>总结：背好模板，lintcode 的 test case 包含空输入数组，需要 python3 的 // 整除运算符才能过</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> (len(nums) == <span class="number">1</span> <span class="keyword">and</span> nums[<span class="number">0</span>] != target):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, target, <span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, target, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> (start &gt; end):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> (start + <span class="number">1</span> == end):</span><br><span class="line">            <span class="keyword">if</span> nums[end] == target:</span><br><span class="line">                <span class="keyword">return</span> end</span><br><span class="line">            <span class="keyword">if</span> nums[start] == target:</span><br><span class="line">                <span class="keyword">return</span> start</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target):</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">elif</span> (nums[mid] &lt; target):</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, target, start, end)</span><br></pre></td></tr></table></figure></p>
<p>总结：不背模板也能写。 但是写出来不如模板的优雅。如果递归调用前面不加 return 的话，还会发生不 return 的情况</p>
<h3 id="LinC-14-First-Position-of-Target-Easy"><a href="#LinC-14-First-Position-of-Target-Easy" class="headerlink" title="LinC 14. First Position of Target (Easy)"></a><a href="https://www.lintcode.com/problem/first-position-of-target/description" target="_blank" rel="noopener">LinC 14. First Position of Target (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Description</span><br><span class="line">For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.</span><br><span class="line"></span><br><span class="line">If the target number does not exist in the array, return -1.</span><br><span class="line"></span><br><span class="line">Have you met this question in a real interview?  </span><br><span class="line">Example</span><br><span class="line">If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">If the count of numbers is bigger than 2^32, can your code work properly?</span><br></pre></td></tr></table></figure>
<p>思路：找到了不要 return，扔掉大的一半，继续找<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: The integer array.</span></span><br><span class="line"><span class="string">    @param target: Target to find.</span></span><br><span class="line"><span class="string">    @return: The first position of target. Position starts from 0.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (len(nums) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">if</span> (nums[start] == target):</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> (nums[end] == target):</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：背好模板，模板 v5</p>
<h3 id="278-First-Bad-Version-Easy"><a href="#278-First-Bad-Version-Easy" class="headerlink" title="278. First Bad Version (Easy)"></a><a href="https://leetcode.com/problems/first-bad-version/description/" target="_blank" rel="noopener">278. First Bad Version (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</span><br><span class="line"></span><br><span class="line">Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</span><br><span class="line"></span><br><span class="line">You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given n = 5, and version = 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure>
<p>思路：前面 first position of target 的变体，可以不做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start, end = <span class="number">0</span>, n</span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(start)):</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(end)):</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>总结：可不做</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> isBadVersion(<span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">1</span>, n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, start, end)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start + <span class="number">1</span> == end:</span><br><span class="line">            <span class="keyword">return</span> start <span class="keyword">if</span> isBadVersion(start) <span class="keyword">else</span> end</span><br><span class="line">        mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> isBadVersion(mid):</span><br><span class="line">            end = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            start = mid</span><br><span class="line">        <span class="keyword">return</span> self.helper(start, end)</span><br></pre></td></tr></table></figure></p>
<p>总结：递归思维更自然。二刷之前没有看模板。模板大法更普适</p>
<h3 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/" target="_blank" rel="noopener">34. Find First and Last Position of Element in Sorted Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</span><br><span class="line"></span><br><span class="line">Your algorithm's runtime complexity must be in the order of O(log n).</span><br><span class="line"></span><br><span class="line">If the target is not found in the array, return [-1, -1].</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
<p>思路：二分法找 Target, 两次二分法，一次找左边界，一次找右边界<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 找左边界</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l ) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[l] == target:</span><br><span class="line">            ans[<span class="number">0</span>] = l</span><br><span class="line">        <span class="keyword">elif</span> nums[r] == target:</span><br><span class="line">            ans[<span class="number">0</span>] = r</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找右边界</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> nums[r] == target:</span><br><span class="line">            ans[<span class="number">1</span>] = r</span><br><span class="line">        <span class="keyword">elif</span> nums[l] == target:</span><br><span class="line">            ans[<span class="number">1</span>] = l</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：按今天的水平，写的时候注意 while 的终止条件是 while l + 1 &lt; r (l, r 不要重合就终止循环)。 两年多前写了稍微更简洁些的版本。可以回头再看看能不能写得出。</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">0</span>, <span class="number">0</span>] <span class="keyword">if</span> nums[<span class="number">0</span>] == target <span class="keyword">else</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">        res1 = end <span class="keyword">if</span> nums[end] == target <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        res1 = start <span class="keyword">if</span> nums[start] == target <span class="keyword">else</span> res1</span><br><span class="line">        <span class="keyword">if</span> res1 == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">        start, end = res1, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">if</span> nums[mid] &gt; target:</span><br><span class="line">                end = mid</span><br><span class="line">        res2 = start <span class="keyword">if</span> nums[start] == target <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        res2 = end <span class="keyword">if</span> nums[end] == target <span class="keyword">else</span> res2</span><br><span class="line">        <span class="keyword">if</span> res2 == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> [res1, res1]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [res1, res2]</span><br></pre></td></tr></table></figure></p>
<p>总结： 凭借模板大法战胜 100% 的 python 选手。<br>高频：…if <strong>nums[mid] == target</strong>: r = <strong>mid</strong>…res1 = r … res1 = l …else res1; if res1 == -1: return [-1, -1]…res2 = l … res2 = r …else res2; if …: return [res1, res1]…</p>
<h3 id="LinC-61-Search-for-a-Range-Medium"><a href="#LinC-61-Search-for-a-Range-Medium" class="headerlink" title="LinC 61. Search for a Range (Medium)"></a><a href="https://www.lintcode.com/problem/search-for-a-range/description" target="_blank" rel="noopener">LinC 61. Search for a Range (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array of n integers, find the starting and ending position of a given target value.</span><br><span class="line"></span><br><span class="line">If the target is not found in the array, return [-1, -1].</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given [5, 7, 7, 8, 8, 10] and target value 8,</span><br><span class="line">return [3, 4].</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(log n) time.</span><br></pre></td></tr></table></figure>
<p>思路：找一个数的第一次和最后一次出现的 index<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: an integer sorted array</span></span><br><span class="line"><span class="string">    @param target: an integer to be inserted</span></span><br><span class="line"><span class="string">    @return: a list of length 2, [index1, index2]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        firstO, lastO = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [firstO, lastO]</span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt; target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> (A[end] == target):</span><br><span class="line">            firstO = end        </span><br><span class="line">        <span class="keyword">if</span> (A[start] == target):</span><br><span class="line">            firstO = start</span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt;= target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> (A[start] == target):</span><br><span class="line">            lastO = start</span><br><span class="line">        <span class="keyword">if</span> (A[end] == target):</span><br><span class="line">            lastO = end</span><br><span class="line">        <span class="keyword">return</span> [firstO, lastO]</span><br></pre></td></tr></table></figure></p>
<p>总结：注意检查空输入！</p>
<h3 id="852-Peak-Index-in-a-Mountain-Array"><a href="#852-Peak-Index-in-a-Mountain-Array" class="headerlink" title="852. Peak Index in a Mountain Array"></a><a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/description/" target="_blank" rel="noopener">852. Peak Index in a Mountain Array</a></h3><p><a href="https://www.lintcode.com/problem/maximum-number-in-mountain-sequence/description" target="_blank" rel="noopener">LinC 585. Maximum Number in Mountain Sequence (Medium)</a><br>Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.<br>Example<br>Given nums = [1, 2, 4, 8, 6, 3] return 8<br>Given nums = [10, 9, 8, 7], return 10</p>
<p>思路：切一刀，判断递增就扔左边，递减就扔右边， 不然就找到了中点<br>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(self, A)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type A: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> A[mid - <span class="number">1</span>] &lt; A[mid] &lt; A[mid + <span class="number">1</span>]:</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">elif</span> A[mid - <span class="number">1</span>] &gt; A[mid] &gt; A[mid + <span class="number">1</span>]:</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">return</span> start <span class="keyword">if</span> A[start] &gt; A[end] <span class="keyword">else</span> end</span><br></pre></td></tr></table></figure></p>
<p>总结：二刷写法跟一刷一样，哪怕是简单的题，题要看清楚， mid min 不要拼错</p>
<h3 id="162-Find-Peak-Element-Medium"><a href="#162-Find-Peak-Element-Medium" class="headerlink" title="162. Find Peak Element (Medium)"></a><a href="https://leetcode.com/problems/find-peak-element/description/" target="_blank" rel="noopener">162. Find Peak Element (Medium)</a></h3><p>A peak element is an element that is greater than its neighbors.<br>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.<br>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br>You may imagine that nums[-1] = nums[n] = -∞.</p>
<p>Example 1:<br>Input: nums = [1,2,3,1]<br>Output: 2<br>Explanation: 3 is a peak element and your function should return the index number 2.</p>
<p>Example 2:<br>Input: nums = [1,2,1,3,5,6,4]<br>Output: 1 or 5<br>Explanation: Your function can return either index number 1 where the peak element is 2,<br>             or index number 5 where the peak element is 6.<br>Note:<br>Your solution should be in logarithmic complexity.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid - <span class="number">1</span>] &lt; nums[mid] &lt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid - <span class="number">1</span>] &lt; nums[mid] &gt; nums[mid + <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">return</span> r <span class="keyword">if</span> nums[l] &lt; nums[r] <span class="keyword">else</span> l</span><br></pre></td></tr></table></figure></p>
<p>面经：Quora。关键要知道切中点，如果是///向上，则顶点在右，如果/^\则找到顶点，否则顶点在左</p>
<h3 id="74-Search-a-2D-Matrix-Medium"><a href="#74-Search-a-2D-Matrix-Medium" class="headerlink" title="74. Search a 2D Matrix (Medium)"></a><a href="https://leetcode.com/problems/search-a-2d-matrix/description/" target="_blank" rel="noopener">74. Search a 2D Matrix (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</span><br><span class="line"></span><br><span class="line">Integers in each row are sorted from left to right.</span><br><span class="line">The first integer of each row is greater than the last integer of the previous row.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span> <span class="keyword">or</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        rows, cols = len(matrix) - <span class="number">1</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        startR, endR = <span class="number">0</span>, rows</span><br><span class="line">        <span class="keyword">while</span> startR + <span class="number">1</span> &lt; endR:</span><br><span class="line">            midR = startR + (endR - startR) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[midR][<span class="number">0</span>] &lt; target:</span><br><span class="line">                startR = midR</span><br><span class="line">            <span class="keyword">elif</span> matrix[midR][<span class="number">0</span>] &gt; target:</span><br><span class="line">                endR = midR</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> startR &lt; endR:</span><br><span class="line">            <span class="keyword">if</span> matrix[startR][cols] &lt; target:</span><br><span class="line">                startR = endR</span><br><span class="line">        startC, endC = <span class="number">0</span>, cols</span><br><span class="line">        <span class="keyword">while</span> startC + <span class="number">1</span> &lt; endC:</span><br><span class="line">            midC = startC + (endC - startC) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[startR][midC] &lt; target:</span><br><span class="line">                startC = midC</span><br><span class="line">            <span class="keyword">elif</span> matrix[startR][midC] &gt; target:</span><br><span class="line">                endC = midC</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span> <span class="keyword">if</span> matrix[startR][startC] != target <span class="keyword">and</span> matrix[startR][endC] != target <span class="keyword">else</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>高频：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        rs, re = <span class="number">0</span>, m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> rs + <span class="number">1</span> &lt; re:</span><br><span class="line">            rm = rs + (re - rs) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[rm][<span class="number">0</span>] &lt; target:</span><br><span class="line">                rs = rm</span><br><span class="line">            <span class="keyword">elif</span> matrix[rm][<span class="number">0</span>] &gt; target:</span><br><span class="line">                re = rm - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> matrix[rs][n - <span class="number">1</span>] &lt; target:</span><br><span class="line">            rs = re</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> target <span class="keyword">in</span> matrix[rs] <span class="keyword">else</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>1总结：注意检查空输入<br>2总结：有两种空情况需要判断 [] 和 [[]]，击败 100% python3 选手。。。<br>高频：记住二分查找的模板：…s + 1 &lt; e…。注意判断…if <strong>matrix[rs][n - 1] &lt;</strong> target:…</p>
<h3 id="153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium" class="headerlink" title="153. Find Minimum in Rotated Sorted Array (Medium)"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">153. Find Minimum in Rotated Sorted Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</span><br><span class="line"></span><br><span class="line">Find the minimum element.</span><br><span class="line"></span><br><span class="line">You may assume no duplicate exists in the array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [3,4,5,1,2]</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>思路：找 pivot，pivot &gt; 0 时返回 nums[pivot + 1]。找 pivot 时,如果 mid &lt; start, 扔 end， 如果 mid &gt; start 扔 start<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; nums[len(nums) - <span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[start]):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">return</span> nums[end]</span><br></pre></td></tr></table></figure></p>
<p>总结：应改为 Easy 难度的题。<br>Follow up: 如果有重复的数? 无法保证在 Log(N) 的时间复杂度内解决 例子:[1,1,1,1,1….,1] 里藏着一个 0.最坏情况下需要把每个位置上的1都看一遍，才能找到最后一个有0 的位置. 考点:能想到这个最坏情况的例子</p>
<h3 id="33-Search-in-Rotated-Sorted-Array-Medium"><a href="#33-Search-in-Rotated-Sorted-Array-Medium" class="headerlink" title="33. Search in Rotated Sorted Array (Medium)"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">33. Search in Rotated Sorted Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</span><br><span class="line"></span><br><span class="line">You are given a target value to search. If found in the array return its index, otherwise return -1.</span><br><span class="line"></span><br><span class="line">You may assume no duplicate exists in the array.</span><br><span class="line"></span><br><span class="line">Your algorithm's runtime complexity must be in the order of O(log n).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p>思路：第一感觉是得知道 pivot 在哪，有 pivot 一侧不能随便扔，但是更优的方法是查单调的侧是否可以扔<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[start] &lt; nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[start] &lt;= target &lt;= nums[mid]:</span><br><span class="line">                    end = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target &lt;= nums[end]:</span><br><span class="line">                    start = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] == target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] == target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结： 注意 [1, 3, 5] target 为 1 这种边界条件， 判断 target 在单调这边需要加等号</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: <span class="string">'List[int]'</span>, target: <span class="string">'int'</span>)</span> -&gt; 'int':</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">if</span> nums[<span class="number">0</span>] == target <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">                <span class="comment"># pivot 在左</span></span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; nums[start]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[end] :</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">                <span class="comment"># piviot 在右</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &gt; target &gt;= nums[start]:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[start] == target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] == target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：判断是否保留单调一边不能只看 nums[mid], 扔一侧的时候可以多扔一个 mid + 1 或 mid - 1<br>高频：…while <strong>l + 1</strong> &lt; r…if nums[mid] <strong>&lt;</strong> nums[l]: if <strong>nums[mid] &lt; target &lt;= nums[r]</strong>: …</p>
<h3 id="81-Search-in-Rotated-Sorted-Array-II-Medium"><a href="#81-Search-in-Rotated-Sorted-Array-II-Medium" class="headerlink" title="81. Search in Rotated Sorted Array II (Medium)"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. Search in Rotated Sorted Array II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).</span><br><span class="line"></span><br><span class="line">You are given a target value to search. If found in the array return true, otherwise return false.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">Output: false</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.</span><br><span class="line">Would this affect the run-time complexity? How and why?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] &lt; nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt;= target &lt; nums[mid]:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[l] &gt; nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt; target &lt;= nums[r]:</span><br><span class="line">                    l = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[l] == target <span class="keyword">or</span> nums[r] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>高频：注意r = len(nums) - 1，判断nums[mid] == nums[l] 的情况下l += 1</p>
<h3 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">69. Sqrt(x) (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Implement int sqrt(int x).</span><br><span class="line"></span><br><span class="line">Compute and return the square root of x, where x is guaranteed to be a non-negative integer.</span><br><span class="line"></span><br><span class="line">Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 8</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The square root of 8 is 2.82842..., and since</span><br><span class="line">             the decimal part is truncated, 2 is returned.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mySqrt</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, x</span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> mid * mid &lt;= x &lt; (mid + <span class="number">1</span>) * (mid + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> mid * mid &lt; x:</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> l <span class="keyword">if</span> l * l &lt;= x &lt; (l + <span class="number">1</span>) * (l + <span class="number">1</span>) <span class="keyword">else</span> r</span><br></pre></td></tr></table></figure>
<p>高频：统一模板…l + 1 &lt; r…if mid <em> mid <strong>&lt;=</strong> x <strong>&lt;</strong>(mid + 1) </em> (mid + 1)…return l if l * l &lt;= x &lt;…</p>
<h3 id="35-Search-Insert-Position-Easy"><a href="#35-Search-Insert-Position-Easy" class="headerlink" title="35. Search Insert Position (Easy)"></a><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">35. Search Insert Position (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</span><br><span class="line"></span><br><span class="line">You may assume no duplicates in the array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 5</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 2</span><br><span class="line">Output: 1</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 7</span><br><span class="line">Output: 4</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: [1,3,5,6], 0</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> target &lt;= nums[l]:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        <span class="keyword">if</span> target &lt;= nums[r]:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">return</span> len(nums)</span><br></pre></td></tr></table></figure>
<p>高频：…l = mid…if target &lt;= nums[l]: return l…return len(nums)</p>
<h3 id="658-Find-K-Closest-Elements-Medium"><a href="#658-Find-K-Closest-Elements-Medium" class="headerlink" title="658. Find K Closest Elements (Medium)"></a><a href="https://leetcode.com/problems/find-k-closest-elements/description/" target="_blank" rel="noopener">658. Find K Closest Elements (Medium)</a></h3><p><a href="https://www.lintcode.com/problem/find-k-closest-elements/description" target="_blank" rel="noopener">LinC 460. Find K Closest Elements (Medium)</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3,4,5], k=4, x=3</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,2,3,4,5], k=4, x=-1</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Note:</span><br><span class="line">The value k is positive and will always be smaller than the length of the sorted array.</span><br><span class="line">Length of the given array is positive and will not exceed 104</span><br><span class="line">Absolute value of elements in the array and x will not exceed 104</span><br><span class="line">UPDATE (2017/9/19):</span><br><span class="line">The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.</span><br></pre></td></tr></table></figure></p>
<p>三刷<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr: List[int], k: int, x: int)</span> -&gt; List[int]:</span></span><br><span class="line">        n = len(arr)</span><br><span class="line">        l, r = <span class="number">0</span>, n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> arr[mid] &lt; x:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt;= n - <span class="number">1</span> <span class="keyword">and</span> cnt &lt; k:</span><br><span class="line">            <span class="keyword">if</span> abs(arr[l] - x) &lt;= abs(arr[r] - x):</span><br><span class="line">                res.append(arr[l])</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                res.append(arr[r])</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> cnt &lt; k:</span><br><span class="line">            res.append(arr[l])</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt;= n - <span class="number">1</span> <span class="keyword">and</span> cnt &lt; k:</span><br><span class="line">            res.append(arr[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sorted(res)</span><br></pre></td></tr></table></figure></p>
<p>三刷：整理一，二刷代码。算法：1.二分法查找 target，将 l, r 指针放到正确的位置；2.左右按 diff 走 k；3.往左走到底，往右走到底…if nums[mid] <strong>&lt;</strong> x: l = <strong>mid</strong> else: r = <strong>mid</strong>…<br>网上还有一种很妖的O(logN)算法，破坏了模板，核心原理是l, r = 0, len(arr) - k…if abs(arr[mid] - x) &gt; abs(arr[mid + k] - x): l = mid + 1 else: r = mid; return arr[l: l + k]</p>
<h1 id="Two-pointers"><a href="#Two-pointers" class="headerlink" title="Two pointers"></a>Two pointers</h1><h3 id="LinC-373-Partition-Array-by-Odd-and-Even-Easy"><a href="#LinC-373-Partition-Array-by-Odd-and-Even-Easy" class="headerlink" title="LinC 373. Partition Array by Odd and Even (Easy)"></a><a href="http://www.lintcode.com/problem/partition-array-by-odd-and-even/" target="_blank" rel="noopener">LinC 373. Partition Array by Odd and Even (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Partition an integers array into odd number first and even number second.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given [1, 2, 3, 4], return [1, 3, 2, 4]</span><br></pre></td></tr></table></figure>
<p>思路：双指针一头一尾，碰到不符合的就换。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: nums: an array of integers</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> nums[r] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        <span class="keyword">if</span> nums[l] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> nums[r] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br></pre></td></tr></table></figure></p>
<p>总结：送两个测试数据进去就能写对。 最后两个 if 可以简化。</p>
<h3 id="26-Remove-Duplicates-from-Sorted-Array-Easy"><a href="#26-Remove-Duplicates-from-Sorted-Array-Easy" class="headerlink" title="26. Remove Duplicates from Sorted Array (Easy)"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">26. Remove Duplicates from Sorted Array (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">Confused why the returned value is an integer but your answer is an array?</span><br><span class="line"></span><br><span class="line">Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</span><br><span class="line"></span><br><span class="line">Internally you can think of this:</span><br><span class="line"></span><br><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i <span class="tag">&lt; <span class="attr">len</span>; <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">print</span>(<span class="attr">nums</span>[<span class="attr">i</span>]);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>
<p>思路：简单题， 慢指针只有在快指针碰到不同的值才走。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：纯热身，秒解</p>
<p>二刷<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(nums)</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[slow] == nums[fast]:</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow], nums[fast] = nums[fast], nums[slow]</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：虽然是容易热身题，却要思考两个问题，第一，数组需要 in place sort, 需要利用已经排好序这个条件来在 slow 往前一个以后交换 slow 和 fast 的数； 第二，返回 slow + 1 可以省一个 ans 变量<br>高频: …else: slow += 1; nums[slow], nums[fast] = nums[fast], nums[slow]; fast += 1…</p>
<h3 id="80-Remove-Duplicates-from-Sorted-Array-II-Medium"><a href="#80-Remove-Duplicates-from-Sorted-Array-II-Medium" class="headerlink" title="80. Remove Duplicates from Sorted Array II (Medium)"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. Remove Duplicates from Sorted Array II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums = [1,1,1,2,2,3],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums = [0,0,1,1,1,1,2,3,3],</span><br><span class="line"></span><br><span class="line">Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        w = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> i &lt; <span class="number">2</span> <span class="keyword">or</span> n != nums[w - <span class="number">2</span>]:</span><br><span class="line">                nums[w] = n</span><br><span class="line">                w += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> w</span><br></pre></td></tr></table></figure>
<p>高频：反正两周前的代码也看不懂了，抄个简单一点的…if i &lt; 2 or n != nums[w <strong>- 2</strong>]</p>
<h3 id="28-Implement-strStr-Easy"><a href="#28-Implement-strStr-Easy" class="headerlink" title="28. Implement strStr() (Easy)"></a><a href="https://leetcode.com/problems/implement-strstr/description/" target="_blank" rel="noopener">28. Implement strStr() (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Implement strStr().</span><br><span class="line"></span><br><span class="line">Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: haystack = "hello", needle = "ll"</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: haystack = "aaaaa", needle = "bba"</span><br><span class="line">Output: -1</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">What should we return when needle is an empty string? This is a great question to ask during an interview.</span><br><span class="line"></span><br><span class="line">For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().</span><br></pre></td></tr></table></figure>
<p>思路：快慢指针<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(needle) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(haystack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack)):</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> i + len(needle) - <span class="number">1</span> &lt; len(haystack):</span><br><span class="line">                    <span class="keyword">if</span> needle == haystack[i: i + len(needle)]:</span><br><span class="line">                        <span class="keyword">return</span> i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结: 思路是双指针没问题，实际用 python 的时候可以用 python 的性质直接取子串</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack: str, needle: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(needle) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(haystack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        end = len(haystack) - len(needle) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> end &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, end):</span><br><span class="line">            <span class="keyword">if</span> haystack[i:i + len(needle)] == needle:</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意空串的时候要返回 int 而不是 bool, needle 为空时，直接返回 0, 优化 end = len(haystack) - len(needle) + 1; if end &lt; 0: return -1; for i in range(0, end)<br>高频：考点 end = lh - ln + 1; … if haystack[i:i + ln] == needle: return i。代码能优化一点点，但是大同小异。</p>
<h3 id="283-Move-Zeroes-Easy"><a href="#283-Move-Zeroes-Easy" class="headerlink" title="283. Move Zeroes (Easy)"></a><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">283. Move Zeroes (Easy)</a></h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>Example:<br>Input: [0,1,0,3,12]<br>Output: [1,3,12,0,0]</p>
<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        l, r = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> r &lt; n:</span><br><span class="line">            <span class="keyword">while</span> nums[r] == <span class="number">0</span> <span class="keyword">and</span> r &lt; n - <span class="number">1</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：三刷出了更简洁的写法，跑测试用例的时候仍然要考虑 0 在左中右三种情况<br>高频：两个月没刷这题，导致思路僵化在一刷的l, r均从0，0开始需要考虑很多种情况的算法。三刷或者l, r从0，1开始代码就简洁很多（本质是一样的）。删掉一刷代码的复杂情况判断。 非要l，r从0，0开始，就不考虑各种情况，l，r永远前进<br>五刷：写出了也能过的代码，但是不如高频代码简洁</p>
<h3 id="125-Valid-Palindrome-Easy"><a href="#125-Valid-Palindrome-Easy" class="headerlink" title="125. Valid Palindrome (Easy)"></a><a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">125. Valid Palindrome (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</span><br><span class="line"></span><br><span class="line">Note: For the purpose of this problem, we define empty string as valid palindrome.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "A man, a plan, a canal: Panama"</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "race a car"</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>思路：头尾双指针， 碰头了返回 True，相同继续走，不同返回 False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span> <span class="keyword">or</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        head, tail = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[head].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[tail].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[head].lower() != s[tail].lower():</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：思路简单， 但是要想到的 case 很多。考虑带标点符号，连续两个位置都是标点符号，整个字符串都是标点符合这三个情况才能写对</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        head, tail = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[head].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[tail].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[head].lower() == s[tail].lower():</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：关键是知道 .isalnum() 这个 function<br>高频</p>
<h3 id="680-Valid-Palindrome-II-Easy"><a href="#680-Valid-Palindrome-II-Easy" class="headerlink" title="680. Valid Palindrome II (Easy)"></a><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">680. Valid Palindrome II (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: "aba"</span><br><span class="line">Output: True</span><br><span class="line">Example 2:</span><br><span class="line">Input: "abca"</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could delete the character 'c'.</span><br><span class="line">Note:</span><br><span class="line">The string will only contain lowercase characters a-z. The maximum length of the string is 50000.</span><br></pre></td></tr></table></figure>
<p>思路：目前网上看到大部分答案都以贪心算法为主，等看贪心了再刷这题。再看一眼感觉就是统计有没有 &gt; 2 单数的题，撸之<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># 要么删左边，要么删右边</span></span><br><span class="line">        <span class="keyword">return</span> self.isPalindrome(s[:l] + s[l + <span class="number">1</span>:]) <span class="keyword">or</span> self.isPalindrome(s[:r] + s[r + <span class="number">1</span>:])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：没那么简单，还要考虑这些情况 1.如果有 2 个 single 均不在 mid 位置；2. 去掉 single 点后的 string 仍然不是 palindrome; 3. 1 个 single，多个位置可以删除； 然后就抓狂了。 看了答案， 真他妈的妖。双指针算法。从两头走到中间，发现第一对不一样的字符之后，要么删左边的，要么删右边的。</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l &lt; r:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.isPalindrome(s[:l] + s[l + <span class="number">1</span>:]) <span class="keyword">or</span> self.isPalindrome(s[:r] + s[r + <span class="number">1</span>:])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：如一刷所说，是一道比较妖的题，背熟吧</p>
<h3 id="1-Two-Sum-Easy"><a href="#1-Two-Sum-Easy" class="headerlink" title="1. Two Sum (Easy)"></a><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">1. Two Sum (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span><br><span class="line"></span><br><span class="line">You may assume that each input would have exactly one solution, and you may not use the same element twice.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<p>思路：固定一个找另一个<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> index1 <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> index2 <span class="keyword">in</span> xrange(index1 + <span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[index1] + nums[index2] == target:</span><br><span class="line">                    <span class="keyword">return</span> [index1, index2]</span><br></pre></td></tr></table></figure></p>
<p>总结： 第二层循环的起始数字注意条件 you may not use the same element twice</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        lookup = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> lookup:</span><br><span class="line">                remain = target - val</span><br><span class="line">                lookup[remain] = idx</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> [lookup[val], idx]</span><br></pre></td></tr></table></figure></p>
<p>总结：除了双指针还有dict的解法，需要熟练掌握，信手拈来。注意遍历list用 for idx, val in enumerate(arr)<br>高频：用dict/hashmap的方法稍微有点绕，而且对后面的xsum没有帮助，掌握两层循环面试应该就够了</p>
<h3 id="167-Two-Sum-II-Input-array-is-sorted-Easy"><a href="#167-Two-Sum-II-Input-array-is-sorted-Easy" class="headerlink" title="167. Two Sum II - Input array is sorted (Easy)"></a><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">167. Two Sum II - Input array is sorted (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</span><br><span class="line"></span><br><span class="line">The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Your returned answers (both index1 and index2) are not zero-based.</span><br><span class="line">You may assume that each input would have exactly one solution and you may not use the same element twice.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure>
<p>思路：增加了 sorted 这个条件， 第一感觉是可以折半查找了。固定 index1，index2 用折半查找获得<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> index1 <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            start, end = index1 + <span class="number">1</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">                mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> numbers[index1] + numbers[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> [index1 + <span class="number">1</span>, mid + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> numbers[index1] + numbers[mid] &lt; target:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> numbers[index1] + numbers[start] == target:</span><br><span class="line">                <span class="keyword">return</span> [index1 + <span class="number">1</span>, start + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[index1] + numbers[end] == target:</span><br><span class="line">                <span class="keyword">return</span> [index1 + <span class="number">1</span>, end + <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：要细心。1.题中 answers are not zero-based 2.要测两个情况 [2, 7, 19], 9 和 [5, 25, 75] 可以测出代码的问题</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            tsum = numbers[l] + numbers[r]</span><br><span class="line">            <span class="keyword">if</span> tsum == target:</span><br><span class="line">                <span class="keyword">return</span> [l + <span class="number">1</span>, r + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> tsum &lt; target:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：二分法跑分不如直接双指针，可能是测试数据导致。双指针代码也简单很多</p>
<h3 id="LinC-607-Two-Sum-III-Data-structure-design-Easy"><a href="#LinC-607-Two-Sum-III-Data-structure-design-Easy" class="headerlink" title="LinC 607. Two Sum III - Data structure design (Easy)"></a><a href="https://www.lintcode.com/problem/two-sum-iii-data-structure-design/description" target="_blank" rel="noopener">LinC 607. Two Sum III - Data structure design (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Design and implement a TwoSum class. It should support the following operations: add and find.</span><br><span class="line"></span><br><span class="line">add - Add the number to an internal data structure.</span><br><span class="line">find - Find if there exists any pair of numbers which sum is equal to the value.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">add(1); add(3); add(5);</span><br><span class="line">find(4) // return true</span><br><span class="line">find(7) // return false</span><br></pre></td></tr></table></figure>
<p>思路：add 的时候把 sum 都存 dict 里面， 查的时候直接返回 dict 里面有没有 sum. 会超时。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span>:</span></span><br><span class="line">    keys = &#123;&#125;</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: number: An integer</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> number <span class="keyword">not</span> <span class="keyword">in</span> self.keys:</span><br><span class="line">            self.keys[number] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.keys[number] = <span class="number">2</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: value: An integer</span></span><br><span class="line"><span class="string">    @return: Find if there exists any pair of numbers which sum is equal to the value.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.keys:</span><br><span class="line">            <span class="keyword">if</span> value - key <span class="keyword">in</span> self.keys:</span><br><span class="line">                <span class="keyword">if</span> value - key == key:</span><br><span class="line">                    <span class="keyword">if</span> self.keys[key] == <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：虽然是一道容易题， 第一反应的思路会超时。 需要在 find 的时候判断能凑出答案的另一个 key 是不是已经在 keys 里了。而不是先存好 sum。 还要判断两个数相同的时候有没有存过两个数。</p>
<h3 id="15-3Sum-Medium"><a href="#15-3Sum-Medium" class="headerlink" title="15. 3Sum (Medium)"></a><a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">15. 3Sum (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The solution set must not contain duplicate triplets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：可以吧 a + b + c = 0 变为 a + b = - c 的问题，问题则变为， 对于任意数 a，dict 里是否存在 -c - a 这么个数， a 和 c 是两层循环<br>二刷：可以把天真的第一想法扔掉了：）。 就是以当前遍历的点 i 为基础的双指针。二刷比一刷有一点改进空间。python 的 list 就带一定的去重机制，可以少写几行去重代码。3 年前写的还是很牛逼的。。。靠，三年前的写法会 TLE。。。真是难度越来越高了。。。尼玛。。。注意：当 sum == 0 的时候需要在 ans.appen(); l += 1; r -= 1; 的基础上加 while l &lt; r and <strong>nums[l] == nums[l - 1]:</strong> l += 1 和 while l &lt; r and nums[r] == nums[r + 1]: r -= 1 这样的跳过语句才能 AC。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        results = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> index1 <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> index1 <span class="keyword">and</span> nums[index1] == nums[index1 - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            head = index1 + <span class="number">1</span></span><br><span class="line">            tail = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">                <span class="keyword">if</span> nums[index1] + nums[head] &gt; -nums[tail]:</span><br><span class="line">                    tail -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[index1] + nums[head] &lt; -nums[tail]:</span><br><span class="line">                    head += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    results.append([nums[index1], nums[head], nums[tail]])</span><br><span class="line">                    head += <span class="number">1</span></span><br><span class="line">                    tail -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> head &lt; tail <span class="keyword">and</span> nums[head] == nums[head - <span class="number">1</span>]:</span><br><span class="line">                        head += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> head &lt; tail <span class="keyword">and</span> nums[tail] == nums[tail + <span class="number">1</span>]:</span><br><span class="line">                        tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p>
<p>总结：三层循环是暴力方法，去重会受阻，这个时候需要想到给输入数组先排个序，因为结果里，没有要求元素的顺序，这是个重要的提示。排序以后每次固定一个数 index1，然后找的过程是：head = index1 + 1, tail = len(nums) - 1; while head &lt; tail:  if nums[index1] + nums[head] &gt; - nums[tail]: tail -= 1, elif nums[index1] + nums[head] &lt; -nums[tail]: head += 1, else: results.append()<br>代码还需要考虑的几个情况：1.对于已经用过的元素需要跳过， 这里要用到 if index1 and nums[index1] == nums[index1 - 1]; 2.如果碰到了一个 result，要跳过所有重复的元素，需要用到 while head &lt; tail and nums[head] == nums[head - 1]: 和相应的 …nums[tail + 1]</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        nums = sorted(nums)</span><br><span class="line">        <span class="keyword">for</span> idx, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> idx &gt; <span class="number">0</span> <span class="keyword">and</span> val == nums[idx - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            target = <span class="number">0</span> - val</span><br><span class="line">            l, r = idx + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                tsum = nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> tsum == target:</span><br><span class="line">                    ans.append([val, nums[l], nums[r]])</span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l + <span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r - <span class="number">1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> tsum &lt; target:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：注意在第一次遍历数组，找到目标这两个位置要去重</p>
<p>三刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            l = i + <span class="number">1</span></span><br><span class="line">            r = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                total = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> total &lt; <span class="number">0</span>:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> total &gt; <span class="number">0</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append([nums[i], nums[l], nums[r]])</span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l + <span class="number">1</span>]:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r - <span class="number">1</span>]:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：稍微优化了一下，更好懂，执行效率更高一点</p>
<h3 id="LinC-382-Triangle-Count-Medium"><a href="#LinC-382-Triangle-Count-Medium" class="headerlink" title="LinC 382. Triangle Count (Medium)"></a><a href="https://www.lintcode.com/problem/triangle-count/description" target="_blank" rel="noopener">LinC 382. Triangle Count (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers, how many three numbers can be found in the array, so that we can build an triangle whose three edges length is the three numbers that we find?</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given array S = [3,4,6,7], return 3. They are:</span><br><span class="line"></span><br><span class="line">[3,4,6]</span><br><span class="line">[3,6,7]</span><br><span class="line">[4,6,7]</span><br><span class="line">Given array S = [4,4,4,4], return 4. They are:</span><br><span class="line"></span><br><span class="line">[4(1),4(2),4(3)]</span><br><span class="line">[4(1),4(2),4(4)]</span><br><span class="line">[4(1),4(3),4(4)]</span><br><span class="line">[4(2),4(3),4(4)]</span><br></pre></td></tr></table></figure>
<p>思路： 判断能不能做三角形以后全排列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param S: A list of integers</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triangleCount</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        S.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index1, longest <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            head, tail = index1 + <span class="number">1</span>, index1 + <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> tail &lt; len(S) <span class="keyword">and</span> S[head] + S[tail] &gt; longest:</span><br><span class="line">                tail += <span class="number">1</span></span><br><span class="line">            tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">                sum += tail - head</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> head &lt; tail <span class="keyword">and</span> S[head] + S[tail] &lt;= longest:</span><br><span class="line">                    tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p>
<p>总结：看清题目，问的是有多少个这样的三角形， 返回数就行。 全排列效率比较低。 更优解是每次定下最长边， 寻找符合条件的另外两个边的数量。 双指针的解法是将 tail 推到最小不能组成三角形的位置， 退一步， 然后从 tail 到 head 的位置的都可以组， 因为他们相加只会比最长边更长。 然后将 head 进一步（缩短），tail 边加长到大于最长边的位置，新 tail 到 head 的位置又都可以组。</p>
<h3 id="16-3Sum-Closest-Medium"><a href="#16-3Sum-Closest-Medium" class="headerlink" title="16. 3Sum Closest (Medium)"></a><a href="https://leetcode.com/problems/3sum-closest/description/" target="_blank" rel="noopener">16. 3Sum Closest (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="keyword">None</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">            l, r = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                t = nums[i] + nums[l] + nums[r]</span><br><span class="line">                <span class="keyword">if</span> t == target:</span><br><span class="line">                    <span class="keyword">return</span> t</span><br><span class="line">                <span class="keyword">elif</span> t &lt; target:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> ans == <span class="keyword">None</span> <span class="keyword">or</span> abs(t - target) &lt; abs(ans - target):</span><br><span class="line">                    ans = t</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：将1，2刷的代码思路总结都删了，都差不多。注意这里没有mid，不是二分查找。</p>
<h3 id="LinC-31-Partition-Array-Medium"><a href="#LinC-31-Partition-Array-Medium" class="headerlink" title="LinC 31. Partition Array (Medium)"></a><a href="https://www.lintcode.com/problem/partition-array/description" target="_blank" rel="noopener">LinC 31. Partition Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Description</span><br><span class="line">Given an array nums of integers and an int k, partition the array (i.e move the elements in "nums") such that:</span><br><span class="line"></span><br><span class="line">All elements <span class="tag">&lt; <span class="attr">k</span> <span class="attr">are</span> <span class="attr">moved</span> <span class="attr">to</span> <span class="attr">the</span> <span class="attr">left</span></span></span><br><span class="line"><span class="tag"><span class="attr">All</span> <span class="attr">elements</span> &gt;</span>= k are moved to the right</span><br><span class="line">Return the partitioning index, i.e the first index i nums[i] &gt;= k.</span><br><span class="line"></span><br><span class="line">You should do really partition in array nums instead of just counting the numbers of integers smaller than k.</span><br><span class="line"></span><br><span class="line">If all elements in nums are smaller than k, then return nums.length</span><br><span class="line">Example</span><br><span class="line">If nums = [3,2,2,1] and k=2, a valid answer is 1.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">Can you partition the array in-place and in O(n)?</span><br></pre></td></tr></table></figure>
<p>思路：和 partition list 很像， 数组的话就只能用双指针了. l 是最后一个 &lt; k, r 是最后一个 &gt;= k<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: The integer array you should partition</span></span><br><span class="line"><span class="string">    @param k: An integer</span></span><br><span class="line"><span class="string">    @return: The index after partition</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionArray</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">while</span> l &lt; len(nums) <span class="keyword">and</span> nums[l] &lt; k:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> r &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[r] &gt;= k:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure></p>
<p>总结：因为数组比链表好操作的多， 比 partition list 解法简单， 需要注意：1。while 的条件是 l &lt;= r 2。l 往右走，r 往左走不要越界，r 往左需要 r &gt;= 0 3.l &gt; r 的时候需要 break</p>
<h3 id="215-Kth-Largest-Element-in-an-Array-Medium"><a href="#215-Kth-Largest-Element-in-an-Array-Medium" class="headerlink" title="215. Kth Largest Element in an Array (Medium)"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">215. Kth Largest Element in an Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br><span class="line">Note:</span><br><span class="line">You may assume k is always valid, 1 ≤ k ≤ array's length.</span><br></pre></td></tr></table></figure>
<p>思路：现场想是基本没戏。quickselect算法，基于quicksort<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k: int)</span> -&gt; int:</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            hi = l</span><br><span class="line">            <span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">            ri = randint(l, r)</span><br><span class="line">            nums[ri], nums[r] = nums[r], nums[ri]</span><br><span class="line">            <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(nums[l:r], l):</span><br><span class="line">                <span class="keyword">if</span> v &gt; nums[r]:</span><br><span class="line">                    nums[i], nums[hi] = nums[hi], nums[i]</span><br><span class="line">                    hi += <span class="number">1</span></span><br><span class="line">            nums[hi], nums[r] = nums[r], nums[hi]</span><br><span class="line">            <span class="keyword">if</span> hi &lt; k:</span><br><span class="line">                <span class="keyword">return</span> quickSelect(hi + <span class="number">1</span>, r)                </span><br><span class="line">            <span class="keyword">elif</span> hi &gt; k:</span><br><span class="line">                <span class="keyword">return</span> quickSelect(l, hi - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[hi]</span><br><span class="line">        <span class="keyword">return</span> quickSelect(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：注意：递归调用的时候记得函数名前要加 return 否则不会返回任何值。由于完全抛弃另一侧，时间复杂度平均由 quick sort 的 O(nlogn) 降为 O(n) 因为输入变小了， quicksort 的输入一直是 n, 最差情况 O(n^2)<br>二刷：改动较大，删掉一刷帮助不大的代码。注意：递归调用的时候记得函数名前要加 return 否则不会返回任何值。…hi = l…for i, v in enumerate(nums[l:r], l):…</p>
<h3 id="75-Sort-Colors-Medium"><a href="#75-Sort-Colors-Medium" class="headerlink" title="75. Sort Colors (Medium)"></a><a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="noopener">75. Sort Colors (Medium)</a></h3><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.<br>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note: You are not suppose to use the library’s sort function for this problem.</p>
<p>Example:<br>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]<br>Follow up:</p>
<p>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with a one-pass algorithm using only constant space?</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        l, r, i = <span class="number">0</span>, len(nums) - <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= r:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">0</span> <span class="keyword">and</span> i &gt; l:</span><br><span class="line">                nums[l], nums[i] = nums[i], nums[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">2</span> <span class="keyword">and</span> i &lt; r:</span><br><span class="line">                nums[i], nums[r] = nums[r], nums[i]</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：in place 不数元素的话得用 l, r 和 i, 要过的话需要熟记交换的第二条件分别为 i &gt; l 和 i &lt; r, 其他情况 i 均前进<br>高频：去掉了一刷繁琐的方法。counting sort只需要count 0和1。1 pass：…while i &lt;= r:…and i &gt; l:…and i &lt; r:…<br>面经：Celo。3个数要保持两个边界l和r，和一个worker i，交换条件要加…i &gt; l…和…i &lt; r，否则会过度交换导致结果有bug</p>
<h3 id="18-4Sum-Medium"><a href="#18-4Sum-Medium" class="headerlink" title="18. 4Sum (Medium)"></a><a href="https://leetcode.com/problems/4sum/description/" target="_blank" rel="noopener">18. 4Sum (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The solution set must not contain duplicate quadruplets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：看了下三年前的答案，不是特别直观。看了九章的答案，貌似好理解一点：去重，枚举一个数，然后用 3Sum 的做法，O(N^3)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums) - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums) - <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j != i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                l, r = j + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[l] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> sum == target:</span><br><span class="line">                        ans.append([nums[i], nums[j], nums[l], nums[r]])</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：有一个自己肯定想不出的条件就是第二层循环怎么跳过：<strong>if j != i + 1 and nums[j] == nums[j - 1]: continue</strong>; 非常勉强能过 AC. 看了网上和三年前的，都是用 dict 先存 2sum，然后再 loop 两遍，用 if pair[0] &gt; j 来去重（第三个元素的 index 要大于前面两个）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">nsum</span><span class="params">(l, r, N, target, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> r - l + <span class="number">1</span> &lt; N <span class="keyword">or</span> N &lt; <span class="number">2</span> <span class="keyword">or</span> N &gt; len(nums) <span class="keyword">or</span> N * nums[l] &gt; target <span class="keyword">or</span> N * nums[r] &lt; target:</span><br><span class="line">                <span class="keyword">return</span>        </span><br><span class="line">            <span class="keyword">if</span> N == <span class="number">2</span>:                    </span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    t = nums[l] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> t == target:</span><br><span class="line">                        ans.append(path + [nums[l], nums[r]])</span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l + <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r - <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> t &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> i == l <span class="keyword">or</span> (i &gt; l <span class="keyword">and</span> nums[i] != nums[i - <span class="number">1</span>]):</span><br><span class="line">                        nsum(i + <span class="number">1</span>, r, N - <span class="number">1</span>, target - nums[i], path + [nums[i]])</span><br><span class="line">        nums.sort()</span><br><span class="line">        nsum(<span class="number">0</span>, len(nums) - <span class="number">1</span>, <span class="number">4</span>, target, [])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>二刷：看 leetcode ac 的流行答案， 返回递归 nsum， 递归内终结条件为解决 2sum，，注意两处去重，1.找到 target 以后，在 l &lt; r 条件下跳过所有后面与 l 相同的；2.进入 nsum 前，if i == 0 or (i &gt; 0 and nums[i - 1] != nums[i])<br>总结：很多坑，N == 2 时要注意 while l &lt; r 做二分法；N &gt; 2 时 for i in range(l, r + 1); nsum(i + 1, …); 如是高频题需要练熟<br>高频：…def nsum(l, r, N, target, path): if r - l + 1 &lt; N or N &lt; 2 or…if N == 2: while l &lt; r:…  while l &lt; r and nums[l] == nums[l + 1]:…while…l += 1; r -= 1…  for i in range(l, r + 1): if (i == l) or…: nsum(i + 1, r…)…</p>
<h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">27. Remove Element</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums and a value val, remove all instances of that value in-place and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">The order of elements can be changed. It doesn't matter what you leave beyond the new length.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums = [3,2,2,3], val = 3,</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 2.</span><br><span class="line"></span><br><span class="line">It doesn't matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums = [0,1,2,2,3,0,4,2], val = 2,</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.</span><br><span class="line"></span><br><span class="line">Note that the order of those five elements can be arbitrary.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeElement</span><span class="params">(self, nums: List[int], val: int)</span> -&gt; int:</span></span><br><span class="line">        ans = len(nums)</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        j = ans - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= j:</span><br><span class="line">            <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[i] != val:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> i &lt;= j <span class="keyword">and</span> nums[j] == val:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                ans -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; j:</span><br><span class="line">                nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：背while i <strong>&lt;=</strong> j: while i &lt;= j and … while i &lt;= j and …if i &lt; j: …</p>
<h3 id="19-Remove-Nth-Node-From-End-of-List-Medium"><a href="#19-Remove-Nth-Node-From-End-of-List-Medium" class="headerlink" title="19. Remove Nth Node From End of List (Medium)"></a><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a linked list, remove the n-th node from the end of list and return its head.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.</span><br><span class="line"></span><br><span class="line">After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Given n will always be valid.</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">Could you do this in one pass?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeNthFromEnd</span><span class="params">(self, head: ListNode, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        fast = slow = dummy</span><br><span class="line">        <span class="keyword">while</span> n:</span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            fast = fast.next</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">        slow.next = slow.next.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<p>高频：dummy = ListNode(0)…fast = slow = dummy…slow.next = slow.next.next…</p>
<h3 id="11-Container-With-Most-Water-Medium"><a href="#11-Container-With-Most-Water-Medium" class="headerlink" title="11. Container With Most Water (Medium)"></a><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</span><br><span class="line"></span><br><span class="line">Note: You may not slant the container and n is at least 2.</span><br><span class="line"></span><br><span class="line">The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxArea</span><span class="params">(self, height: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans, l, r = <span class="number">0</span>, <span class="number">0</span>, len(height) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            ans = max(ans, (r - l) * min(height[l], height[r]))</span><br><span class="line">            <span class="keyword">if</span> height[l] &lt; height[r]:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：除了…while l &lt; r: ans = max(…min(…))…并学不到什么东西</p>
<h3 id="345-Reverse-Vowels-of-a-String-Easy"><a href="#345-Reverse-Vowels-of-a-String-Easy" class="headerlink" title="345. Reverse Vowels of a String (Easy)"></a><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. Reverse Vowels of a String (Easy)</a></h3><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p>Example 1:<br>Input: “hello”<br>Output: “holle”</p>
<p>Example 2:<br>Input: “leetcode”<br>Output: “leotcede”<br>Note:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">"aeiouAEIOU"</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> <span class="string">"aeiouAEIOU"</span>:</span><br><span class="line">                s = s[:i] + stack.pop() + s[i + <span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> s</span><br></pre></td></tr></table></figure></p>
<p>inplace:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseVowels</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        arr = list(s)</span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">while</span> arr[l] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"aeiouAEIOU"</span> <span class="keyword">and</span> l &lt; len(s) - <span class="number">1</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> arr[r] <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">"aeiouAEIOU"</span> <span class="keyword">and</span> r &gt; <span class="number">0</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &lt; r:</span><br><span class="line">                arr[l], arr[r] = arr[r], arr[l]</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(arr)</span><br></pre></td></tr></table></figure></p>
<p>面经：DJI。</p>
<h1 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS 广度优先搜索"></a>BFS 广度优先搜索</h1><p>图的遍历 Traversal in Graph</p>
<ul>
<li>层级遍历 Level Order Traversal</li>
<li>由点及面 Connected Component</li>
<li>拓扑排序 Topological Sorting</li>
</ul>
<p>最短路径 Shortest Path in Simple Graph</p>
<ul>
<li>仅限简单图求最短路径。即，图中每条边长度都是1，或者边长都相等</li>
</ul>
<h3 id="695-Max-Area-of-Island-Medium"><a href="#695-Max-Area-of-Island-Medium" class="headerlink" title="695. Max Area of Island (Medium)"></a><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">695. Max Area of Island (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</span><br><span class="line"></span><br><span class="line">Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</span><br><span class="line">Example 2:</span><br><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line">Given the above grid, return 0.</span><br><span class="line">Note: The length of each dimension in the given grid does not exceed 50.</span><br></pre></td></tr></table></figure>
<p>思路：没啥太多好说的，BFS 暴力<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(grid) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[row][col] == <span class="number">1</span>:</span><br><span class="line">                    ans = max(self.bfs(grid, row, col), ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, grid, row, col)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append((row, col))</span><br><span class="line">        grid[row][col] = <span class="number">0</span></span><br><span class="line">        size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            row, col = q.popleft()</span><br><span class="line">            size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row - <span class="number">1</span>, col) <span class="keyword">and</span> grid[row - <span class="number">1</span>][col] == <span class="number">1</span>:</span><br><span class="line">                q.append((row - <span class="number">1</span>, col))</span><br><span class="line">                grid[row - <span class="number">1</span>][col] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row + <span class="number">1</span>, col) <span class="keyword">and</span> grid[row + <span class="number">1</span>][col] == <span class="number">1</span>:</span><br><span class="line">                q.append((row + <span class="number">1</span>, col))</span><br><span class="line">                grid[row + <span class="number">1</span>][col] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row, col - <span class="number">1</span>) <span class="keyword">and</span> grid[row][col - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                q.append((row, col - <span class="number">1</span>))</span><br><span class="line">                grid[row][col - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row, col + <span class="number">1</span>) <span class="keyword">and</span> grid[row][col + <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                q.append((row, col + <span class="number">1</span>))</span><br><span class="line">                grid[row][col + <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, grid, row, col)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; len(grid) <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; len(grid[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>总结：在上下左右走的时候注意入 q 以后立刻将该点标为 0， 以防同一个点入两次。<br>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(grid) == <span class="number">0</span> <span class="keyword">or</span> len(grid[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="number">1</span>:</span><br><span class="line">                    s = <span class="number">0</span></span><br><span class="line">                    q = collections.deque()</span><br><span class="line">                    q.append((r, c))</span><br><span class="line">                    grid[r][c] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">while</span> len(q) &gt; <span class="number">0</span>:</span><br><span class="line">                        (rq, cq) = q.popleft()</span><br><span class="line">                        s += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">if</span> rq &gt; <span class="number">0</span> <span class="keyword">and</span> grid[rq - <span class="number">1</span>][cq] == <span class="number">1</span>:</span><br><span class="line">                            q.append((rq - <span class="number">1</span>, cq))</span><br><span class="line">                            grid[rq - <span class="number">1</span>][cq] = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">if</span> rq &lt; len(grid) - <span class="number">1</span> <span class="keyword">and</span> grid[rq + <span class="number">1</span>][cq] == <span class="number">1</span>:</span><br><span class="line">                            q.append((rq + <span class="number">1</span>, cq))</span><br><span class="line">                            grid[rq + <span class="number">1</span>][cq] = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">if</span> cq &gt; <span class="number">0</span> <span class="keyword">and</span> grid[rq][cq - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                            q.append((rq, cq - <span class="number">1</span>))</span><br><span class="line">                            grid[rq][cq - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">                        <span class="keyword">if</span> cq &lt; len(grid[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> grid[rq][cq + <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                            q.append((rq, cq + <span class="number">1</span>))</span><br><span class="line">                            grid[rq][cq + <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">                    <span class="keyword">if</span> s &gt; ans:</span><br><span class="line">                        ans = s</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：一次写完， 没有像一刷那样拆成三个函数。 各有优劣吧。注意清零的位置要在放 queue 之后立刻清零，以防同一个点如两次， lol 二刷踩同样的坑 :’(</p>
<h3 id="102-Binary-Tree-Level-Order-Traversal-Medium"><a href="#102-Binary-Tree-Level-Order-Traversal-Medium" class="headerlink" title="102. Binary Tree Level Order Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">return its level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            level = []</span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> q:</span><br><span class="line">                level += [n.val]</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nq.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nq.append(n.right)</span><br><span class="line">            q = nq</span><br><span class="line">            ans.append(level)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>二刷：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">107. Binary Tree Level Order Traversal II (Easy)</a> 没毛病，注意：list.reverse() 是 in place, 不返回 list 可以 ans.reverse() return ans, 或者啰嗦点的 list(reversed(ans)) 返回 list。用 deque 其实是多余的，因为每个 level 的 q 都直接扔掉（拼出来的下一层的 newQ 取代），可以用 list，for 循环一遍就可以了。<br>总结：注意外层用 while， 内层用 for 来遍历之前放进去的每一层节点<br>高频：deque高效q，…if not root: return ans…level = [], nq = collections.deque()</p>
<h3 id="107-Binary-Tree-Level-Order-Traversal-II-Easy"><a href="#107-Binary-Tree-Level-Order-Traversal-II-Easy" class="headerlink" title="107. Binary Tree Level Order Traversal II (Easy)"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">107. Binary Tree Level Order Traversal II (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">return its bottom-up level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrderBottom</span><span class="params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(root, level)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> level &gt; len(ans) - <span class="number">1</span>:</span><br><span class="line">                ans.append([])</span><br><span class="line">            ans[level].append(root.val)</span><br><span class="line">            bfs(root.left, level + <span class="number">1</span>)</span><br><span class="line">            bfs(root.right, level + <span class="number">1</span>)</span><br><span class="line">        bfs(root, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：用q跟上题代码一样，加个递归的解法，…def bfs(root, level):…</p>
<h3 id="103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/" target="_blank" rel="noopener">103. Binary Tree Zigzag Level Order Traversal (Medium)</a></h3><p><a href="http://www.lintcode.com/en/problem/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">LinC 71. Binary Tree Zigzag Order Traversal</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">return its zigzag level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>思路：reverse 初始为 0，每层 1 - reverse, reverse == 1 就 reverse<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        reverse = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:        </span><br><span class="line">            temp = []</span><br><span class="line">            newQ = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> q:</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    newQ.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    newQ.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> reverse:</span><br><span class="line">                temp.reverse()</span><br><span class="line">            reverse = <span class="number">1</span> - reverse</span><br><span class="line">            ans.append(temp)</span><br><span class="line">            q = newQ</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：一次过，可做可不做吧<br>高频：同一次过，优化空间为可以用deque()的popleft()和pop()来省一个reverse()的时间</p>
<h3 id="133-Clone-Graph-Medium"><a href="#133-Clone-Graph-Medium" class="headerlink" title="133. Clone Graph (Medium)"></a><a href="https://leetcode.com/problems/clone-graph/description/" target="_blank" rel="noopener">133. Clone Graph (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"https://assets.leetcode.com/uploads/2019/02/19/113_sample.png"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">alt</span>=<span class="string">"graph example"</span>/&gt;</span></span><br><span class="line">Input:</span><br><span class="line">&#123;"$id":"1","neighbors":[&#123;"$id":"2","neighbors":[&#123;"$ref":"1"&#125;,&#123;"$id":"3","neighbors":[&#123;"$ref":"2"&#125;,&#123;"$id":"4","neighbors":[&#123;"$ref":"3"&#125;,&#123;"$ref":"1"&#125;],"val":4&#125;],"val":3&#125;],"val":2&#125;,&#123;"$ref":"4"&#125;],"val":1&#125;</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">Node 1's value is 1, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 2's value is 2, and it has two neighbors: Node 1 and 3.</span><br><span class="line">Node 3's value is 3, and it has two neighbors: Node 2 and 4.</span><br><span class="line">Node 4's value is 4, and it has two neighbors: Node 1 and 3.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">The number of nodes will be between 1 and 100.</span><br><span class="line">The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.</span><br><span class="line">Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.</span><br><span class="line">You must return the copy of the given node as a reference to the cloned graph.</span><br></pre></td></tr></table></figure>
<p>思路：BFS, 用一个 dict 存当前节点的邻居，如果没见过就加 dict 存 queue，queue 出来建 node，放 neighbor；概念上比较好懂，写码可能有坑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a undirected graph node</span></span><br><span class="line"><span class="comment"># class UndirectedGraphNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.neighbors = []</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param node, a undirected graph node</span></span><br><span class="line">    <span class="comment"># @return a undirected graph node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        _cloneNode = UndirectedGraphNode(node.label)</span><br><span class="line">        dict[node] = _cloneNode</span><br><span class="line">        q = [node]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            new_q = []</span><br><span class="line">            <span class="keyword">for</span> _node <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> _node.neighbors:</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                        _cloneNode = UndirectedGraphNode(neighbor.label)</span><br><span class="line">                        dict[neighbor] = _cloneNode</span><br><span class="line">                        new_q.append(neighbor)</span><br><span class="line">                    dict[_node].neighbors.append(dict[neighbor])    </span><br><span class="line">            q = new_q</span><br><span class="line">        <span class="keyword">return</span> dict[node]</span><br></pre></td></tr></table></figure></p>
<p>总结：思路用 dict 来存当前节点的邻居是错的，需要用 dict 存当前节点和克隆节点的映射关系。因为反正映射关系在，加邻居可以后加. 邻居是不能直接 copy 或者 = 的， 因为邻居的类型也是节点， 需要创造以后加进去。测一下，然后 debug 细一点， 要测出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict[_node].neighbors.append(dict[neighbor])</span><br></pre></td></tr></table></figure></p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val, neighbors):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.neighbors = neighbors</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        d = &#123;&#125;</span><br><span class="line">        n = Node(node.val, [])</span><br><span class="line">        <span class="keyword">if</span> node.neighbors == <span class="keyword">None</span> <span class="keyword">or</span> len(node.neighbors) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        d[node] = n</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append(node)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            nq = q.popleft()</span><br><span class="line">            <span class="keyword">if</span> nq <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                n = Node(nq.val, [])</span><br><span class="line">                d[nq] = n</span><br><span class="line">            <span class="keyword">for</span> nn <span class="keyword">in</span> nq.neighbors:</span><br><span class="line">                <span class="keyword">if</span> nn <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">                    q.append(nn)</span><br><span class="line">                    n = Node(nn.val, [])</span><br><span class="line">                    d[nn] = n    </span><br><span class="line">                d[nq].neighbors.append(d[nn])</span><br><span class="line">        <span class="keyword">return</span> d[node]</span><br></pre></td></tr></table></figure></p>
<p>总结：二刷第一遍没有想到 nn 在不在 d 里面，都要加入到克隆出来的节点的 neighbors 中去。此次击败了 100% 的内存使用，如需提高速度，可以增加一个 visited = set() 如果已经访问过就 return，可以用空间换时间</p>
<h3 id="127-Word-Ladder-Medium"><a href="#127-Word-Ladder-Medium" class="headerlink" title="127. Word Ladder (Medium)"></a><a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="noopener">127. Word Ladder (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</span><br><span class="line"></span><br><span class="line">Only one letter can be changed at a time.</span><br><span class="line">Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Return 0 if there is no such transformation sequence.</span><br><span class="line">All words have the same length.</span><br><span class="line">All words contain only lowercase alphabetic characters.</span><br><span class="line">You may assume no duplicates in the word list.</span><br><span class="line">You may assume beginWord and endWord are non-empty and are not the same.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">beginWord = "hit",</span><br><span class="line">endWord = "cog",</span><br><span class="line">wordList = ["hot","dot","dog","lot","log","cog"]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog",</span><br><span class="line">return its length 5.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">beginWord = "hit"</span><br><span class="line">endWord = "cog"</span><br><span class="line">wordList = ["hot","dot","dog","lot","log"]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>
<p>思路：确实是寻找路径的问题，从 beginWord 到 endWord 是否存在最短路径让他俩相连，最短路径取决于词库里有哪些词（路径）。怎么实现很不清晰<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> beginWord == endWord:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        wordSet = set(wordList)</span><br><span class="line">        q = collections.deque([[beginWord, <span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            word, level = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                <span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>:</span><br><span class="line">                    newWord = word[:index] + char + word[index + <span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> newWord <span class="keyword">in</span> wordSet:</span><br><span class="line">                        <span class="keyword">if</span> newWord == endWord:</span><br><span class="line">                            <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                        wordSet.remove(newWord)</span><br><span class="line">                        q.append([newWord, level + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>总结：看了下答案，网上答案解释的比较好理解的是，起始词是树的根节点，每一层是从第一个字母到最后一个字母，每次一个字母，从 a - z 替换过一遍，同时又在 wordList 里的词。从上往下 BFS，找到 endWord 即返回当前 level。啧啧啧，强大的应用题。逻辑对还得不 TLE 需要1.将 wordList 转成 set；2.使用 collections.deque；3.碰到 wordSet 中的词，先该词在 wordSet 中删除，再入 deque</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class="line">        wordSet = set(wordList)</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append((beginWord, <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            word, level = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(beginWord)):</span><br><span class="line">                <span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">"abcdefghijklmnopqrstuvwxyz"</span>:</span><br><span class="line">                    newWord = word[:i] + letter + word[i + <span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> newWord <span class="keyword">in</span> wordSet:</span><br><span class="line">                        <span class="keyword">if</span> newWord == endWord:</span><br><span class="line">                            <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                        q.append((newWord, level + <span class="number">1</span>))</span><br><span class="line">                        wordSet.remove(newWord)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>总结：几个要点，1.明白deque的作用是将wordList中的词通过每次改一个字母的方式挪到一个堆栈中，然后逐步的以(word, level)的形式pop出来，直到堆栈为空或者找到目标词 2.明白每一层遍历每一个位置上的字母所有可能性，由于每次找到一个词都会将其在wordList中去除，因此不用担心重复 3. deque.popleft() 而非 popLeft() 需要注意 4.裁剪字符串的时候要注意[：终点] [起点:] 终点是不包括的，起点是包括的，因此，裁掉位置在i的字符需要用 word[:i] + letter + word[i + 1:] 5.判断结果是否找到的语句要放在判断词是否在wordSet里之内</p>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord: str, endWord: str, wordList: List[str])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(beginWord) != len(endWord) <span class="keyword">or</span> len(wordList) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> wordList:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(beginWord)):</span><br><span class="line">                tmp = word[:i] + <span class="string">"*"</span> + word[i + <span class="number">1</span>:]</span><br><span class="line">                graph[tmp].append(word)</span><br><span class="line">        visited = set(beginWord)</span><br><span class="line">        q = collections.deque([(beginWord, <span class="number">1</span>)])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            tmp, level = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(beginWord)):</span><br><span class="line">                pattern = tmp[:i] + <span class="string">"*"</span> + tmp[i + <span class="number">1</span>:]</span><br><span class="line">                <span class="keyword">for</span> word <span class="keyword">in</span> graph[pattern]:</span><br><span class="line">                    <span class="keyword">if</span> word == endWord:</span><br><span class="line">                        <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> word <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        visited.add(word)</span><br><span class="line">                        q.append((word, level + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>总结：新算法，先建一个defaultdict的词库，然后bfs，效率高一些，空间换时间。背：graph[temp].append(word); … visited = set(beginWord); q = collections.deque([(beginWord, 1)]); … pattern = tmp[:i] + tmp[i + 1:]; for word in graph[pattern]: … if word not in visited:…</p>
<h3 id="200-Number-of-Islands-Medium"><a href="#200-Number-of-Islands-Medium" class="headerlink" title="200. Number of Islands (Medium)"></a><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">200. Number of Islands (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>思路：遍历矩阵，碰到 1 就上下左右 BFS，碰到 0 跳过。BFS 访问过的标 0<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(grid) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> rowI <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> colI <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[rowI][colI] == <span class="string">"1"</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    q = collections.deque([[rowI, colI]])</span><br><span class="line">                    grid[rowI][colI] = <span class="string">"0"</span></span><br><span class="line">                    <span class="keyword">while</span> q:</span><br><span class="line">                        row, col = q.popleft()</span><br><span class="line">                        <span class="comment"># up</span></span><br><span class="line">                        <span class="keyword">if</span> (row &gt; <span class="number">0</span>) <span class="keyword">and</span> grid[row - <span class="number">1</span>][col] == <span class="string">"1"</span>:</span><br><span class="line">                                q.append([row - <span class="number">1</span>, col])</span><br><span class="line">                                grid[row - <span class="number">1</span>][col] = <span class="string">'0'</span></span><br><span class="line">                        <span class="comment"># down</span></span><br><span class="line">                        <span class="keyword">if</span> (row &lt; len(grid) - <span class="number">1</span>) <span class="keyword">and</span> grid[row + <span class="number">1</span>][col] == <span class="string">"1"</span>:</span><br><span class="line">                                q.append([row + <span class="number">1</span>, col])</span><br><span class="line">                                grid[row + <span class="number">1</span>][col] = <span class="string">'0'</span></span><br><span class="line">                        <span class="comment"># left</span></span><br><span class="line">                        <span class="keyword">if</span> (col &gt; <span class="number">0</span>) <span class="keyword">and</span> grid[row][col - <span class="number">1</span>] == <span class="string">"1"</span>:</span><br><span class="line">                                q.append([row, col - <span class="number">1</span>])</span><br><span class="line">                                grid[row][col - <span class="number">1</span>] = <span class="string">'0'</span></span><br><span class="line">                        <span class="comment"># right</span></span><br><span class="line">                        <span class="keyword">if</span> (col &lt; len(grid[<span class="number">0</span>]) - <span class="number">1</span>) <span class="keyword">and</span> grid[row][col + <span class="number">1</span>] == <span class="string">"1"</span>:</span><br><span class="line">                                q.append([row, col + <span class="number">1</span>])</span><br><span class="line">                                grid[row][col + <span class="number">1</span>] = <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：对于 leetcode ac 比较重要的细节是，gird[][] = ‘0’ 这句话要在 while 的每个 if 里面，否则逻辑 OK 但是会 TLE</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid: List[List[str]])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(grid) == <span class="number">0</span> <span class="keyword">or</span> len(grid[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[r][c] == <span class="string">"1"</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    grid[r][c] = <span class="string">"0"</span></span><br><span class="line">                    q.append((r, c))</span><br><span class="line">                    <span class="keyword">while</span> q:</span><br><span class="line">                        nr, nc = q.popleft()</span><br><span class="line">                        <span class="keyword">if</span> nr - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[nr - <span class="number">1</span>][nc] == <span class="string">"1"</span>:</span><br><span class="line">                            grid[nr - <span class="number">1</span>][nc] = <span class="string">"0"</span></span><br><span class="line">                            q.append((nr <span class="number">-1</span>, nc))</span><br><span class="line">                        <span class="keyword">if</span> nr + <span class="number">1</span> &lt; len(grid) <span class="keyword">and</span> grid[nr + <span class="number">1</span>][nc] == <span class="string">"1"</span>:</span><br><span class="line">                            grid[nr + <span class="number">1</span>][nc] = <span class="string">"0"</span></span><br><span class="line">                            q.append((nr + <span class="number">1</span>, nc))</span><br><span class="line">                        <span class="keyword">if</span> nc - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> grid[nr][nc - <span class="number">1</span>] == <span class="string">"1"</span>:</span><br><span class="line">                            grid[nr][nc - <span class="number">1</span>] = <span class="string">"0"</span></span><br><span class="line">                            q.append((nr, nc - <span class="number">1</span>))</span><br><span class="line">                        <span class="keyword">if</span> nc + <span class="number">1</span> &lt; len(grid[<span class="number">0</span>]) <span class="keyword">and</span> grid[nr][nc + <span class="number">1</span>] == <span class="string">"1"</span>:</span><br><span class="line">                            grid[nr][nc + <span class="number">1</span>] = <span class="string">"0"</span></span><br><span class="line">                            q.append((nr, nc + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：比较直观，注意island是用字符串“1”而非数字1代表的</p>
<h3 id="LinC-611-Knight-Shortest-Path-Medium"><a href="#LinC-611-Knight-Shortest-Path-Medium" class="headerlink" title="LinC 611. Knight Shortest Path (Medium)"></a><a href="https://www.lintcode.com/problem/knight-shortest-path/description" target="_blank" rel="noopener">LinC 611. Knight Shortest Path (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.</span><br><span class="line">Return -1 if knight can not reached.</span><br><span class="line"></span><br><span class="line">source and destination must be empty.</span><br><span class="line">Knight can not enter the barrier.</span><br><span class="line"></span><br><span class="line">Clarification</span><br><span class="line">If the knight is at (x, y), he can get to the following positions in one step:</span><br><span class="line"></span><br><span class="line">(x + 1, y + 2)</span><br><span class="line">(x + 1, y - 2)</span><br><span class="line">(x - 1, y + 2)</span><br><span class="line">(x - 1, y - 2)</span><br><span class="line">(x + 2, y + 1)</span><br><span class="line">(x + 2, y - 1)</span><br><span class="line">(x - 2, y + 1)</span><br><span class="line">(x - 2, y - 1)</span><br><span class="line">Example</span><br><span class="line">[[0,0,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">source = [2, 0] destination = [2, 2] return 2</span><br><span class="line"></span><br><span class="line">[[0,1,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">source = [2, 0] destination = [2, 2] return 6</span><br><span class="line"></span><br><span class="line">[[0,1,0],</span><br><span class="line"> [0,0,1],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">source = [2, 0] destination = [2, 2] return -1</span><br></pre></td></tr></table></figure>
<p>思路：没什么思路， 看了下答案，就是 BFS 硬来，需要检查走了某个方向以后是不是还是在棋盘内<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition for a point.</span></span><br><span class="line"><span class="string">class Point:</span></span><br><span class="line"><span class="string">    def __init__(self, a=0, b=0):</span></span><br><span class="line"><span class="string">        self.x = a</span></span><br><span class="line"><span class="string">        self.y = b</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param grid: a chessboard included 0 (false) and 1 (true)</span></span><br><span class="line"><span class="string">    @param source: a point</span></span><br><span class="line"><span class="string">    @param destination: a point</span></span><br><span class="line"><span class="string">    @return: the shortest path</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span><span class="params">(self, grid, source, destination)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(grid) == <span class="number">0</span> <span class="keyword">or</span> (len(grid[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dx = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>]</span><br><span class="line">        dy = [<span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">        q = collections.deque([source])</span><br><span class="line">        grid[source.x][source.y] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            qlen = len(q)</span><br><span class="line">            next_q = collections.deque()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(qlen):</span><br><span class="line">                pt = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> pt.x == destination.x <span class="keyword">and</span> pt.y == destination.y:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                <span class="keyword">for</span> move <span class="keyword">in</span> range(len(dx)):</span><br><span class="line">                    nextPt = Point(pt.x + dx[move], pt.y + dy[move])</span><br><span class="line">                    <span class="keyword">if</span> (self.isInbound(grid, nextPt) <span class="keyword">and</span> grid[nextPt.x][nextPt.y] == <span class="number">0</span>):</span><br><span class="line">                        next_q.append(nextPt)</span><br><span class="line">                        grid[nextPt.x][nextPt.y] = <span class="number">1</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            q = next_q</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInbound</span><span class="params">(self, grid, pt)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> pt.x &gt;= <span class="number">0</span> <span class="keyword">and</span> pt.x &lt; len(grid) <span class="keyword">and</span> pt.y &gt;= <span class="number">0</span> <span class="keyword">and</span> pt.y &lt; len(grid[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>总结：注意 isInbound 要查的是 &gt;=0 和 &lt; len()， 其他的问题可以通过跑一个测试数据发现</p>
<h3 id="785-Is-Graph-Bipartite-Medium"><a href="#785-Is-Graph-Bipartite-Medium" class="headerlink" title="785. Is Graph Bipartite? (Medium)"></a><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">785. Is Graph Bipartite? (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Given an undirected graph, return true if and only if it is bipartite.</span><br><span class="line"></span><br><span class="line">Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</span><br><span class="line"></span><br><span class="line">The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">graph will have length in range [1, 100].</span><br><span class="line">graph[i] will contain integers in range [0, graph.length - 1].</span><br><span class="line">graph[i] will not contain i or duplicate values.</span><br><span class="line">The graph is undirected: if any element j is in graph[i], then i will be in graph[j].</span><br></pre></td></tr></table></figure>
<p>思路：用染色的方法，可以用 DFS, BFS 给所有 node 染上两种色中的一种。1.未上色，既上色，给相邻节点上相反色 2.已上色，查是否和目前要上的色相同<br>DFS:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(n, color)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> n <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> color == seen[n]</span><br><span class="line">            seen[n] = color</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> graph[n]:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> dfs(v, -color):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen <span class="keyword">and</span> dfs(i, <span class="number">1</span>) == <span class="keyword">False</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>BFS:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        seen = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                s = [(i, <span class="number">1</span>)]</span><br><span class="line">                seen[i] = <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> s:</span><br><span class="line">                    n, color = s.pop()</span><br><span class="line">                    <span class="keyword">for</span> v <span class="keyword">in</span> graph[n]:</span><br><span class="line">                        <span class="keyword">if</span> v <span class="keyword">in</span> seen:</span><br><span class="line">                            <span class="keyword">if</span> color == seen[v]:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                        <span class="keyword">else</span>:</span><br><span class="line">                            seen[v] = -color</span><br><span class="line">                            s.append((v, -color))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>二刷：DFS: …return color == seen[n]…if not dfs(v, -color): return False…return True… BFS: …seen[i] = 1; while…</p>
<h3 id="LinC-178-Graph-Valid-Tree-Medium"><a href="#LinC-178-Graph-Valid-Tree-Medium" class="headerlink" title="LinC 178. Graph Valid Tree (Medium)"></a><a href="http://www.lintcode.com/problem/graph-valid-tree/" target="_blank" rel="noopener">LinC 178. Graph Valid Tree (Medium)</a></h3><p>Leetcode 261. Graph Valid Tree 加锁<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</span><br><span class="line"></span><br><span class="line">You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.</span><br><span class="line"></span><br><span class="line">Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.</span><br></pre></td></tr></table></figure></p>
<p>思路：树的两个条件是不能有环，不能有孤儿节点。怎么实现想不太出来。看了答案，用 defaultdict(list) 放节点之间的关系， 有没有环其实不用管，因为只要确保边的数量 == n - 1, 并且 <strong>BFS</strong> 走过一遍之后访问过了所有的点，就确定没有环了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param n: An integer</span></span><br><span class="line"><span class="string">    @param edges: a list of undirected edges</span></span><br><span class="line"><span class="string">    @return: true if it's a valid tree, or false</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTree</span><span class="params">(self, n, edges)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(edges) == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span>        </span><br><span class="line">        <span class="keyword">if</span> len(edges) != n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mapping = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            mapping[edge[<span class="number">0</span>]].append(edge[<span class="number">1</span>])</span><br><span class="line">            mapping[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">        visited = set()</span><br><span class="line">        q = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.pop()</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> mapping[node]:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    q.append(neighbor)</span><br><span class="line">                    visited.add(neighbor)</span><br><span class="line">        <span class="keyword">return</span> len(visited) == n</span><br></pre></td></tr></table></figure></p>
<p>总结：相当值得做的一道 BFS 题。注意 已经访问过的节点不要入 q，不然无向图的边会导致死循环</p>
<h3 id="130-Surrounded-Regions-Medium"><a href="#130-Surrounded-Regions-Medium" class="headerlink" title="130. Surrounded Regions (Medium)"></a><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. Surrounded Regions (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.</span><br><span class="line"></span><br><span class="line">A region is captured by flipping all 'O's into 'X's in that surrounded region.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X O O X</span><br><span class="line">X X O X</span><br><span class="line">X O X X</span><br><span class="line">After running your function, the board should be:</span><br><span class="line"></span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X X X X</span><br><span class="line">X O X X</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span><span class="params">(self, board: List[List[str]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify board in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        m, n = len(board), len(board[<span class="number">0</span>])</span><br><span class="line">        rule = <span class="keyword">lambda</span> ij: <span class="number">0</span> &lt;= ij[<span class="number">0</span>] &lt; m <span class="keyword">and</span> <span class="number">0</span> &lt;= ij[<span class="number">1</span>] &lt; n <span class="keyword">and</span> board[ij[<span class="number">0</span>]][ij[<span class="number">1</span>]] == <span class="string">'O'</span></span><br><span class="line">        q = list(filter(rule, [ij <span class="keyword">for</span> k <span class="keyword">in</span> range(max(m, n)) <span class="keyword">for</span> ij <span class="keyword">in</span> [(<span class="number">0</span>, k), (k, <span class="number">0</span>), (m - <span class="number">1</span>, k), (k, n - <span class="number">1</span>)]]))</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            (i, j) = q.pop()</span><br><span class="line">            board[i][j] = <span class="string">'S'</span></span><br><span class="line">            q += list(filter(rule, [(i, j - <span class="number">1</span>), (i, j + <span class="number">1</span>), (i - <span class="number">1</span>, j), (i + <span class="number">1</span>, j)]))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">'S'</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span></span><br></pre></td></tr></table></figure>
<p>高频：需要改为q.pop(0)才是BFS，否则是DFS，但是代码风格放在BFS比较合适</p>
<h3 id="675-Cut-Off-Trees-for-Golf-Event-Hard"><a href="#675-Cut-Off-Trees-for-Golf-Event-Hard" class="headerlink" title="675. Cut Off Trees for Golf Event (Hard)"></a><a href="https://leetcode.com/problems/cut-off-trees-for-golf-event/" target="_blank" rel="noopener">675. Cut Off Trees for Golf Event (Hard)</a></h3><p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:<br>0 represents the obstacle can’t be reached.<br>1 represents the ground can be walked through.<br>The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.</p>
<p>You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).<br>You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.<br>You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.</p>
<p>Example 1:<br>Input:<br>[<br> [1,2,3],<br> [0,0,4],<br> [7,6,5]<br>]<br>Output: 6</p>
<p>Example 2:<br>Input:<br>[<br> [1,2,3],<br> [0,0,0],<br> [7,6,5]<br>]<br>Output: -1</p>
<p>Example 3:<br>Input:<br>[<br> [2,3,4],<br> [0,0,5],<br> [8,7,6]<br>]<br>Output: 6<br>Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cutOffTree</span><span class="params">(self, forest)</span>:</span></span><br><span class="line">        m, n = len(forest), len(forest[<span class="number">0</span>])</span><br><span class="line">        trees = [[forest[r][c], r, c] <span class="keyword">for</span> r <span class="keyword">in</span> range(m) <span class="keyword">for</span> c <span class="keyword">in</span> range(n) <span class="keyword">if</span> forest[r][c] &gt; <span class="number">1</span>]</span><br><span class="line">        trees.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        nextR, nextC = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> h, r, c <span class="keyword">in</span> trees:</span><br><span class="line">            step = self.bfs(forest, nextR, nextC, r, c, m, n)</span><br><span class="line">            <span class="keyword">if</span> step == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                forest[r][c] = <span class="number">1</span></span><br><span class="line">                nextR, nextC = r, c</span><br><span class="line">                ans += step</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, forest, startR, startC, endR, endC, m, n)</span>:</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        q = [(startR, startC)]</span><br><span class="line">        dirs = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]</span><br><span class="line">        visited = set()</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)):</span><br><span class="line">                r, c = q.pop()</span><br><span class="line">                <span class="keyword">if</span> r == endR <span class="keyword">and</span> c == endC:</span><br><span class="line">                    <span class="keyword">return</span> step</span><br><span class="line">                visited.add((r, c))</span><br><span class="line">                <span class="keyword">for</span> dr, dc <span class="keyword">in</span> dirs:</span><br><span class="line">                    <span class="keyword">if</span> <span class="number">0</span> &lt;= r + dr &lt;= m - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= c + dc &lt;= n - <span class="number">1</span> <span class="keyword">and</span> forest[r + dr][c + dc] != <span class="number">0</span> <span class="keyword">and</span> (r + dr, c + dc) <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                        nq.append((r + dr, c + dc))</span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            q = nq</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。比较不偏门的算法，可惜会TLE</p>
<h2 id="Topological-sorting-拓扑排序"><a href="#Topological-sorting-拓扑排序" class="headerlink" title="Topological sorting 拓扑排序"></a>Topological sorting 拓扑排序</h2><h3 id="LinC-127-Topological-Sorting-Medium"><a href="#LinC-127-Topological-Sorting-Medium" class="headerlink" title="LinC 127. Topological Sorting (Medium)"></a><a href="https://www.lintcode.com/problem/topological-sorting/description" target="_blank" rel="noopener">LinC 127. Topological Sorting (Medium)</a></h3><p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p>
<p>For each directed edge A -&gt; B in graph, A must before B in the order list.<br>The first node in the order can be any node in the graph with no nodes direct to it.<br>Find any topological order for the given graph.<br>You can assume that there is at least one topological order in the graph.<br>Clarification<br><a href="http://www.lintcode.com/help/graph" target="_blank" rel="noopener">Learn more about representation of graphs</a></p>
<p>Example:<br>For graph as follow:<br><img src="/images/lintcode_127_topo_1.jpeg" alt="graph example"><br>The topological order can be:<br>[0, 1, 2, 3, 4, 5]<br>[0, 2, 3, 1, 5, 4]<br>思路：拓扑排序，算法貌似是：1.统计每个点的入度；2.将入度为 0 的点入 queue；3.从队列中 pop 点，去掉所有指向别的点的边: 相应点入度 -1；4.新入度为 0 的点入 queue<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition for a Directed graph node</span></span><br><span class="line"><span class="string">class DirectedGraphNode:</span></span><br><span class="line"><span class="string">    def __init__(self, x):</span></span><br><span class="line"><span class="string">        self.label = x</span></span><br><span class="line"><span class="string">        self.neighbors = []</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: graph: A list of Directed graph node</span></span><br><span class="line"><span class="string">    @return: Any topological order for the given graph.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topSort</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(graph) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        inBound = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> inBound:</span><br><span class="line">                inBound[node] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> inBound:</span><br><span class="line">                    inBound[neighbor] = <span class="number">0</span></span><br><span class="line">                inBound[neighbor] += <span class="number">1</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> inBound:</span><br><span class="line">            <span class="keyword">if</span> inBound[node] == <span class="number">0</span>:</span><br><span class="line">                q.append(node)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            zNode = q.popleft()</span><br><span class="line">            ans.append(zNode)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> zNode.neighbors:</span><br><span class="line">                inBound[node] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inBound[node] == <span class="number">0</span>:</span><br><span class="line">                    q.append(node)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：顺利。但是题目没有说清楚 return 的是一个拓扑排序好的 node 的 list</p>
<h3 id="207-Course-Schedule-Medium"><a href="#207-Course-Schedule-Medium" class="headerlink" title="207. Course Schedule (Medium)"></a><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">207. Course Schedule (Medium)</a></h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.<br>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]<br>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: true<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0. So it is possible.</p>
<p>Example 2:<br>Input: 2, [[1,0],[0,1]]<br>Output: false<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0, and to take course 0 you should<br>             also have finished course 1. So it is impossible.</p>
<p>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; bool:</span></span><br><span class="line">        inDegree = [<span class="number">0</span>] * numCourses</span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[e[<span class="number">1</span>]].append(e[<span class="number">0</span>])</span><br><span class="line">            inDegree[e[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        q = []</span><br><span class="line">        <span class="keyword">for</span> i, d <span class="keyword">in</span> enumerate(inDegree):</span><br><span class="line">            <span class="keyword">if</span> d == <span class="number">0</span>:</span><br><span class="line">                q.append(i)</span><br><span class="line">        <span class="keyword">while</span> q:            </span><br><span class="line">            v1 = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> v2 <span class="keyword">in</span> graph[v1]:</span><br><span class="line">                inDegree[v2] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inDegree[v2] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v2)</span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> inDegree:</span><br><span class="line">            <span class="keyword">if</span> d != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：较值得二刷的题，发现了for i, v in enumerate(list)和for k, v in dict.items()这两种用法混淆的薄弱环节。 还有对入度和建的graph概念没有完全理解<br>面经：Cruise。…collecitons.default <strong>dict</strong>()…统计入度需要…inDegree[<strong>e[0]</strong>] += 1…被指向的vertex入度加一</p>
<h3 id="210-Course-Schedule-II-Medium"><a href="#210-Course-Schedule-II-Medium" class="headerlink" title="210. Course Schedule II (Medium)"></a><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">210. Course Schedule II (Medium)</a></h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.<br>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]<br>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.<br>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: [0,1]<br>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished<br>             course 0. So the correct course order is [0,1] .</p>
<p>Example 2:<br>Input: 4, [[1,0],[2,0],[3,1],[3,2]]<br>Output: [0,1,2,3] or [0,2,1,3]<br>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both<br>             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.<br>             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .<br>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses: int, prerequisites: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        graph = collections.defaultdict(list)</span><br><span class="line">        indegree = [<span class="number">0</span>] * numCourses</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> prerequisites:</span><br><span class="line">            graph[e[<span class="number">1</span>]].append(e[<span class="number">0</span>])</span><br><span class="line">            indegree[e[<span class="number">0</span>]] += <span class="number">1</span></span><br><span class="line">        q = []</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(indegree):</span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span>:</span><br><span class="line">                q.append(i)</span><br><span class="line">                ans.append(i)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            v1 = q.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">for</span> v2 <span class="keyword">in</span> graph[v1]:</span><br><span class="line">                indegree[v2] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> indegree[v2] == <span class="number">0</span>:</span><br><span class="line">                    q.append(v2)</span><br><span class="line">                    ans.append(v2)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> len(ans) == numCourses <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure>
<p>面经：Cruise。</p>
<h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS 深度优先搜索"></a>DFS 深度优先搜索</h1><h2 id="Binary-Tree-DFS-二叉树与树上的深度优先搜索"><a href="#Binary-Tree-DFS-二叉树与树上的深度优先搜索" class="headerlink" title="Binary Tree DFS 二叉树与树上的深度优先搜索"></a>Binary Tree DFS 二叉树与树上的深度优先搜索</h2><h3 id="257-Binary-Tree-Paths-Easy"><a href="#257-Binary-Tree-Paths-Easy" class="headerlink" title="257. Binary Tree Paths (Easy)"></a><a href="https://leetcode.com/problems/binary-tree-paths/description/" target="_blank" rel="noopener">257. Binary Tree Paths (Easy)</a></h3><p>Given a binary tree, return all root-to-leaf paths.<br>Note: A leaf is a node with no children.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line">Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]</span><br></pre></td></tr></table></figure></p>
<p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root: TreeNode)</span> -&gt; List[str]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(root, <span class="string">""</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, path, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">                ans.append(<span class="string">f"<span class="subst">&#123;root.val&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(<span class="string">f"<span class="subst">&#123;path&#125;</span>-&gt;<span class="subst">&#123;root.val&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> path:</span><br><span class="line">            path = <span class="string">f"<span class="subst">&#123;root.val&#125;</span>"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            path = <span class="string">f"<span class="subst">&#123;path&#125;</span>-&gt;<span class="subst">&#123;root.val&#125;</span>"</span></span><br><span class="line">        self.dfs(root.left, path, ans)</span><br><span class="line">        self.dfs(root.right, path, ans)</span><br></pre></td></tr></table></figure>
<p>三刷：删除1，2刷的代码。使用更接近DFS模板，适合面试的代码</p>
<h3 id="144-Binary-Tree-Preorder-Traversal-Medium"><a href="#144-Binary-Tree-Preorder-Traversal-Medium" class="headerlink" title="144. Binary Tree Preorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return the preorder traversal of its nodes' values.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br><span class="line">Follow up: Recursive solution is trivial, could you do it iteratively?</span><br></pre></td></tr></table></figure>
<p>思路：递归写熟了确实是简单。<br>二刷：看了下 traverse 背后的逻辑，“拿着一个记事本, 顺着二叉树走, 走过一个, 在本子上面记下来”<br><img src="/images/leetode_144_bina_1.jpeg" alt="preorder-traverse-logic-image"></p>
<p>递归 Traverse:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        self.helper(root, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        self.helper(root.left, ans)</span><br><span class="line">        self.helper(root.right, ans)</span><br></pre></td></tr></table></figure></p>
<p>非递归:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span>   </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>             </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            n = stack.pop()</span><br><span class="line">            ans.append(n.val)</span><br><span class="line">            <span class="keyword">if</span> n.right:</span><br><span class="line">                stack.append(n.right)</span><br><span class="line">            <span class="keyword">if</span> n.left:</span><br><span class="line">                stack.append(n.left)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>Divide and Conquer 分治:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span>   </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>    </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        left = self.preorderTraversal(root.left)</span><br><span class="line">        right = self.preorderTraversal(root.right)</span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        ans.extend(left)</span><br><span class="line">        ans.extend(right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：非递归要记住 pop，push right， push left 这个算法。就可以写对.<br>二刷：因为栈是先进后出，所以先 push right。分治的代码里要用 extend 来把 list 填充到另一个 list 里。<br>三刷：代码已经没有什么优化空间了。无他手熟尔</p>
<h3 id="94-Binary-Tree-Inorder-Traversal-Medium"><a href="#94-Binary-Tree-Inorder-Traversal-Medium" class="headerlink" title="94. Binary Tree Inorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return the inorder traversal of its nodes' values.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br><span class="line">Follow up: Recursive solution is trivial, could you do it iteratively?</span><br></pre></td></tr></table></figure>
<p>思路：递归和用栈各写一遍<br>二刷：递归如果不想用 instance variable，就将 ans 传到 helper 里去。<br>递归:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(root, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(root.left, ans)</span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        self.dfs(root.right, ans)</span><br></pre></td></tr></table></figure></p>
<p>二刷：不用 class 变量就把 ans 传入 helper / dfs 函数, 把一刷的递归去掉了，看题的时候方便点。<br>三刷：递归方法注意主函数调用一次dfs函数，dfs递归调用自己，dfs函数中注意判断…if not root: return…<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = stack.pop(<span class="number">-1</span>)</span><br><span class="line">                ans.append(root.val)</span><br><span class="line">                root = root.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>高频：递归自己就加 def <strong>init</strong>(): self.ans = []…if not root: return []…, 否则用 dfs(self, root, ans):…<br>四刷：简化删除代码，改pushAlltoLeft()为…while root or stack:…非递归/stack，需要记住代码套路</p>
<h3 id="LinC-11-Search-Range-in-Binary-Search-Tree-Medium"><a href="#LinC-11-Search-Range-in-Binary-Search-Tree-Medium" class="headerlink" title="LinC 11.Search Range in Binary Search Tree (Medium)"></a><a href="http://www.lintcode.com/problem/search-range-in-binary-search-tree/" target="_blank" rel="noopener">LinC 11.Search Range in Binary Search Tree (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a binary search tree and a range [k1, k2], return all elements in the given range.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">If k1 = 10 and k2 = 22, then your function should return [12, 20, 22].</span><br><span class="line"></span><br><span class="line">    20</span><br><span class="line">   /  \</span><br><span class="line">  8   22</span><br><span class="line"> / \</span><br><span class="line">4   12</span><br></pre></td></tr></table></figure>
<p>思路：inorder traversal 的话出来的是从小到大，把符合 k1, k2 条件的返回就行了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, root, k1, k2)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(root, k1, k2, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, k1, k2, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(root.left, k1, k2, ans)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= k2 <span class="keyword">and</span> root.val &gt;= k1:</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">        self.dfs(root.right, k1, k2, ans)</span><br></pre></td></tr></table></figure></p>
<p>二刷，非递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, root, k1, k2)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        ans = []</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n = stack.pop(<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span> k1 &lt;= n.val &lt;= k2:</span><br><span class="line">                    ans.append(n.val)</span><br><span class="line">                root = n.right</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：inorder非递归模板大法：…while root or stack:…</p>
<h3 id="LinC-448-Inorder-Successor-in-BST-Medium"><a href="#LinC-448-Inorder-Successor-in-BST-Medium" class="headerlink" title="LinC 448. Inorder Successor in BST (Medium)"></a><a href="http://www.lintcode.com/problem/inorder-successor-in-binary-search-tree/" target="_blank" rel="noopener">LinC 448. Inorder Successor in BST (Medium)</a></h3><p>Leetcode 285. Inorder Successor in BST 带锁<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</span><br><span class="line"></span><br><span class="line">If the given node has no in-order successor in the tree, return null.</span><br><span class="line"></span><br><span class="line">It's guaranteed p is one node in the given tree. (You can directly compare the memory address to find p)</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given tree = [2,1] and node = 1:</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">1</span><br><span class="line">return node 2.</span><br><span class="line"></span><br><span class="line">Given tree = [2,1,3] and node = 2:</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br><span class="line">return node 3.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(h), where h is the height of the BST.</span><br></pre></td></tr></table></figure></p>
<p>思路：DFS 找这个 node， 返回这个 node inorder 的下一个 node<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: root: The root of the BST.</span></span><br><span class="line"><span class="string">    @param: p: You need find the successor node of p.</span></span><br><span class="line"><span class="string">    @return: Successor of p.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span><span class="params">(self, root, p)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        stack = []</span><br><span class="line">        found = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n = stack.pop(<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span> found:</span><br><span class="line">                    <span class="keyword">return</span> n</span><br><span class="line">                <span class="keyword">if</span> p == n:</span><br><span class="line">                    found = <span class="keyword">True</span></span><br><span class="line">                root = n.right</span><br></pre></td></tr></table></figure></p>
<p>递归:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span><span class="params">(self, root, p)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        self.pre = <span class="keyword">None</span></span><br><span class="line">        self.suc = <span class="keyword">None</span></span><br><span class="line">        self.inOrder(root, p)</span><br><span class="line">        <span class="keyword">return</span> self.suc</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, root, p)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inOrder(root.left, p)</span><br><span class="line">        <span class="keyword">if</span> self.pre == p:</span><br><span class="line">            self.suc = root</span><br><span class="line">        self.pre = root</span><br><span class="line">        self.inOrder(root.right, p)</span><br></pre></td></tr></table></figure></p>
<p>总结：递归怎么都写不对， 先抄一个非递归能理解的<br>二刷：递归， 需要self.pre和self.suc两个变量来返回self.suc。简化非递归，用了inorder模板…while root or stack:…</p>
<h3 id="98-Validate-Binary-Search-Tree-Medium"><a href="#98-Validate-Binary-Search-Tree-Medium" class="headerlink" title="98. Validate Binary Search Tree (Medium)"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/description/" target="_blank" rel="noopener">98. Validate Binary Search Tree (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, determine if it is a valid binary search tree (BST).</span><br><span class="line"></span><br><span class="line">Assume a BST is defined as follows:</span><br><span class="line"></span><br><span class="line">The left subtree of a node contains only nodes with keys less than the node's key.</span><br><span class="line">The right subtree of a node contains only nodes with keys greater than the node's key.</span><br><span class="line">Both the left and right subtrees must also be binary search trees.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value</span><br><span class="line">             is 5 but its right child's value is 4.</span><br></pre></td></tr></table></figure>
<p>二刷，利用BST本身左&lt;根&lt;右的性质：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root, -sys.maxsize, sys.maxsize)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, minVal, maxVal)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= minVal <span class="keyword">or</span> root.val &gt;= maxVal:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(root.left, minVal, min(root.val, maxVal)) <span class="keyword">and</span> self.dfs(root.right, max(minVal, root.val), maxVal)</span><br></pre></td></tr></table></figure></p>
<p>inorder 中序遍历额外数组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        res = []</span><br><span class="line">        self.inOrder(root, res)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(res)):</span><br><span class="line">            <span class="keyword">if</span> res[i] &lt;= res[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, root, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inOrder(root.left, res)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        self.inOrder(root.right, res)</span><br></pre></td></tr></table></figure></p>
<p>inorder 中序遍历不适用额外数组：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.pre = -sys.maxsize</span><br><span class="line">        self.valid = <span class="keyword">True</span></span><br><span class="line">        self.inOrder(root)</span><br><span class="line">        <span class="keyword">return</span> self.valid</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">or</span> <span class="keyword">not</span> self.valid:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inOrder(n.left)</span><br><span class="line">        <span class="keyword">if</span> n.val &lt;= self.pre:</span><br><span class="line">            self.valid = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.pre = n.val</span><br><span class="line">        self.inOrder(n.right)</span><br></pre></td></tr></table></figure></p>
<p>inorder 中序遍历非递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        pre = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> stack:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n = stack.pop(<span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">if</span> pre <span class="keyword">and</span> n.val &lt;= pre.val:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                pre = n</span><br><span class="line">                root = n.right</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意：1.分治最后一句 minVal 和 maxVal 的传法是 return f(root.left, minVal, min(root.val, maxVal)) and f(root.right, max(root.val, minVal), maxVal)<br>总结：背sys.maxsize，递归终止条件 if not root: return True; if root.val &lt;= minVal…: return False…<br>高频：背maxsize, if root.val &lt;<strong>=</strong> minV or root.val &gt;<strong>=</strong> maxV; def dfs(…)或def inOrder(…)<br>三刷：…if root.val &lt;<strong>=</strong> minV or root.val &gt;= maxV:…<br>四刷：总结四种解法：利用BST本身左&lt;根&lt;右的性质的递归，中序遍历额外数组递归，中序遍历无额外数组递归，中序遍历非递归(有/无额外数组). 中序遍历非递归无额外数组:…if pre and n.val &lt;= pre.val: return False; pre = n…</p>
<h3 id="230-Kth-Smallest-Element-in-a-BST-Medium"><a href="#230-Kth-Smallest-Element-in-a-BST-Medium" class="headerlink" title="230. Kth Smallest Element in a BST (Medium)"></a><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener">230. Kth Smallest Element in a BST (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">You may assume k is always valid, 1 ≤ k ≤ BST's total elements.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br><span class="line">Follow up:</span><br><span class="line">What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</span><br></pre></td></tr></table></figure>
<p>思路：第一感觉是一直往下，找到最小，然后利用 BST 左边比 root 小，root 不大于右边的特性找到 K。 具体怎么实现得看答案。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次写能 ac 的土递归办法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.helper(root, k)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.helper(root.left, k)</span><br><span class="line">        self.cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.cnt == k:</span><br><span class="line">            self.ans = root.val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.helper(root.right, k)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归 / 栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == k:</span><br><span class="line">                <span class="keyword">return</span> node.val</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">                <span class="keyword">while</span> node:</span><br><span class="line">                    stack.append(node)</span><br><span class="line">                    node = node.left</span><br></pre></td></tr></table></figure></p>
<p>总结：答案基本就是中序遍历，统计当前遍历的步数，到 k 返回。递归算法还是需要全局变量:(。非递归 / 栈算法用上题的套路加一个 counter 就很容易写对。 Follow up: 二叉树经常被修改 如何优化 kthSmallest 这个操作? 在 TreeNode 中增加一个 counter，代表整个树的节点个数，也可以用一个 HashMap&lt;TreeNode, Integer&gt; 来存储某个节点为代表的子树的节点个数。在增删查改的过程中记录不断更新受影响节点的 counter， 在 kthSmallest 的实现中用类似 Quick Select 的算法去找到 kth smallest element 时间复杂度为 O(h)，h 为树的高度。</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; int:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mid = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> k != <span class="number">1</span>:</span><br><span class="line">                    k -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> mid.val</span><br><span class="line">                <span class="keyword">if</span> mid.right:</span><br><span class="line">                    root = mid.right</span><br></pre></td></tr></table></figure></p>
<p>总结：递归已无太多优化空间，非递归有简化版本，需背, while root or len(stack) &gt; 0: if root… else: mid = …pop(); … if <strong>mid</strong>.right: root = mid.right</p>
<h3 id="173-Binary-Search-Tree-Iterator-Medium"><a href="#173-Binary-Search-Tree-Iterator-Medium" class="headerlink" title="173. Binary Search Tree Iterator (Medium)"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator/description/" target="_blank" rel="noopener">173. Binary Search Tree Iterator (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</span><br><span class="line"></span><br><span class="line">Calling next() will return the next smallest number in the BST.</span><br><span class="line"></span><br><span class="line">Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</span><br></pre></td></tr></table></figure>
<p>思路：看了代码 “Your BSTIterator will be called like this” 后感觉这个 iterator 需要存一个中序遍历的队列, next() 就 popleft，hasNext() 就返回该队列是否为空。use O(h) 内存暂时不知道怎么实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a  binary tree node</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span><span class="params">(object)</span>:</span></span><br><span class="line">    q = collections.deque()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            self.q.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">                <span class="keyword">while</span> node:</span><br><span class="line">                    stack.append(node)</span><br><span class="line">                    node = node.left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.q) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.q.popleft()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"># i, v = BSTIterator(root), []</span></span><br><span class="line"><span class="comment"># while i.hasNext(): v.append(i.next())</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意全局变量（和 class method）前面加 self.，别的没什么，想好了比较好写的题</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span>:</span></span><br><span class="line">    q = collections.deque()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root: TreeNode)</span>:</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root <span class="keyword">or</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> root:</span><br><span class="line">                stack.append(root)</span><br><span class="line">                root = root.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                mid = stack.pop()</span><br><span class="line">                self.q.append(mid.val)</span><br><span class="line">                <span class="keyword">if</span> mid.right:</span><br><span class="line">                    root = mid.right</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @return the next smallest number</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.hasNext():</span><br><span class="line">            <span class="keyword">return</span> self.q.popleft()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        @return whether we have a next smallest number</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.q) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>总结：上一题的非递归要背 while root or len(stack) &gt; 0: if <strong>root</strong>: stack.append…; root = root.left…</p>
<h3 id="LinC-900-Closest-Binary-Search-Tree-Value-Easy"><a href="#LinC-900-Closest-Binary-Search-Tree-Value-Easy" class="headerlink" title="LinC 900. Closest Binary Search Tree Value (Easy)"></a><a href="https://www.lintcode.com/problem/closest-binary-search-tree-value/description" target="_blank" rel="noopener">LinC 900. Closest Binary Search Tree Value (Easy)</a></h3><p>Leetcode 270. Closest Binary Search Tree Value 带锁<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</span><br><span class="line"></span><br><span class="line">Given target value is a floating point.</span><br><span class="line">You are guaranteed to have only one unique value in the BST that is closest to the target.</span><br><span class="line">Example</span><br><span class="line">Given root = &#123;1&#125;, target = 4.428571, return 1.</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param root: the given BST</span></span><br><span class="line"><span class="string">    @param target: the given target</span></span><br><span class="line"><span class="string">    @return: the value in the BST that is closest to the target</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 最直观</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestValue</span><span class="params">(self, root, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        ans = root.val</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> abs(root.val - target) &lt; abs(ans - target):</span><br><span class="line">                ans = root.val</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; target:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestValue</span><span class="params">(self, root, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        tempA = root.val</span><br><span class="line">        <span class="keyword">if</span> tempA &lt; target:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> tempA</span><br><span class="line">        tempB = self.closestValue(root, target)</span><br><span class="line">        <span class="keyword">return</span> tempA <span class="keyword">if</span> abs(tempA - target) &lt; abs(tempB - target) <span class="keyword">else</span> tempB</span><br></pre></td></tr></table></figure>
<p>总结：最直观的是根据 BST 性质二分查找；除此之外还有递归（回溯）和迭代 / stack / 中序遍历（维护一个最小值）两种写法。直观写法需要注意：1.ans 赋值的条件；2.root 往哪边走的条件。 递归（回溯）写法要注意：1.返回的条件放的位置（在决定往哪边走之后）；递归完之后还要判断最后返回哪个值</p>
<h3 id="113-Path-Sum-II-Medium"><a href="#113-Path-Sum-II-Medium" class="headerlink" title="113. Path Sum II (Medium)"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given the below binary tree and sum = 22,</span><br><span class="line"></span><br><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \    / \</span><br><span class="line">7    2  5   1</span><br><span class="line">Return:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">   [5,4,11,2],</span><br><span class="line">   [5,8,4,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(root, sum, [], ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, target, path, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> target == root.val <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            ans.append(path[:] + [root.val])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        path.append(root.val)</span><br><span class="line">        self.dfs(root.left, target - root.val, path, ans)</span><br><span class="line">        self.dfs(root.right, target - root.val, path, ans)</span><br><span class="line">        <span class="keyword">del</span> path[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：…if…s == root.val:…dfs(…path + [root.val],…)<br>面经：Quora, 大疆。<br>todo 再刷可以用非递归while stack: (n, s, path) = q.pop()</p>
<h3 id="129-Sum-Root-to-Leaf-Numbers-Medium"><a href="#129-Sum-Root-to-Leaf-Numbers-Medium" class="headerlink" title="129. Sum Root to Leaf Numbers (Medium)"></a><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</span><br><span class="line"></span><br><span class="line">An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.</span><br><span class="line"></span><br><span class="line">Find the total sum of all root-to-leaf numbers.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">Output: 25</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 1-&gt;2 represents the number 12.</span><br><span class="line">The root-to-leaf path 1-&gt;3 represents the number 13.</span><br><span class="line">Therefore, sum = 12 + 13 = 25.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [4,9,0,5,1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">Output: 1026</span><br><span class="line">Explanation:</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.</span><br><span class="line">The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.</span><br><span class="line">The root-to-leaf path 4-&gt;0 represents the number 40.</span><br><span class="line">Therefore, sum = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        s = [(root, <span class="number">0</span>)]</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            n, v = s.pop(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">if</span> n:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> n.left <span class="keyword">and</span> <span class="keyword">not</span> n.right:</span><br><span class="line">                    ans += v * <span class="number">10</span> + n.val</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    s.append((n.left, v * <span class="number">10</span> + n.val))</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    s.append((n.right, v * <span class="number">10</span> + n.val))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：非递归stack + dfs<br>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumNumbers</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root, <span class="number">0</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, val)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> val * <span class="number">10</span> + root.val</span><br><span class="line">        <span class="keyword">return</span> self.helper(root.left, val * <span class="number">10</span> + root.val) + self.helper(root.right, val * <span class="number">10</span> + root.val)</span><br></pre></td></tr></table></figure></p>
<p>总结：递归…if not root: return 0…return helper(…val * 10 + root.val) + helper(…)</p>
<h3 id="437-Path-Sum-III-Medium"><a href="#437-Path-Sum-III-Medium" class="headerlink" title="437. Path Sum III (Medium)"></a><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III (Medium)</a></h3><p>You are given a binary tree in which each node contains an integer value.<br>Find the number of paths that sum to a given value.<br>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).<br>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<p>Example:<br>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</p>
<pre><code>  10
 /  \
5   -3
</code></pre><p>   / \    \<br>  3   2   11<br> / \   \<br>3  -2   1</p>
<p>Return 3. The paths that sum to 8 are:</p>
<ol>
<li>5 -&gt; 3</li>
<li>5 -&gt; 2 -&gt; 1</li>
<li>-3 -&gt; 11</li>
</ol>
<p>Brute force：遍历一遍，每个节点开始走DFS<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.preorder(root, sum)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(root, target)</span><br><span class="line">        self.preorder(root.left, target)</span><br><span class="line">        self.preorder(root.right, target)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, target)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> target == root.val:</span><br><span class="line">            self.ans += <span class="number">1</span></span><br><span class="line">        self.dfs(root.left, target - root.val)</span><br><span class="line">        self.dfs(root.right, target - root.val)</span><br></pre></td></tr></table></figure></p>
<p>DFS + Memo：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; int:</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.dfs(root, sum, <span class="number">0</span>, &#123;<span class="number">0</span>: <span class="number">1</span>&#125;)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, target, curPathSum, memo)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        curPathSum += root.val</span><br><span class="line">        oldPathSum = curPathSum - target</span><br><span class="line">        self.ans += memo.get(oldPathSum, <span class="number">0</span>)</span><br><span class="line">        memo[curPathSum] = memo.get(curPathSum, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">        self.dfs(root.left, target, curPathSum, memo)</span><br><span class="line">        self.dfs(root.right, target, curPathSum, memo)</span><br><span class="line">        memo[curPathSum] -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>面经：Quora。…oldPathSum = <strong>curPathSum - target</strong>…</p>
<h2 id="Binary-Tree-Divide-Conquer-二叉树与分治"><a href="#Binary-Tree-Divide-Conquer-二叉树与分治" class="headerlink" title="Binary Tree Divide Conquer 二叉树与分治"></a>Binary Tree Divide Conquer 二叉树与分治</h2><h3 id="226-Invert-Binary-Tree-Easy"><a href="#226-Invert-Binary-Tree-Easy" class="headerlink" title="226. Invert Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">226. Invert Binary Tree (Easy)</a></h3><p>Invert a binary tree.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input:</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">Output:</span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure></p>
<p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:<br>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
<p>递归1：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>递归2：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        l = self.invertTree(root.left)</span><br><span class="line">        r = self.invertTree(root.right)</span><br><span class="line">        root.left, root.right = r, l</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>递归3：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            root.left, root.right = self.invertTree(root.right), self.invertTree(root.left)</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>非递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> q:</span><br><span class="line">                n.left, n.right = n.right, n.left</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nq.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nq.append(n.right)</span><br><span class="line">            q = nq</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>高频：删掉了思路和1，2，3刷的总结，def dfs(…的非模板代码，没有什么价值。增加了递归代码<br>五刷：增加递归写法。非递归：先入nq再反转或先反转再入nq</p>
<h3 id="100-Same-Tree-Easy"><a href="#100-Same-Tree-Easy" class="headerlink" title="100. Same Tree (Easy)"></a><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree (Easy)</a></h3><p>Given two binary trees, write a function to check if they are the same or not.<br>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   3     2   3</span><br><span class="line"></span><br><span class="line">        [1,2,3],   [1,2,3]</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:     1         1</span><br><span class="line">          /           \</span><br><span class="line">         2             2</span><br><span class="line"></span><br><span class="line">        [1,2],     [1,null,2]</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input:     1         1</span><br><span class="line">          / \       / \</span><br><span class="line">         2   1     1   2</span><br><span class="line"></span><br><span class="line">        [1,2,1],   [1,1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></p>
<p>递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p <span class="keyword">and</span> <span class="keyword">not</span> q:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> (p <span class="keyword">and</span> <span class="keyword">not</span> q) <span class="keyword">or</span> (q <span class="keyword">and</span> <span class="keyword">not</span> p) <span class="keyword">or</span> p.val != q.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.isSameTree(p.left, q.left) <span class="keyword">and</span> self.isSameTree(p.right, q.right)</span><br></pre></td></tr></table></figure></p>
<p>非递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSameTree</span><span class="params">(self, p: TreeNode, q: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        s1, s2 = [p], [q]</span><br><span class="line">        <span class="keyword">while</span> s1 <span class="keyword">and</span> s2:</span><br><span class="line">            n1, n2 = s1.pop(), s2.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">and</span> <span class="keyword">not</span> n2:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (n1 <span class="keyword">and</span> <span class="keyword">not</span> n2) <span class="keyword">or</span> (n2 <span class="keyword">and</span> <span class="keyword">not</span> n1) <span class="keyword">or</span> n1.val != n2.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            s1.append(n1.left)</span><br><span class="line">            s1.append(n1.right)</span><br><span class="line">            s2.append(n2.left)</span><br><span class="line">            s2.append(n2.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> s1 <span class="keyword">and</span> <span class="keyword">not</span> s2</span><br></pre></td></tr></table></figure></p>
<p>高频：非递归如果pop(0)为先续遍历preorder traversal<br>二刷：递归…elif (p and not q) or (…</p>
<h3 id="101-Symmetric-Tree-Easy"><a href="#101-Symmetric-Tree-Easy" class="headerlink" title="101. Symmetric Tree (Easy)"></a><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. Symmetric Tree (Easy)</a></h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">For example, this binary tree [1,2,2,3,4,4,3] is symmetric:</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line"> / \ / \</span><br><span class="line">3  4 4  3</span><br><span class="line">But the following [1,2,2,null,3,null,3] is not:</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   2</span><br><span class="line">   \   \</span><br><span class="line">   3    3</span><br></pre></td></tr></table></figure></p>
<p>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<p>递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> (l <span class="keyword">and</span> <span class="keyword">not</span> r) <span class="keyword">or</span> (r <span class="keyword">and</span> <span class="keyword">not</span> l):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> l.val == r.val <span class="keyword">and</span> helper(l.left, r.right) <span class="keyword">and</span> helper(l.right, r.left)</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, root.right)</span><br></pre></td></tr></table></figure></p>
<p>非递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span><span class="params">(self, root: TreeNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        s = [root.left, root.right]</span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            l, r = s.pop(), s.pop()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> l <span class="keyword">and</span> <span class="keyword">not</span> r:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> (l <span class="keyword">and</span> <span class="keyword">not</span> r) <span class="keyword">or</span> (r <span class="keyword">and</span> <span class="keyword">not</span> l) <span class="keyword">or</span> l.val != r.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            s.append(l.left)</span><br><span class="line">            s.append(r.right)</span><br><span class="line">            s.append(l.right)</span><br><span class="line">            s.append(r.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>高频：递归：…helper(<strong>l.left, r.right</strong>) and helper(l.right, r.left)。非递归：…if not l and not r: <strong>continue</strong>…<br>二刷：递归：…helper(<strong>l.left, r.right</strong>) and…</p>
<h3 id="104-Maximum-Depth-of-Binary-Tree-Easy"><a href="#104-Maximum-Depth-of-Binary-Tree-Easy" class="headerlink" title="104. Maximum Depth of Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree (Easy)</a></h3><p>Given a binary tree, find its maximum depth.<br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br>Note: A leaf is a node with no children.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">return its depth = 3.</span><br></pre></td></tr></table></figure></p>
<p>三刷，递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> max(self.maxDepth(root.left), self.maxDepth(root.right)) + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>非递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nq.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nq.append(n.right)</span><br><span class="line">            q = nq</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：不常练就容易简单递归也写不出<br>高频：删掉1，2刷的代码和总结，基本都是递归二分法的套路。非递归：注意[None]和[]不等<br>四刷：高频的q不错</p>
<h3 id="110-Balanced-Binary-Tree-Easy"><a href="#110-Balanced-Binary-Tree-Easy" class="headerlink" title="110. Balanced Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">110. Balanced Binary Tree (Easy)</a></h3><p>Given a binary tree, determine if it is height-balanced.<br>For this problem, a height-balanced binary tree is defined as:<br>a binary tree in which the depth of the two subtrees of every node never differ by more than 1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Given the following tree [3,9,20,null,null,15,7]:</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">Return true.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Given the following tree [1,2,2,3,3,null,null,4,4]:</span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure></p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        self.balanced = <span class="keyword">True</span></span><br><span class="line">        self.maxDepth(root)</span><br><span class="line">        <span class="keyword">return</span> self.balanced</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = self.maxDepth(root.left)</span><br><span class="line">        r = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">if</span> abs(l - r) &gt; <span class="number">1</span>:</span><br><span class="line">            self.balanced = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> max(l, r) + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：简化代码，self.balanced必须是全局变量，否则会出错<br>高频：self.balanced = True; def max_depth(root):…return <strong>max(l, r) + 1</strong>…<br>三刷：递归有用到104题二叉树的最大深度<br>四刷：有个<a href="https://www.youtube.com/watch?v=LU4fGD-fgJQ" target="_blank" rel="noopener">youtube视频解释的特别清楚</a></p>
<h3 id="111-Minimum-Depth-of-Binary-Tree-Easy"><a href="#111-Minimum-Depth-of-Binary-Tree-Easy" class="headerlink" title="111. Minimum Depth of Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, find its minimum depth.</span><br><span class="line"></span><br><span class="line">The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">return its minimum depth = 2.</span><br></pre></td></tr></table></figure>
<p>递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l = self.minDepth(root.left)</span><br><span class="line">        r = self.minDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> l + r + <span class="number">1</span> <span class="keyword">if</span> l == <span class="number">0</span> <span class="keyword">or</span> r == <span class="number">0</span> <span class="keyword">else</span> min(l, r) + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>非递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minDepth</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> n <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> n.left <span class="keyword">and</span> <span class="keyword">not</span> n.right:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nq.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nq.append(n.right)</span><br><span class="line">            q = nq</span><br></pre></td></tr></table></figure></p>
<p>高频：与上一题的不同是要考虑左子树和右子树长度为0的情况，因为长度定义为节点到叶子。…l = f(root.left); r = f(root.right); return l + r + 1 if l == 0 or…。非递归：if not n.left and not n.right: return res…<br>二刷：递归：…return l + r + 1 if not l or not r else min(…) + 1</p>
<h3 id="114-Flatten-Binary-Tree-to-Linked-List-Medium"><a href="#114-Flatten-Binary-Tree-to-Linked-List-Medium" class="headerlink" title="114. Flatten Binary Tree to Linked List (Medium)"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List (Medium)</a></h3><p>Given a binary tree, flatten it to a linked list in-place.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">For example, given the following tree:</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br><span class="line">The flattened tree should look like:</span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure></p>
<p>高频：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root: TreeNode)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.helper(root)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.helper(root.right)</span><br><span class="line">        self.helper(root.left)</span><br><span class="line">        root.right = self.prev</span><br><span class="line">        root.left = <span class="keyword">None</span></span><br><span class="line">        self.prev = root</span><br></pre></td></tr></table></figure></p>
<p>总结：简洁代码，套路要直观很多，先递归右，然后左子树，然后拼接root.right = self.prev; root.left = None; self.prev = root<br>三刷：既然要靠背，就背个代码量少的，讨论区叫reverse preorder。…递归right; 递归left; 接右；清左；设prev<br>四刷：reverse preorder…f(root.right)…f(root.left); root.right = …root.left = None; prev = root</p>
<h3 id="108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree (Easy)"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener">108. Convert Sorted Array to Binary Search Tree (Easy)</a></h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:<br>Given the sorted array: [-10,-3,0,5,9],<br>One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span><span class="params">(self, nums: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      mid = (len(nums) - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">      root = TreeNode(nums[mid])</span><br><span class="line">      root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">      root.right = self.sortedArrayToBST(nums[mid + <span class="number">1</span>:])</span><br><span class="line">      <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>高频：<strong>if not nums: return</strong>…mid =…root = …root.left = …root.right = …return root<br>面经：Amazon …mid = (len(nums) - 1) // 2…root.left =…return root<br>三刷：如此牛逼，改写了下一题的space:O(n)的写法lol</p>
<h3 id="109-Convert-Sorted-List-to-Binary-Search-Tree-Medium"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree-Medium" class="headerlink" title="109. Convert Sorted List to Binary Search Tree (Medium)"></a><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. Convert Sorted List to Binary Search Tree (Medium)</a></h3><p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:<br>Given the sorted linked list: [-10,-3,0,5,9],<br>One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     0</span><br><span class="line">    / \</span><br><span class="line">  -3   9</span><br><span class="line">  /   /</span><br><span class="line">-10  5</span><br></pre></td></tr></table></figure></p>
<p>space: O(n):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            nums.append(head.val)</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">return</span> self.helper(nums)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        mid = (len(nums) - <span class="number">1</span>) // <span class="number">2</span></span><br><span class="line">        root = TreeNode(nums[mid])</span><br><span class="line">        root.left = self.helper(nums[:mid])</span><br><span class="line">        root.right = self.helper(nums[mid + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>space: O(1):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedListToBST</span><span class="params">(self, head: ListNode)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(head, <span class="keyword">None</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, l, r)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l == r:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        s, f = l, l</span><br><span class="line">        <span class="keyword">while</span> f != r <span class="keyword">and</span> f.next != r:</span><br><span class="line">            s = s.next</span><br><span class="line">            f = f.next.next</span><br><span class="line">        root = TreeNode(s.val)</span><br><span class="line">        root.left = self.helper(l, s)</span><br><span class="line">        root.right = self.helper(s.next, r)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>高频：…if h == t: return None…while f != t and f.next != t…toBST(h, s)…toBST(s.next, t)…<br>二刷：space: O(1):…while f != r and f.next != r:…f(l, s)…f(s.next, r)…</p>
<h3 id="112-Path-Sum-Easy"><a href="#112-Path-Sum-Easy" class="headerlink" title="112. Path Sum (Easy)"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum (Easy)</a></h3><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br>Note: A leaf is a node with no children.</p>
<p>Example:<br>Given the below binary tree and sum = 22,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      5</span><br><span class="line">     / \</span><br><span class="line">    4   8</span><br><span class="line">   /   / \</span><br><span class="line">  11  13  4</span><br><span class="line"> /  \      \</span><br><span class="line">7    2      1</span><br></pre></td></tr></table></figure></p>
<p>return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.</p>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span><span class="params">(self, root: TreeNode, sum: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> root.val == sum <span class="keyword">and</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, sum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, sum - root.val)</span><br></pre></td></tr></table></figure></p>
<p>面经：Quora。<br>二刷：输入节点可能有负数，sum可能为负数</p>
<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</a></h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.<br>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given<br>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, preorder: List[int], inorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = TreeNode(preorder.pop(<span class="number">0</span>))</span><br><span class="line">        root.left = self.buildTree(preorder, inorder[:inorder.index(root.val)])</span><br><span class="line">        root.right =self.buildTree(preorder, inorder[inorder.index(root.val) + <span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>高频：精髓是找到当层递归的root index，然后递归左右子树<br>二刷：preorder 和 inorder均判断是否为空</p>
<h3 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</a></h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.<br>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given<br>inorder = [9,3,15,20,7]<br>postorder = [9,15,7,20,3]<br>Return the following binary tree:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure></p>
<p>O(n^2)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> inorder <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        root = TreeNode(postorder.pop())</span><br><span class="line">        idx = inorder.index(root.val)</span><br><span class="line">        root.right = self.buildTree(inorder[idx + <span class="number">1</span>:], postorder)</span><br><span class="line">        root.left = self.buildTree(inorder[:idx], postorder)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>O(n)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span><span class="params">(self, inorder: List[int], postorder: List[int])</span> -&gt; TreeNode:</span></span><br><span class="line">        mapping = &#123;v : i <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(inorder)&#125;</span><br><span class="line">        <span class="keyword">return</span> self.helper(<span class="number">0</span>, len(postorder) - <span class="number">1</span>, postorder, mapping)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, l, r, postorder, mapping)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> l &gt; r <span class="keyword">or</span> <span class="keyword">not</span> postorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = TreeNode(postorder.pop())</span><br><span class="line">            idx = mapping[root.val]</span><br><span class="line">            root.right = self.helper(idx + <span class="number">1</span>, r, postorder, mapping)</span><br><span class="line">            root.left = self.helper(l, idx - <span class="number">1</span>, postorder, mapping)</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>高频：上题的解法：…buildTree(…<strong>postorder[:i]</strong>)…buildTree(…postorder[i:])…更高效的新解法：…root.<strong>right</strong> = … root.left = …<br>二刷：因为postorder是左右中，从右pop的时候先拿到右子树，因此要从右子树开始递归，否则会出错。O(n):…f(0, len(postorder) <strong>- 1</strong>…</p>
<h3 id="116-Populating-Next-Right-Pointers-in-Each-Node-Medium"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node-Medium" class="headerlink" title="116. Populating Next Right Pointers in Each Node (Medium)"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node (Medium)</a></h3><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<br>Initially, all next pointers are set to NULL.<br>Example:<br><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="Populating Next Right Pointers example"></p>
<p>递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            root.left.next = root.right</span><br><span class="line">            root.right.next = root.next.left <span class="keyword">if</span> root.next <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">        self.connect(root.left)</span><br><span class="line">        self.connect(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>非递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        q = []</span><br><span class="line">        q.append(root)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(q):</span><br><span class="line">                <span class="keyword">if</span> i &lt; len(q) - <span class="number">1</span>:</span><br><span class="line">                    n.next = q[i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nq.append(n.left)</span><br><span class="line">                    nq.append(n.right)</span><br><span class="line">            q = nq</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>高频：递归分制比较好理解，刷了一个好理解的用q的非递归，更巧妙的pre，cur双指针相比之下不那么适合面试<br>二刷：递归：…root.right.next = <strong>root.next.left</strong> if…</p>
<h3 id="117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium" class="headerlink" title="117. Populating Next Right Pointers in Each Node II (Medium)"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II (Medium)</a></h3><p>Given a binary tree<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Node &#123;</span><br><span class="line">  int val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<br>Initially, all next pointers are set to NULL.<br>Example:<br><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="Populating Next Right Pointers example II"><br>Note:<br>You may only use constant extra space.<br>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</p>
<p>非递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            prev = <span class="keyword">None</span></span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(q)):</span><br><span class="line">                n = q.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> prev:</span><br><span class="line">                    prev.next = n</span><br><span class="line">                prev = n</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    q.append(n.left)</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    q.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, root: <span class="string">'Node'</span>)</span> -&gt; 'Node':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        leaf = root.next</span><br><span class="line">        <span class="keyword">while</span> leaf:</span><br><span class="line">            <span class="keyword">if</span> leaf.left:</span><br><span class="line">                leaf = leaf.left</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> leaf.right:</span><br><span class="line">                leaf = leaf.right</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            leaf = leaf.next</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            root.left.next = root.right <span class="keyword">if</span> root.right <span class="keyword">else</span> leaf</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            root.right.next = leaf</span><br><span class="line">        self.connect(root.right)</span><br><span class="line">        self.connect(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>高频：由于平层有可能子节点缺失，需要寻找到平层的最近子节点。递归时要右建立一些next关系再左，…while leaf:…leaf = leaf.next…root.right.next = leaf…数据结构导致debug很困难，需要记住答案。<br>二刷：非递归：每层用prev = None…prev = n…更容易记。递归：每层需要跳过root层next中无子节点的节点，来寻找root层最近的子节点（左或右子节点）。先递归右</p>
<h3 id="701-Insert-into-a-Binary-Search-Tree-Medium"><a href="#701-Insert-into-a-Binary-Search-Tree-Medium" class="headerlink" title="701. Insert into a Binary Search Tree (Medium)"></a><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/description/" target="_blank" rel="noopener">701. Insert into a Binary Search Tree (Medium)</a></h3><p><a href="http://www.lintcode.com/problem/insert-node-in-a-binary-search-tree/" target="_blank" rel="noopener">LinC Insert Node in a Binary Search Tree</a><br>Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.<br>Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">For example,</span><br><span class="line">Given the tree:</span><br><span class="line">        4</span><br><span class="line">       / \</span><br><span class="line">      2   7</span><br><span class="line">     / \</span><br><span class="line">    1   3</span><br><span class="line">And the value to insert: 5</span><br><span class="line">You can return this binary search tree:</span><br><span class="line">         4</span><br><span class="line">       /   \</span><br><span class="line">      2     7</span><br><span class="line">     / \   /</span><br><span class="line">    1   3 5</span><br><span class="line">This tree is also valid:</span><br><span class="line">         5</span><br><span class="line">       /   \</span><br><span class="line">      2     7</span><br><span class="line">     / \   </span><br><span class="line">    1   3</span><br><span class="line">         \</span><br><span class="line">          4</span><br></pre></td></tr></table></figure></p>
<p>递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root: TreeNode, val: int)</span> -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        <span class="keyword">if</span> val &gt; root.val:</span><br><span class="line">            root.right = self.insertIntoBST(root.right, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root.left = self.insertIntoBST(root.left, val)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>非递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root, val)</span>:</span></span><br><span class="line">        n = TreeNode(val)</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur != n:</span><br><span class="line">            <span class="keyword">if</span> n.val &gt; cur.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    cur.right = n</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                    cur.left = n</span><br><span class="line">                cur = cur.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>二刷：…if val &gt; root.val: root.right = f(…)…<br>三刷：递归：要有接的动作…<strong>root.right =</strong> f(…， 非递归：n = TreeNode(val)…</p>
<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree (Easy)"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree (Easy)</a></h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”<br>Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="LCA of BST example"><br>Example 1:<br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.</p>
<p>Example 2:<br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>Output: 2<br>Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<p>Note:<br>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the BST.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> p.val &gt; root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> p.val &lt; root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>
<p>三刷：只要p，q在同一子树中 (均比root大或小)，就一直走，直到条件不满足就直接走到LCA了。return f…return f…return root</p>
<h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree (Medium)"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">236. Lowest Common Ancestor of a Binary Tree (Medium)</a></h3><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”<br>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     _______3______</span><br><span class="line">    /              \</span><br><span class="line"> ___5__          ___1__</span><br><span class="line">/      \        /      \</span><br><span class="line">6      _2       0       8</span><br><span class="line">      /  \</span><br><span class="line">      7   4</span><br></pre></td></tr></table></figure></p>
<p>Example 1:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of of nodes 5 and 1 is 3.</p>
<p>Example 2:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>Output: 5<br>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself<br>             according to the LCA definition.</p>
<p>Note:<br>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the binary tree.</p>
<p>四刷递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        l = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        r = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l:</span><br><span class="line">            <span class="keyword">return</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> r:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>非递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root: <span class="string">'TreeNode'</span>, p: <span class="string">'TreeNode'</span>, q: <span class="string">'TreeNode'</span>)</span> -&gt; 'TreeNode':</span></span><br><span class="line">        parent = &#123;root: <span class="keyword">None</span>&#125;</span><br><span class="line">        queue = [root]</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            nq = []</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(queue)):</span><br><span class="line">                n = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> n.left:</span><br><span class="line">                    nq.append(n.left)</span><br><span class="line">                    parent[n.left] = n</span><br><span class="line">                <span class="keyword">if</span> n.right:</span><br><span class="line">                    nq.append(n.right)</span><br><span class="line">                    parent[n.right] = n</span><br><span class="line">            queue = nq</span><br><span class="line">        ancestors = set()</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            ancestors.add(p)</span><br><span class="line">            p = parent[p]</span><br><span class="line">        <span class="keyword">while</span> q <span class="keyword">not</span> <span class="keyword">in</span> ancestors:</span><br><span class="line">            q = parent[q]</span><br><span class="line">        <span class="keyword">return</span> q</span><br></pre></td></tr></table></figure></p>
<p>四刷：递归：就一个节点而言，如果找到了p或q返回自己…if root == p.val or…: return root…, 递归后要分析结果，如果没有左（左侧没有目标）则返回右，如果没有右则返回左。（否则）（有左和右）返回root<br>非递归：bfs遍历全树建立parent关系，p存入ancestor set，遍历p的parent，遍历q的parent，遇到在set中的即返回q。需给root加None这个Parent以防需要返回root…parent = {root: None}…</p>
<h2 id="Combination-based-DFS-基于组合的深度优先搜索"><a href="#Combination-based-DFS-基于组合的深度优先搜索" class="headerlink" title="Combination based DFS - 基于组合的深度优先搜索"></a>Combination based DFS - 基于组合的深度优先搜索</h2><h3 id="78-Subsets-Medium"><a href="#78-Subsets-Medium" class="headerlink" title="78. Subsets (Medium)"></a><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">78. Subsets (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given a set of distinct integers, nums, return all possible subsets (the power set).</span><br><span class="line"></span><br><span class="line">Note: The solution set must not contain duplicate subsets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：不太擅长组合和排列的题。这道题确实更像排列题，子集全排。DFS 模板：1.遍历输入元素；2.将当前元素加入 path；3。遍历递归当前元素之后的元素 i + 1；4：剪枝，将最后一个元素从 path 中去掉<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs([], <span class="number">0</span>, nums)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, path, index, nums)</span>:</span></span><br><span class="line">        self.ans.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> innerIndex <span class="keyword">in</span> range(index, len(nums)):</span><br><span class="line">            path.append(nums[innerIndex])</span><br><span class="line">            self.dfs(path, innerIndex + <span class="number">1</span>, nums)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：在 dfs 里，往 self.ans 添加答案的时候需要用 deep copy，不然的话会发生 self.ans 里面全是空的状况（感觉是因为最后剪枝的原因）。时间复杂度为 O(n*2^n) 指数级时间， 因为产生 2^n 个子 list，每个 list 的长度是 n 级的<br>二刷：这类 combination 的题要用 start，遍历递归时递归 i + 1 元素; 模板不直接遍历元素了， 下一题 permutation 三刷把代码改成模板，就没有 confusion 了。</p>
<p>三刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs([], <span class="number">0</span>, nums)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, path, start, nums)</span>:</span></span><br><span class="line">        self.ans.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            self.dfs(path, i + <span class="number">1</span>, nums)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：dfs内层循环中调用递归要用i + 1，如果用start会导致结果中重复使用相同位置的元素<br>高频：…dfs(path, start): ans.append(path[:])…注意此处无条件加入ans</p>
<h3 id="39-Combination-Sum-Medium"><a href="#39-Combination-Sum-Medium" class="headerlink" title="39. Combination Sum (Medium)"></a><a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="noopener">39. Combination Sum (Medium)</a></h3><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</p>
<p>The same repeated number may be chosen from candidates unlimited number of times.</p>
<p>Note:</p>
<p>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.</p>
<p>Example 1:<br>Input: candidates = [2,3,6,7], target = 7,<br>A solution set is:<br>[<br>  [7],<br>  [2,2,3]<br>]</p>
<p>Example 2:<br>Input: candidates = [2,3,5], target = 8,<br>A solution set is:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        candidates.sort()</span><br><span class="line">        self.dfs(candidates, target, [], ans, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, cur, ans, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sum(cur) == target:</span><br><span class="line">            ans.append(cur[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(candidates)):</span><br><span class="line">            <span class="keyword">if</span> sum(cur) + candidates[i] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            cur += [candidates[i]]</span><br><span class="line">            self.dfs(candidates, target, cur, ans, i)</span><br><span class="line">            <span class="keyword">del</span> cur[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：if target &lt; 0: return 改成 if target - candidates[i] &lt; 0: break，效率提升<br>高频：…dfs(total, path, start):…for i in range(<strong>start</strong>, len(candidates)):…dfs(total - n, path, <strong>i</strong>)…最后这个i千万不能写成不动的start了，极难de此bug<br>面经：Amazon。…dfs(…<strong>start</strong>):…for i in range(start, len(…))…self.dfs(…<strong>i</strong>)…</p>
<h3 id="40-Combination-Sum-II-Medium"><a href="#40-Combination-Sum-II-Medium" class="headerlink" title="40. Combination Sum II (Medium)"></a><a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener">40. Combination Sum II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</span><br><span class="line"></span><br><span class="line">Each number in candidates may only be used once in the combination.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All numbers (including target) will be positive integers.</span><br><span class="line">The solution set must not contain duplicate combinations.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        candidates.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(candidates, target, ans, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, ans, cur, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sum(cur) == target:</span><br><span class="line">            ans.append(cur[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(candidates)):</span><br><span class="line">            <span class="keyword">if</span> sum(cur) + candidates[i] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i] == candidates[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cur += [candidates[i]]</span><br><span class="line">            self.dfs(candidates, target, ans, cur, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">del</span> cur[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：删去一二刷的代码和总结，因为用的模板都不够容易记，三刷虽然执行效率很高却破坏了模板，不适合面试。…def dfs(path, target, start):…for i in range(<strong>start</strong>, n): <strong>if i &gt; start</strong> and …<br>面经：Amazon。…<strong>if i &gt; start</strong> and…</p>
<h3 id="216-Combination-Sum-III-Medium"><a href="#216-Combination-Sum-III-Medium" class="headerlink" title="216. Combination Sum III (Medium)"></a><a href="https://leetcode.com/problems/combination-sum-iii/description/" target="_blank" rel="noopener">216. Combination Sum III (Medium)</a></h3><p>Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</p>
<p>Note:<br>All numbers will be positive integers.<br>The solution set must not contain duplicate combinations.<br>Example 1:</p>
<p>Input: k = 3, n = 7<br>Output: [[1,2,4]]<br>Example 2:</p>
<p>Input: k = 3, n = 9<br>Output: [[1,2,6], [1,3,5], [2,3,4]]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(k, n, ans, [], <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, k, target, ans, cur, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> sum(cur) == target <span class="keyword">and</span> len(cur) == k:</span><br><span class="line">            ans.append(cur[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, <span class="number">10</span>):</span><br><span class="line">            <span class="keyword">if</span> sum(cur) + i &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            cur += [i]</span><br><span class="line">            self.dfs(k, target, ans, cur, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">del</span> cur[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>面经：删除了1，2刷的代码</p>
<h3 id="77-Combinations-Medium"><a href="#77-Combinations-Medium" class="headerlink" title="77. Combinations (Medium)"></a><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">77. Combinations (Medium)</a></h3><p>Given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>Example:<br>Input: n = 4, k = 2<br>Output:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(n, k, ans, [], <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, k, ans, cur, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(cur) == k:</span><br><span class="line">            ans.append(cur[:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, n + <span class="number">1</span>):</span><br><span class="line">            cur += [i]</span><br><span class="line">            self.dfs(n, k, ans, cur, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">del</span> cur[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。</p>
<h3 id="131-Palindrome-Partitioning-Medium"><a href="#131-Palindrome-Partitioning-Medium" class="headerlink" title="131. Palindrome Partitioning (Medium)"></a><a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="noopener">131. Palindrome Partitioning (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a string s, partition s such that every substring of the partition is a palindrome.</span><br><span class="line"></span><br><span class="line">Return all possible palindrome partitioning of s.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: "aab"</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  ["aa","b"],</span><br><span class="line">  ["a","a","b"]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：看了下答案， 唯一不太好懂的地方是 start &gt;= len(s) 才入 self.ans， 写好以后用测试数据看看为什么<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.ans</span><br><span class="line">        self.dfs(s, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= len(s):</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(start, len(s)):</span><br><span class="line">            subS = s[start:index + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> self.isPalindrome(subS):</span><br><span class="line">                path.append(subS)</span><br><span class="line">                self.dfs(s, path, index + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：注意：1.subStr[0:1] 返回第一个 char，[0:2] 返回 [0][1] 位置的 subStr；2.python 检查 palindrom 可以用 s == s[::-1]；3.self.ans.append(path[:]) 以后记得 return; 4.range(start, len(s)) 可以通过测试数据纠正。之所以用 start &gt;= len(s) 是因为要把 s 拆完一遍才能入 self.ans</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s: str)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(s, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == len(s):</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(s)):</span><br><span class="line">            subS = s[start : i + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> subS == subS[::<span class="number">-1</span>]:</span><br><span class="line">                path.append(subS)</span><br><span class="line">                self.dfs(s, path, i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：稍微精简了一下，要注意s[start : end], s[::-1]写法<br>高频：…dfs(path, start): if start == len(s):…subS = s[start <strong>:</strong> i + 1]…不是start == len(s) - 1</p>
<h3 id="93-Restore-IP-Addresses-Medium"><a href="#93-Restore-IP-Addresses-Medium" class="headerlink" title="93. Restore IP Addresses (Medium)"></a><a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener">93. Restore IP Addresses (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a string containing only digits, restore it by returning all possible valid IP address combinations.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: "25525511135"</span><br><span class="line">Output: ["255.255.11.135", "255.255.111.35"]</span><br></pre></td></tr></table></figure>
<p>思路：从上面的 131. Palindrome Partitioning (Medium) 和 LinC 680. Split String (Easy) 获得了灵感<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">12</span> <span class="keyword">or</span> len(s) &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(s, <span class="string">''</span>, <span class="number">0</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path, start, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> path.count(<span class="string">'.'</span>) &gt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == len(s) + <span class="number">4</span>:</span><br><span class="line">            ans.append(path[:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(s)):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(s[start:i + <span class="number">1</span>]):</span><br><span class="line">                path += s[start:i + <span class="number">1</span>] + <span class="string">'.'</span></span><br><span class="line">                self.dfs(s, path, i + <span class="number">1</span>, ans)</span><br><span class="line">                path = path[:-(i + <span class="number">2</span> - start)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> int(s) &gt;= <span class="number">0</span> <span class="keyword">and</span> int(s) &lt;= <span class="number">255</span></span><br></pre></td></tr></table></figure></p>
<p>总结：很多细节：1. start 跟着 i 走，没有前进；2. 遍历字符串取子串的时候要 range(, len + 1)， 不然会取不到最后一个字符<br>不算二刷，以上注意的第 2 点可以简化为取 s[start:i + 1]; 从上题 131. Palindrome Partitioning (Medium) 学的。</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt; <span class="number">4</span> <span class="keyword">or</span> len(s) &gt; <span class="number">12</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(num)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> &lt;= int(num) &lt;= <span class="number">255</span> <span class="keyword">and</span> str(int(num)) == num</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path, start)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) &gt; <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == <span class="number">4</span> <span class="keyword">and</span> len(<span class="string">''</span>.join(path)) == len(s):</span><br><span class="line">                res.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(s)):</span><br><span class="line">                subS = s[start: i + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span> isValid(subS):</span><br><span class="line">                    path.append(subS)</span><br><span class="line">                    dfs(path, i + <span class="number">1</span>)</span><br><span class="line">                    path.pop()</span><br><span class="line">        dfs([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">'.'</span>.join(i) <span class="keyword">for</span> i <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure></p>
<p>高频：…subS = s[start: i + 1]…</p>
<h3 id="LinC-680-Split-String-Easy"><a href="#LinC-680-Split-String-Easy" class="headerlink" title="LinC 680. Split String (Easy)"></a><a href="https://www.lintcode.com/problem/split-string/description" target="_blank" rel="noopener">LinC 680. Split String (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Give a string, you can choose to split the string after one character or two adjacent characters, and make the string to be composed of only one character or two characters. Output all possible results.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given the string "123"</span><br><span class="line">return [["1","2","3"],["12","3"],["1","23"]]</span><br></pre></td></tr></table></figure>
<p>思路：看了下答案，主要的文章就在递归退出的条件和 DFS 中 for 循环的起始条件。边写边想。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: : a string to be split</span></span><br><span class="line"><span class="string">    @return: all possible split string array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [[]]</span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(s, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= len(s):</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(start, start + <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> index &lt; len(s):</span><br><span class="line">                path.append(s[start:index + <span class="number">1</span>])</span><br><span class="line">                self.dfs(s, path, index + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：空输入的输出有点 wacky，for 循环内注意查越界（可以通过测试一个数据实现）</p>
<h3 id="90-Subsets-II-Medium"><a href="#90-Subsets-II-Medium" class="headerlink" title="90. Subsets II (Medium)"></a><a href="https://leetcode.com/problems/subsets-ii/description/" target="_blank" rel="noopener">90. Subsets II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</span><br><span class="line"></span><br><span class="line">Note: The solution set must not contain duplicate subsets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path, start)</span>:</span></span><br><span class="line">            ans.append(path[:])</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                dfs(path, i + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：将1，2刷的思路，代码和总结都删掉了，遵循模板的答案。…if i &gt; <strong>start</strong> and …</p>
<h3 id="140-Word-Break-II-Hard"><a href="#140-Word-Break-II-Hard" class="headerlink" title="140. Word Break II (Hard)"></a><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">140. Word Break II (Hard)</a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>Note:</p>
<p>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.<br>Example 1:</p>
<p>Input:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>Output:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]<br>Example 2:</p>
<p>Input:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>Output:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>Explanation: Note that you are allowed to reuse a dictionary word.<br>Example 3:</p>
<p>Input:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output:<br>[]</p>
<p>九章：DFS算法的掌握，主要在练习; 一个题第一遍不顺利，就要写第二遍，第三遍; 像 Word Break II 纯 DFS 版本 和 Regular Expression Matching 这样的问题，要练到 30 分钟内 AC。做不到就反复再练。<br>Strong Hire: DFS+DP优化<br>Hire / Weak Hire: DFS 能写完，且 Bug free or Bug 不多，不需要提示 or 需要少量提示<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(s, wordDict, &#123;&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, wordDict, memo)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[s]</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> wordDict:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> s.startswith(w):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> len(w) == len(s):</span><br><span class="line">                res.append(w)</span><br><span class="line">            restOfWords = self.dfs(s[len(w):], wordDict, memo)</span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> restOfWords:</span><br><span class="line">                item = <span class="string">f"<span class="subst">&#123;w&#125;</span> <span class="subst">&#123;item&#125;</span>"</span></span><br><span class="line">                res.append(item)</span><br><span class="line">        memo[s] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。…item = f”{w} {item}”; res.append(item)…</p>
<h2 id="Permutation-based-DFS-基于排列的深度优先搜索"><a href="#Permutation-based-DFS-基于排列的深度优先搜索" class="headerlink" title="Permutation based DFS - 基于排列的深度优先搜索"></a>Permutation based DFS - 基于排列的深度优先搜索</h2><h3 id="46-Permutations-Medium"><a href="#46-Permutations-Medium" class="headerlink" title="46. Permutations (Medium)"></a><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">46. Permutations (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of distinct integers, return all possible permutations.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：答案说要记具体某个点是否已经被访问过。写写看有没有什么坑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            self.visited[i] = <span class="keyword">False</span></span><br><span class="line">        self.dfs(nums, [], ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, path, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == len(nums):</span><br><span class="line">            ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> self.visited[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            self.visited[i] = <span class="keyword">True</span></span><br><span class="line">            self.dfs(nums, path, ans)</span><br><span class="line">            path.pop()</span><br><span class="line">            self.visited[i] = <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：思路 OK 的话貌似没有什么明显的坑<br>二刷：和 subset 和 combination sum 不同点在于排列进入 dfs 不需要 start 这个参数; 记得要有 self.visited, 存 path 的时候要 deep copy<br>三刷：遍历进递归的循环走 i, 和其他 DFS 模板保持一致。这题可以通过 if self.visited[i]: continue 来记需要一个 self.visited</p>
<p>四刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(nums, [])</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == len(nums):</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num <span class="keyword">in</span> path:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(num)</span><br><span class="line">            self.dfs(nums, path)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：比较简化的方法，重点是去重的机制，if num in path: continue。无需start，模板类似<br>高频：背dfs(path):…if n in path: continue…</p>
<h3 id="47-Permutations-II-Medium"><a href="#47-Permutations-II-Medium" class="headerlink" title="47. Permutations II (Medium)"></a><a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="noopener">47. Permutations II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of numbers that might contain duplicates, return all possible unique permutations.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：看了下答案，比上一题要多处理的两件事：1.要排序；2.对于相同的数在 for 循环里跳过；此处 for 循环要用 index 了因为有重复的数，要用 dict 统计该位置是否被用过<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums]</span><br><span class="line">        visited = &#123;i: <span class="keyword">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)&#125;</span><br><span class="line">        ans = []        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == n:</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> visited[i]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> visited[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                visited[i] = <span class="keyword">True</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                dfs(path)</span><br><span class="line">                visited[i] = <span class="keyword">False</span></span><br><span class="line">                path.pop()</span><br><span class="line">        nums.sort()</span><br><span class="line">        dfs([])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：注意相同数的跳过方法，需要用 if i &gt; 0 and nums[i] == nums[i - 1] and not visited[i - 1] i.e. 如果相等，需要前面的已经用过了才能用（相等且 i - 1 用过了就<strong>不</strong> continue，就是说这个重复的数是给前面的轮次在用）<br>二刷：和 combination sum II 的类似之处是 input 都可能有重复的元素。 和 permutation 类似之处是也需要 visited 记录已使用的元素。不同是 iterate 的时候要用 i, 还要 i == i - 1 and visited[i - 1] == False 来去重; dfs 里 iterate 的时候记得 if not self.visited；要细心，…and visited[i - 1] == false</p>
<p>三刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        self.dfs(nums, [])</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(nums[:i] + nums[i + <span class="number">1</span>:], path + [nums[i]])</span><br></pre></td></tr></table></figure></p>
<p>总结：更简洁的代码， 重点是递归终止的条件if len(nums) == 0:…;递归的方法self.dfs(nums[:i] + nums[i + 1:], path + [nums[i]])一步步将元素搬到path中<br>高频：三刷的方法更加巧妙， 直接传进去的时候就把nums里用过的当前元素给剪了。好懂一些的模板还是用一二刷的。需要背…if i &gt; 0 and nums[i] == nums[i - 1] and <strong>not visited[i - 1]</strong>:…这个剪枝条件</p>
<h3 id="LinC-862-Next-Closest-Time-Medium"><a href="#LinC-862-Next-Closest-Time-Medium" class="headerlink" title="LinC 862. Next Closest Time (Medium)"></a><a href="https://www.lintcode.com/problem/next-closest-time/description" target="_blank" rel="noopener">LinC 862. Next Closest Time (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a time represented in the format "HH:MM", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.</span><br><span class="line"></span><br><span class="line">You may assume the given input string is always valid. For example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.</span><br><span class="line"></span><br><span class="line">Example：</span><br><span class="line">Given time = "19:34", return "19:39".</span><br><span class="line">Explanation:</span><br><span class="line">The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.</span><br><span class="line"></span><br><span class="line">Given time = "23:59", return "22:22".</span><br><span class="line">Explanation:</span><br><span class="line">The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically.</span><br></pre></td></tr></table></figure>
<p>思路：属于对我来说现场想很费时的题。直接看答案找思路<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param time: the given time</span></span><br><span class="line"><span class="string">    @return: the next closest time</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextClosestTime</span><span class="params">(self, time)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        s = set(time)</span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> time</span><br><span class="line">        digits = time[<span class="number">0</span>:<span class="number">2</span>] + time[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">        self.ans = <span class="string">''</span></span><br><span class="line">        self.minDiff = sys.maxsize</span><br><span class="line">        self.target = int(time[<span class="number">0</span>:<span class="number">2</span>]) * <span class="number">60</span> + int(time[<span class="number">3</span>:<span class="number">5</span>])</span><br><span class="line">        self.dfs(digits, <span class="string">''</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, digits, path, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="number">4</span>:</span><br><span class="line">            <span class="comment"># path 产生了一个合法的时间，判断和 target 距离 diff 和 self.minDiff 的关系</span></span><br><span class="line">            m = int(path[<span class="number">0</span>:<span class="number">2</span>]) * <span class="number">60</span> + int(path[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">            diff = m - self.target</span><br><span class="line">            <span class="keyword">if</span> diff == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">                diff = <span class="number">24</span> * <span class="number">60</span> + diff</span><br><span class="line">            <span class="keyword">if</span> diff &lt; self.minDiff:</span><br><span class="line">                self.minDiff = diff</span><br><span class="line">                self.ans = path[<span class="number">0</span>:<span class="number">2</span>] + <span class="string">':'</span> + path[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> digits:</span><br><span class="line">            <span class="comment"># 处理 path, 把不合适的时间都 continue 过去, 但是怎么判断现在处理的是哪个位置？看了下答案， 其实不需要 enumerate</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">0</span> <span class="keyword">and</span> int(digit) &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">1</span> <span class="keyword">and</span> int(path) * <span class="number">10</span> + int(digit) &gt; <span class="number">23</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">2</span> <span class="keyword">and</span> int(digit) &gt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">3</span> <span class="keyword">and</span> int(path[<span class="number">2</span>:<span class="number">3</span>]) * <span class="number">10</span> + int(digit) &gt; <span class="number">59</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(digits, path + digit, start + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：python3 把 sys.maxint 改成 sys.maxsize 了。要一次对的话，很多取数的细节需要留心。1.input time 要取 [0:2] [3:5] 来跳过 ‘:’; 2.diff 是负数的时候要用 24 * 60 + diff（而不是 -）；3.for 循环里面的 digit 记得包上 int()</p>
<h3 id="22-Generate-Parentheses-Medium"><a href="#22-Generate-Parentheses-Medium" class="headerlink" title="22. Generate Parentheses (Medium)"></a><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="noopener">22. Generate Parentheses (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</span><br><span class="line"></span><br><span class="line">For example, given n = 3, a solution set is:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  "((()))",</span><br><span class="line">  "(()())",</span><br><span class="line">  "(())()",</span><br><span class="line">  "()(())",</span><br><span class="line">  "()()()"</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：既然是 backtracking / permutation based dfs 的题，先看看套路。有两个可能的路径， 第一种是：先 n 对括号的全排列，然后留 valid；第二种是：直接从 n 对括号里拼 valid 的排列，先试试第一种， 比较直观好理解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s = <span class="string">'('</span> * n + <span class="string">')'</span> * n</span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n * <span class="number">2</span>):</span><br><span class="line">            self.visited[i] = <span class="keyword">False</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(s, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == len(s):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(path):</span><br><span class="line">                self.ans.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> s[i] == s[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> self.visited[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.visited[i] = <span class="keyword">True</span></span><br><span class="line">            path += s[i]</span><br><span class="line">            self.dfs(s, path)</span><br><span class="line">            path = path[:<span class="number">-1</span>]</span><br><span class="line">            self.visited[i] = <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> path[<span class="number">0</span>] == <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> paren <span class="keyword">in</span> path:</span><br><span class="line">            <span class="keyword">if</span> paren == <span class="string">'('</span>:</span><br><span class="line">                stack.append(paren)</span><br><span class="line">            <span class="keyword">if</span> paren == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span>       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 二刷，稍微妖一点的 DFS 解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span>       </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans =[]</span><br><span class="line">        self.dfs(n, n, <span class="string">''</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, left, right, path, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">            ans.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">            self.dfs(left - <span class="number">1</span>, right, path + <span class="string">'('</span>, ans)</span><br><span class="line">        <span class="keyword">if</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:</span><br><span class="line">            self.dfs(left, right - <span class="number">1</span>, path + <span class="string">')'</span>, ans)</span><br></pre></td></tr></table></figure>
<p>总结：还挺佩服我自己的，调试下居然能过。。。虽然效率及其低下。。。立刻二刷吧。。。<br>二刷没什么好说的，left &lt; right ( 比 ) 数量多就 paren 就 valid。</p>
<p>三刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(left, right, path)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">                ans.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">                dfs(left - <span class="number">1</span>, right, path + <span class="string">'('</span>)</span><br><span class="line">            <span class="keyword">if</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:</span><br><span class="line">                dfs(left, right - <span class="number">1</span>, path + <span class="string">')'</span>)</span><br><span class="line">        dfs(n, n, <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：简化代码。注意if right &gt; 0 and left <strong>&lt;</strong> right:…这个条件，因为 left 和 right 是减的<br>高频：看代码就要意识到这是dfs/backtrack的题，要记得def dfs(<strong>left, right, path</strong>):…dfs(n, n, “”)…，还可以换一种写法if left == n and right == n:…if left &lt; n:…if right &lt; n and left &gt; right:…dfs(0, 0, “”)…</p>
<h3 id="51-N-Queens-Hard"><a href="#51-N-Queens-Hard" class="headerlink" title="51. N-Queens (Hard)"></a><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">51. N-Queens (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.</span><br><span class="line">Given an integer n, return all distinct solutions to the n-queens puzzle.</span><br><span class="line">Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: [</span><br><span class="line"> [".Q..",  // Solution 1</span><br><span class="line">  "...Q",</span><br><span class="line">  "Q...",</span><br><span class="line">  "..Q."],</span><br><span class="line"></span><br><span class="line"> ["..Q.",  // Solution 2</span><br><span class="line">  "Q...",</span><br><span class="line">  "...Q",</span><br><span class="line">  ".Q.."]</span><br><span class="line">]</span><br><span class="line">Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solveNQueens</span><span class="params">(self, n: int)</span> -&gt; List[List[str]]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(qs, xpys, ymxs)</span>:</span></span><br><span class="line">            p = len(qs)</span><br><span class="line">            <span class="keyword">if</span> p == n:</span><br><span class="line">                res.append(qs)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> q <span class="keyword">in</span> range(n):</span><br><span class="line">                <span class="keyword">if</span> q <span class="keyword">not</span> <span class="keyword">in</span> qs <span class="keyword">and</span> p + q <span class="keyword">not</span> <span class="keyword">in</span> xpys <span class="keyword">and</span> q - p <span class="keyword">not</span> <span class="keyword">in</span> ymxs:</span><br><span class="line">                    dfs(qs + [q], xpys + [p + q], ymxs + [q - p])</span><br><span class="line">        dfs([], [], [])</span><br><span class="line">        <span class="keyword">return</span> [[<span class="string">"."</span> * i + <span class="string">"Q"</span> + <span class="string">"."</span> * (n - i - <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> b] <span class="keyword">for</span> b <span class="keyword">in</span> res]</span><br></pre></td></tr></table></figure>
<p>高频：不得不说讨论区python的答案查x+y和y-x是比较天才的。N-Queens II 注意子函数中变量操作背后带=（assignment）的都要用self.ans全局变量</p>
<h2 id="Graph-based-DFS-基于图的深度优先搜索"><a href="#Graph-based-DFS-基于图的深度优先搜索" class="headerlink" title="Graph based DFS 基于图的深度优先搜索"></a>Graph based DFS 基于图的深度优先搜索</h2><h3 id="17-Letter-Combinations-of-a-Phone-Number-Medium"><a href="#17-Letter-Combinations-of-a-Phone-Number-Medium" class="headerlink" title="17. Letter Combinations of a Phone Number (Medium)"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</span><br><span class="line"></span><br><span class="line">A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode_17_lett_1.png" alt="keypad example"><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: "23"</span><br><span class="line">Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Although the above answer is in lexicographical order, your answer could be in any order you want.</span><br></pre></td></tr></table></figure></p>
<p>思路：看着像 DFS，但是没有特别具体的思路，看答案。看了下三年前写的代码，还挺牛逼的。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        <span class="keyword">if</span> len(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.ans</span><br><span class="line">        self.mapping = &#123;</span><br><span class="line">            <span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">            <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">            <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">            <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">            <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">            <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">            <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">            <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        self.dfs(digits, <span class="string">''</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, digits, path, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == len(digits):</span><br><span class="line">            self.ans.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> self.mapping[digits[start]]:</span><br><span class="line">            self.dfs(digits, path + letter, start + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：只能说三年前写的还挺牛逼的。。。<br>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="string">'2'</span>: <span class="string">'abc'</span>,</span><br><span class="line">            <span class="string">'3'</span>: <span class="string">'def'</span>,</span><br><span class="line">            <span class="string">'4'</span>: <span class="string">'ghi'</span>,</span><br><span class="line">            <span class="string">'5'</span>: <span class="string">'jkl'</span>,</span><br><span class="line">            <span class="string">'6'</span>: <span class="string">'mno'</span>,</span><br><span class="line">            <span class="string">'7'</span>: <span class="string">'pqrs'</span>,</span><br><span class="line">            <span class="string">'8'</span>: <span class="string">'tuv'</span>,</span><br><span class="line">            <span class="string">'9'</span>: <span class="string">'wxyz'</span></span><br><span class="line">        &#125;</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(path, start)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> len(path) == len(digits):</span><br><span class="line">                ans.append(path)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> mapping[digits[start]]:</span><br><span class="line">                path += c</span><br><span class="line">                dfs(path, start + <span class="number">1</span>)</span><br><span class="line">                path = path[:<span class="number">-1</span>]</span><br><span class="line">        dfs(<span class="string">""</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>高频：…for c in mapping[digits[start]]:…</p>
<h3 id="79-Word-Search-Medium"><a href="#79-Word-Search-Medium" class="headerlink" title="79. Word Search (Medium)"></a><a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="noopener">79. Word Search (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a 2D board and a word, find if the word exists in the grid.</span><br><span class="line"></span><br><span class="line">The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  ['A','B','C','E'],</span><br><span class="line">  ['S','F','C','S'],</span><br><span class="line">  ['A','D','E','E']</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = "ABCCED", return true.</span><br><span class="line">Given word = "SEE", return true.</span><br><span class="line">Given word = "ABCB", return false.</span><br></pre></td></tr></table></figure>
<p>思路：知道是 DFS 以后超级明显的一道题，两年多前居然写过。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">0</span>, len(board)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">0</span>, len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> self.dfs(board, row, col, word, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, row, col, word, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt; len(board) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt; len(board[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> board[row][col] != word[start]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        board[row][col] = <span class="string">'#'</span></span><br><span class="line">        <span class="comment"># up</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, row - <span class="number">1</span>, col, word, start + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># down</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, row + <span class="number">1</span>, col, word, start + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># left</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, row, col - <span class="number">1</span>, word, start + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># right</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, row, col + <span class="number">1</span>, word, start + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        board[row][col] = word[start]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：已经决定了不喜欢 x, y 千万不要动摇，row, col 到底。注意越界判断的时候要用 len(board) - 1 和 len(board[0]) - 1 而非 word。这次用了新写法，比两年多前的版本少了大约 10 行左右代码。<br>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(i, j, start)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> word[start] == board[i][j]:</span><br><span class="line">                <span class="keyword">if</span> start == len(word) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                board[i][j] = <span class="string">" "</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> dfs(i - <span class="number">1</span>, j, start + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">if</span> i &lt; len(board) - <span class="number">1</span> <span class="keyword">and</span> dfs(i + <span class="number">1</span>, j, start + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span> <span class="keyword">and</span> dfs(i, j - <span class="number">1</span>, start + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">if</span> j &lt; len(board[<span class="number">0</span>]) - <span class="number">1</span> <span class="keyword">and</span> dfs(i, j + <span class="number">1</span>, start + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                board[i][j] = word[start]</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span>   </span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> dfs(r, c, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：def dfs(i, j, start): if word[start] == board[i][j]: if start == len(word) - 1: return True…board[i][j] = word[start]; return False…</p>
<h3 id="490-The-Maze-Medium"><a href="#490-The-Maze-Medium" class="headerlink" title="490. The Maze (Medium)"></a><a href="https://leetcode.com/problems/the-maze" target="_blank" rel="noopener">490. The Maze (Medium)</a></h3><p>加锁题<br>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>
<p>Given the ball’s start position, the destination and the maze, determine whether the ball could stop at the destination.</p>
<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>
<p>Example 1<br>Input 1: a maze represented by a 2D array<br>0 0 1 0 0<br>0 0 0 0 0<br>0 0 0 1 0<br>1 1 0 1 1<br>0 0 0 0 0<br>Input 2: start coordinate (rowStart, colStart) = (0, 4)<br>Input 3: destination coordinate (rowDest, colDest) = (4, 4)</p>
<p>Output: true<br>Explanation: One possible way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.<br><img src="https://leetcode.com/static/images/problemset/maze_1_example_1.png" alt="the maze example 1"></p>
<p>Example 2<br>Input 1: a maze represented by a 2D array<br>0 0 1 0 0<br>0 0 0 0 0<br>0 0 0 1 0<br>1 1 0 1 1<br>0 0 0 0 0<br>Input 2: start coordinate (rowStart, colStart) = (0, 4)<br>Input 3: destination coordinate (rowDest, colDest) = (3, 2)</p>
<p>Output: false<br>Explanation: There is no way for the ball to stop at the destination.<br><img src="https://leetcode.com/static/images/problemset/maze_1_example_2.png" alt="the maze example 2"></p>
<p>Note:<br>1.There is only one ball and one destination in the maze.<br>2.Both the ball and the destination exist on an empty space, and they will not be at the same position initially.<br>3.The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.<br>4.The maze contains at least 2 empty spaces, and both the width and height of the maze won’t exceed 100.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPath</span><span class="params">(self, maze, start, destination)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type maze: List[List[int]]</span></span><br><span class="line"><span class="string">        :type start: List[int]</span></span><br><span class="line"><span class="string">        :type destination: List[int]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        visited = set()</span><br><span class="line">        m, n = len(maze), len(maze[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> self.dfs(maze, (start[<span class="number">0</span>], start[<span class="number">1</span>]), (destination[<span class="number">0</span>], destination[<span class="number">1</span>]), visited, m, n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, maze, cur, dest, visited, m, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cur == dest:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">in</span> visited:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        visited.add(cur)</span><br><span class="line">        <span class="keyword">for</span> rd, cd <span class="keyword">in</span> [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">-1</span>), (<span class="number">0</span>, <span class="number">1</span>)]:</span><br><span class="line">            r, c = cur</span><br><span class="line">            <span class="keyword">while</span> <span class="number">0</span> &lt;= r + rd &lt;= m - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= c + cd &lt;= n - <span class="number">1</span> <span class="keyword">and</span> maze[r + rd][c + cd] != <span class="number">1</span>:</span><br><span class="line">                r += rd</span><br><span class="line">                c += cd</span><br><span class="line">            <span class="keyword">if</span> self.dfs(maze, (r, c), dest, visited, m, n):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。注意…r, c = cur…必须在for下面，if self.dfs(…): return True…必须是这个结构。todo: BFS</p>
<h3 id="417-Pacific-Atlantic-Water-Flow-Medium"><a href="#417-Pacific-Atlantic-Water-Flow-Medium" class="headerlink" title="417. Pacific Atlantic Water Flow (Medium)"></a><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">417. Pacific Atlantic Water Flow (Medium)</a></h3><p>Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.<br>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.<br>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>
<p>Note:<br>The order of returned grid coordinates does not matter.<br>Both m and n are less than 150.</p>
<p>Example:<br>Given the following 5x5 matrix:<br>  Pacific ~   ~   ~   ~   ~<br>       ~  1   2   2   3  (5) <em><br>       ~  3   2   3  (4) (4) </em><br>       ~  2   4  (5)  3   1  <em><br>       ~ (6) (7)  1   4   5  </em><br>       ~ (5)  1   1   2   4  *</p>
<pre><code>*   *   *   *   * Atlantic
</code></pre><p>Return:<br>[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pacificAtlantic</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        reach_p = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        reach_a = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">        self.dirs = [(<span class="number">-1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">0</span>, <span class="number">-1</span>)]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(m):</span><br><span class="line">            self.dfs(matrix, r, <span class="number">0</span>, m, n, reach_p)</span><br><span class="line">            self.dfs(matrix, r, n - <span class="number">1</span>, m, n, reach_a)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(n):</span><br><span class="line">            self.dfs(matrix, <span class="number">0</span>, c, m, n, reach_p)</span><br><span class="line">            self.dfs(matrix, m - <span class="number">1</span>, c, m, n, reach_a)</span><br><span class="line">        <span class="keyword">return</span> [[r, c] <span class="keyword">for</span> r <span class="keyword">in</span> range(m) <span class="keyword">for</span> c <span class="keyword">in</span> range(n) <span class="keyword">if</span> reach_p[r][c] == <span class="keyword">True</span> <span class="keyword">and</span> reach_a[r][c] == <span class="keyword">True</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, matrix, r, c, m, n, reach)</span>:</span></span><br><span class="line">        reach[r][c] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> rd, cd <span class="keyword">in</span> self.dirs:</span><br><span class="line">            nr, nc = r + rd, c + cd</span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> &lt;= nr &lt;= m - <span class="number">1</span> <span class="keyword">and</span> <span class="number">0</span> &lt;= nc &lt;= n - <span class="number">1</span> <span class="keyword">and</span> matrix[nr][nc] &gt;= matrix[r][c] <span class="keyword">and</span> <span class="keyword">not</span> reach[nr][nc]:</span><br><span class="line"></span><br><span class="line">                self.dfs(matrix, nr, nc, m, n, reach)</span><br></pre></td></tr></table></figure></p>
<p>面经：Cruise Automation。dfs：从两个海开始往内陆灌，返回两个海都能灌到的地方 todo bfs</p>
<h1 id="Recursion-递归-Backtracking-DFS"><a href="#Recursion-递归-Backtracking-DFS" class="headerlink" title="Recursion 递归 / Backtracking / DFS"></a>Recursion 递归 / Backtracking / DFS</h1><h3 id="13-Roman-to-Integer-Easy"><a href="#13-Roman-to-Integer-Easy" class="headerlink" title="13. Roman to Integer (Easy)"></a><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. Roman to Integer (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</span><br><span class="line"></span><br><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br><span class="line">For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</span><br><span class="line"></span><br><span class="line">Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</span><br><span class="line"></span><br><span class="line">I can be placed before V (5) and X (10) to make 4 and 9.</span><br><span class="line">X can be placed before L (50) and C (100) to make 40 and 90.</span><br><span class="line">C can be placed before D (500) and M (1000) to make 400 and 900.</span><br><span class="line">Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "III"</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "IV"</span><br><span class="line">Output: 4</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: "IX"</span><br><span class="line">Output: 9</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: "LVIII"</span><br><span class="line">Output: 58</span><br><span class="line">Explanation: L = 50, V= 5, III = 3.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: "MCMXCIV"</span><br><span class="line">Output: 1994</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">romanToInt</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        mapping = &#123;</span><br><span class="line">            <span class="string">'M'</span>: <span class="number">1000</span>,</span><br><span class="line">            <span class="string">'D'</span>: <span class="number">500</span>,</span><br><span class="line">            <span class="string">'C'</span>: <span class="number">100</span>,</span><br><span class="line">            <span class="string">'L'</span>: <span class="number">50</span>,</span><br><span class="line">            <span class="string">'X'</span>: <span class="number">10</span>,</span><br><span class="line">            <span class="string">'V'</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">'I'</span>: <span class="number">1</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> mapping[s]</span><br><span class="line">        first, second, rest = s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>:]</span><br><span class="line">        <span class="keyword">if</span> mapping[first] &lt; mapping[second]:</span><br><span class="line">            <span class="keyword">return</span> mapping[second] - mapping[first] + self.romanToInt(rest)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> mapping[first] + self.romanToInt(second + rest)</span><br></pre></td></tr></table></figure></p>
<p>总结：…else: return <strong>mapping[first] + self.romanToInt(second + rest)</strong></p>
<h3 id="50-Pow-x-n-Medium"><a href="#50-Pow-x-n-Medium" class="headerlink" title="50. Pow(x, n) (Medium)"></a><a href="https://leetcode.com/problems/powx-n/description/" target="_blank" rel="noopener">50. Pow(x, n) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Implement pow(x, n), which calculates x raised to the power n (xn).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">n is a 32-bit signed integer, within the range [−231, 231 − 1]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(x, n) <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span>/self.helper(x, -n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = self.helper(x, n//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> res * res <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">else</span> x * res * res</span><br></pre></td></tr></table></figure>
<p>总结：有固定写法套路的题目， 不值得做。<br>高频：稍微精简了一点，为高频而刷</p>
<h3 id="4-Median-of-Two-Sorted-Arrays-Hard"><a href="#4-Median-of-Two-Sorted-Arrays-Hard" class="headerlink" title="4. Median of Two Sorted Arrays (Hard)"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. Median of Two Sorted Arrays (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">There are two sorted arrays nums1 and nums2 of size m and n respectively.</span><br><span class="line"></span><br><span class="line">Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</span><br><span class="line"></span><br><span class="line">You may assume nums1 and nums2 cannot be both empty.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedianSortedArrays</span><span class="params">(self, nums1: List[int], nums2: List[int])</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums1 <span class="keyword">and</span> <span class="keyword">not</span> nums2:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        m, n = len(nums1), len(nums2)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">findK</span><span class="params">(a, b, k)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> a:</span><br><span class="line">                <span class="keyword">return</span> b[k]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> b:</span><br><span class="line">                <span class="keyword">return</span> a[k]</span><br><span class="line">            ai, bi = len(a) // <span class="number">2</span>, len(b) // <span class="number">2</span></span><br><span class="line">            am, bm = a[ai], b[bi]</span><br><span class="line">            <span class="keyword">if</span> k &gt; ai + bi:</span><br><span class="line">                <span class="keyword">if</span> am &lt; bm:</span><br><span class="line">                    <span class="keyword">return</span> findK(a[ai + <span class="number">1</span>:], b, k - ai - <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> findK(a, b[bi + <span class="number">1</span>:], k - bi - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> am &gt; bm:</span><br><span class="line">                    <span class="keyword">return</span> findK(a[:ai], b, k)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> findK(a, b[:bi], k)</span><br><span class="line">        <span class="keyword">if</span> (m + n) % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> findK(nums1, nums2, (m + n) // <span class="number">2</span>) * <span class="number">0.5</span> + findK(nums1, nums2, (m + n) //<span class="number">2</span> - <span class="number">1</span>) * <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> findK(nums1, nums2, (m + n) // <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>高频：总长度是奇偶数分开做，…def findK(a, b, k):…if…:…return findK(a[ai + 1:], b, k - ai - 1)…</p>
<h3 id="653-Two-Sum-IV-Input-is-a-BST-Easy"><a href="#653-Two-Sum-IV-Input-is-a-BST-Easy" class="headerlink" title="653. Two Sum IV - Input is a BST (Easy)"></a><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. Two Sum IV - Input is a BST (Easy)</a></h3><p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p>
<p>Example 1:<br>Input:<br>    5<br>   / \<br>  3   6<br> / \   \<br>2   4   7</p>
<p>Target = 9<br>Output: True</p>
<p>Example 2:<br>Input:<br>    5<br>   / \<br>  3   6<br> / \   \<br>2   4   7</p>
<p>Target = 28<br>Output: False<br>hash表/set方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        seen = set()</span><br><span class="line">        <span class="keyword">return</span> self.helper(root, k, seen)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, k, seen)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> k - root.val <span class="keyword">in</span> seen:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        seen.add(root.val)</span><br><span class="line">        <span class="keyword">return</span> self.helper(root.left, k, seen) <span class="keyword">or</span> self.helper(root.right, k, seen)</span><br></pre></td></tr></table></figure></p>
<p>非递归BFS：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        q, seen = [root], set()</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> q:</span><br><span class="line">            <span class="keyword">if</span> k - n.val <span class="keyword">in</span> seen:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            seen.add(n.val)</span><br><span class="line">            <span class="keyword">if</span> n.left:</span><br><span class="line">                q.append(n.left)</span><br><span class="line">            <span class="keyword">if</span> n.right:</span><br><span class="line">                q.append(n.right)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>in-order/中序遍历双指针：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findTarget</span><span class="params">(self, root: TreeNode, k: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        res = []</span><br><span class="line">        self.inorder(root, res)</span><br><span class="line">        i, j = <span class="number">0</span>, len(res) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            t = res[i] + res[j]</span><br><span class="line">            <span class="keyword">if</span> t == k:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> t &lt; k:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root, res)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inorder(root.left, res)</span><br><span class="line">        res.append(root.val)</span><br><span class="line">        self.inorder(root.right, res)</span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h2><h3 id="LinC-6-Merge-Two-Sorted-Arrays-Easy"><a href="#LinC-6-Merge-Two-Sorted-Arrays-Easy" class="headerlink" title="LinC 6. Merge Two Sorted Arrays (Easy)"></a><a href="https://www.lintcode.com/problem/merge-two-sorted-arrays/description" target="_blank" rel="noopener">LinC 6. Merge Two Sorted Arrays (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Merge two given sorted integer array A and B into a new sorted integer array.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">A=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">B=[2,4,5,6]</span><br><span class="line"></span><br><span class="line">return [1,2,2,3,4,4,5,6]</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">How can you optimize your algorithm if one array is very large and the other is very small?</span><br></pre></td></tr></table></figure>
<p>思路：热身题，直接做<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: sorted integer array A</span></span><br><span class="line"><span class="string">    @param B: sorted integer array B</span></span><br><span class="line"><span class="string">    @return: A new sorted integer array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSortedArray</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        ans = []</span><br><span class="line">        indexA = <span class="number">0</span></span><br><span class="line">        indexB = <span class="number">0</span></span><br><span class="line">        indexC = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> indexC &lt; len(A) + len(B):</span><br><span class="line">            <span class="keyword">if</span> indexA == len(A) <span class="keyword">or</span> indexB == len(B):</span><br><span class="line">                <span class="keyword">if</span> indexA == len(A):</span><br><span class="line">                    ans.append(B[indexB])</span><br><span class="line">                    indexB += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append(A[indexA])</span><br><span class="line">                    indexA += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> A[indexA] &lt; B[indexB]:</span><br><span class="line">                    ans.append(A[indexA])</span><br><span class="line">                    indexA += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append(B[indexB])</span><br><span class="line">                    indexB += <span class="number">1</span></span><br><span class="line">            indexC += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：非常值得刷的一道热身题， 需要考虑两个 array 越界的问题。看了下答案用三个 while 循环也可以。</p>
<h3 id="88-Merge-Sorted-Array-Easy"><a href="#88-Merge-Sorted-Array-Easy" class="headerlink" title="88. Merge Sorted Array (Easy)"></a><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">88. Merge Sorted Array (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The number of elements initialized in nums1 and nums2 are m and n respectively.</span><br><span class="line">You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p>思路：直觉上想不太出来怎么不创建新的存储空间把小数组 merge 到大数组里。看了答案，如果 nums1 后面空着这么些空，就从后面开始填。哎，曾经是能自主想的出的。。。正着困难的话就反着试试<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1) == len(nums2):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)):</span><br><span class="line">                nums1[i] = nums2[i]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index1 = m - <span class="number">1</span></span><br><span class="line">        index2 = n - <span class="number">1</span></span><br><span class="line">        index3 = len(nums1) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> index3 &gt;= <span class="number">0</span> <span class="keyword">and</span> index2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> index1 &lt; <span class="number">0</span>:</span><br><span class="line">                nums1[index3] = nums2[index2]</span><br><span class="line">                index2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums1[index1] &lt; nums2[index2]:</span><br><span class="line">                    nums1[index3] = nums2[index2]</span><br><span class="line">                    index2 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums1[index3] = nums1[index1]</span><br><span class="line">                    index1 -= <span class="number">1</span></span><br><span class="line">            index3 -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：虽然是 easy 题，要考虑情况：1.nums1 和 nums2 一样大的话需要逐个考过去；2.index2 如果走到最前面就可以结束了。注意题目的输入包含了 m 和 n 要利用好</p>
<p>高频：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1: List[int], m: int, nums2: List[int], n: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            nums1[:] = nums2[:]</span><br><span class="line">        i1 = m - <span class="number">1</span></span><br><span class="line">        i2 = n - <span class="number">1</span></span><br><span class="line">        im = m + n - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i1 &gt;= <span class="number">0</span> <span class="keyword">and</span> i2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[i1] &lt; nums2[i2]:</span><br><span class="line">                nums1[im] = nums2[i2]</span><br><span class="line">                i2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[im] = nums1[i1]</span><br><span class="line">                i1 -= <span class="number">1</span></span><br><span class="line">            im -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i1 &lt; <span class="number">0</span>:</span><br><span class="line">            nums1[:i2 + <span class="number">1</span>] = nums2[:i2 + <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：代码简化，也更好理解一些，算法还是原来的，从nums1后往前填，注意最后如果nums1都填完了要把nums2剩余的都天过去nums1[:i2 <strong>+ 1</strong>] = nums2[:i2 <strong>+ 1</strong>]</p>
<h3 id="73-Set-Matrix-Zeroes-Medium"><a href="#73-Set-Matrix-Zeroes-Medium" class="headerlink" title="73. Set Matrix Zeroes (Medium)"></a><a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">73. Set Matrix Zeroes (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1,1,1],</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [1,1,1]</span><br><span class="line">]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,0,1],</span><br><span class="line">  [0,0,0],</span><br><span class="line">  [1,0,1]</span><br><span class="line">]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [0,1,2,0],</span><br><span class="line">  [3,4,5,2],</span><br><span class="line">  [1,3,1,5]</span><br><span class="line">]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [0,0,0,0],</span><br><span class="line">  [0,4,5,0],</span><br><span class="line">  [0,3,1,0]</span><br><span class="line">]</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">A straight forward solution using O(mn) space is probably a bad idea.</span><br><span class="line">A simple improvement uses O(m + n) space, but still not the best solution.</span><br><span class="line">Could you devise a constant space solution?</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        r0 = set()</span><br><span class="line">        c0 = set()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> matrix[r][c] == <span class="number">0</span>:</span><br><span class="line">                    r0.add(r)</span><br><span class="line">                    c0.add(c)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> r0:</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(len(matrix[<span class="number">0</span>])):</span><br><span class="line">                matrix[r][c] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> c0:</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> range(len(matrix)):</span><br><span class="line">                matrix[r][c] = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>总结：O(m+n)空间的解法<br>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setZeroes</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        is1stRZ, is1stCZ = <span class="keyword">True</span> <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> matrix[<span class="number">0</span>] <span class="keyword">else</span> <span class="keyword">False</span>, <span class="keyword">True</span> <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">in</span> list(zip(*matrix))[<span class="number">0</span>] <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i, r <span class="keyword">in</span> enumerate(matrix):</span><br><span class="line">            <span class="keyword">for</span> j, c <span class="keyword">in</span> enumerate(r):</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">and</span> j <span class="keyword">and</span> c == <span class="number">0</span>:</span><br><span class="line">                    matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">                    matrix[<span class="number">0</span>][j] = <span class="number">0</span></span><br><span class="line">        m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            <span class="keyword">if</span> matrix[i][<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                matrix[i] = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> matrix[<span class="number">0</span>][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                    matrix[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> is1stRZ:</span><br><span class="line">            matrix[<span class="number">0</span>] = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">if</span> is1stCZ:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>总结：O(1)空间</p>
<h3 id="56-Merge-Intervals-Medium"><a href="#56-Merge-Intervals-Medium" class="headerlink" title="56. Merge Intervals (Medium)"></a><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">56. Merge Intervals (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of intervals, merge all overlapping intervals.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">Output: [[1,6],[8,10],[15,18]]</span><br><span class="line">Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [[1,4],[4,5]]</span><br><span class="line">Output: [[1,5]]</span><br><span class="line">Explanation: Intervals [1,4] and [4,5] are considered overlapping.</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        intervals.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        ans = []</span><br><span class="line">        cur = intervals[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(intervals)):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">0</span>] &lt;= cur[<span class="number">1</span>]:</span><br><span class="line">                cur[<span class="number">1</span>] = max(intervals[i][<span class="number">1</span>], cur[<span class="number">1</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(cur[:])</span><br><span class="line">                cur = intervals[i]</span><br><span class="line">        ans.append(cur)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>面经：Cruise。…cur[1] = <strong>max(intervals[i][1], cur[1])</strong>…</p>
<h3 id="LinC-839-Merge-Two-Sorted-Interval-Lists-Easy"><a href="#LinC-839-Merge-Two-Sorted-Interval-Lists-Easy" class="headerlink" title="LinC 839. Merge Two Sorted Interval Lists (Easy)"></a><a href="https://www.lintcode.com/problem/merge-two-sorted-interval-lists/description" target="_blank" rel="noopener">LinC 839. Merge Two Sorted Interval Lists (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Merge two sorted (ascending) lists of interval and return it as a new sorted list. The new sorted list should be made by splicing together the intervals of the two lists and sorted in ascending order.</span><br><span class="line"></span><br><span class="line">The intervals in the given list do not overlap.</span><br><span class="line">The intervals in different lists may overlap.</span><br><span class="line">Example</span><br><span class="line">Given list1 = [(1,2),(3,4)] and list2 = [(2,3),(5,6)], return [(1,4),(5,6)].</span><br></pre></td></tr></table></figure>
<p>思路：思路跟上题 merge interval一样，可以不做<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of Interval.</span></span><br><span class="line"><span class="string">class Interval(object):</span></span><br><span class="line"><span class="string">    def __init__(self, start, end):</span></span><br><span class="line"><span class="string">        self.start = start</span></span><br><span class="line"><span class="string">        self.end = end</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param list1: one of the given list</span></span><br><span class="line"><span class="string">    @param list2: another list</span></span><br><span class="line"><span class="string">    @return: the new sorted list of interval</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoInterval</span><span class="params">(self, list1, list2)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list1:</span><br><span class="line">            <span class="keyword">return</span> list2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> list2:</span><br><span class="line">            <span class="keyword">return</span> list1</span><br><span class="line">        list3 = list1 + list2</span><br><span class="line">        list3.sort(key=<span class="keyword">lambda</span> x: x.start)</span><br><span class="line">        ans = [list3[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(list3)):</span><br><span class="line">            <span class="keyword">if</span> list3[i].start &lt;= ans[<span class="number">-1</span>].end:</span><br><span class="line">                ans[<span class="number">-1</span>].end = max(list3[i].end, ans[<span class="number">-1</span>].end)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(list3[i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>二刷：删掉一刷代码，统一思路</p>
<h3 id="228-Summary-Ranges-Medium"><a href="#228-Summary-Ranges-Medium" class="headerlink" title="228. Summary Ranges (Medium)"></a><a href="https://leetcode.com/problems/summary-ranges/description/" target="_blank" rel="noopener">228. Summary Ranges (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted integer array without duplicates, return the summary of its ranges.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:  [0,1,2,4,5,7]</span><br><span class="line">Output: ["0-&gt;2","4-&gt;5","7"]</span><br><span class="line">Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:  [0,2,3,4,6,8,9]</span><br><span class="line">Output: ["0","2-&gt;4","6","8-&gt;9"]</span><br><span class="line">Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先写 O(n) 的再优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans, start = [], <span class="number">0</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">addToRes</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> l == r:</span><br><span class="line">                ans.append(str(nums[l]))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(<span class="string">f"<span class="subst">&#123;str(nums[l])&#125;</span>-&gt;<span class="subst">&#123;str(nums[r])&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i + <span class="number">1</span>] - <span class="number">1</span>:</span><br><span class="line">                addToRes(start, i)</span><br><span class="line">                start = i + <span class="number">1</span></span><br><span class="line">        addToRes(start, len(nums) - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>二刷：删掉了一刷的思路，代码和总结。 ..start = 0…def addToRes(l, r):…start = i + 1…</p>
<h3 id="67-Add-Binary-Easy"><a href="#67-Add-Binary-Easy" class="headerlink" title="67. Add Binary (Easy)"></a><a href="https://leetcode.com/problems/add-binary/" target="_blank" rel="noopener">67. Add Binary (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given two binary strings, return their sum (also a binary string).</span><br><span class="line"></span><br><span class="line">The input strings are both non-empty and contains only characters 1 or 0.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: a = "11", b = "1"</span><br><span class="line">Output: "100"</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: a = "1010", b = "1011"</span><br><span class="line">Output: "10101"</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addBinary</span><span class="params">(self, a: str, b: str)</span> -&gt; str:</span></span><br><span class="line">        m = len(a)</span><br><span class="line">        n = len(b)</span><br><span class="line">        l = max(m, n)</span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        carry = <span class="number">0</span></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= l:</span><br><span class="line">            <span class="keyword">if</span> i &lt;= m <span class="keyword">and</span> i &lt;= n:</span><br><span class="line">                val = int(a[-i]) + int(b[-i]) + carry</span><br><span class="line">            <span class="keyword">elif</span> i &lt;= m:</span><br><span class="line">                val = int(a[-i]) + carry</span><br><span class="line">            <span class="keyword">elif</span> i &lt;= n:</span><br><span class="line">                val = int(b[-i]) + carry</span><br><span class="line">            <span class="keyword">if</span> val &gt; <span class="number">1</span>:</span><br><span class="line">                carry = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                carry = <span class="number">0</span></span><br><span class="line">            ans = str(val % <span class="number">2</span>) + ans</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> carry == <span class="number">1</span>:</span><br><span class="line">            ans = <span class="string">"1"</span> + ans</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：…<strong>i = 1</strong>…while i <strong>&lt;=</strong> l:…if val &gt; 1: carry = 1; else: carry = 0; ans = str(val % 2) + ans; i += 1…</p>
<h3 id="12-Integer-to-Roman-Medium"><a href="#12-Integer-to-Roman-Medium" class="headerlink" title="12. Integer to Roman (Medium)"></a><a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">12. Integer to Roman (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.</span><br><span class="line"></span><br><span class="line">Symbol       Value</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br><span class="line">For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.</span><br><span class="line"></span><br><span class="line">Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:</span><br><span class="line"></span><br><span class="line">I can be placed before V (5) and X (10) to make 4 and 9.</span><br><span class="line">X can be placed before L (50) and C (100) to make 40 and 90.</span><br><span class="line">C can be placed before D (500) and M (1000) to make 400 and 900.</span><br><span class="line">Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: "III"</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: "IV"</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 9</span><br><span class="line">Output: "IX"</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: 58</span><br><span class="line">Output: "LVIII"</span><br><span class="line">Explanation: L = 50, V = 5, III = 3.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: 1994</span><br><span class="line">Output: "MCMXCIV"</span><br><span class="line">Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intToRoman</span><span class="params">(self, num: int)</span> -&gt; str:</span></span><br><span class="line">        n = [<span class="number">1000</span>, <span class="number">900</span>, <span class="number">500</span>, <span class="number">400</span>, <span class="number">100</span>, <span class="number">90</span>, <span class="number">50</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line">        l = [<span class="string">"M"</span>, <span class="string">"CM"</span>, <span class="string">"D"</span>, <span class="string">"CD"</span>, <span class="string">"C"</span>, <span class="string">"XC"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>, <span class="string">"X"</span>, <span class="string">"IX"</span>, <span class="string">"V"</span>, <span class="string">"IV"</span>, <span class="string">"I"</span>]</span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(n):</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            t = num // v</span><br><span class="line">            ans += l[i] * t</span><br><span class="line">            num %= v</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：有了n和l俩数组就是easy了</p>
<h3 id="43-Multiply-Strings-Medium"><a href="#43-Multiply-Strings-Medium" class="headerlink" title="43. Multiply Strings (Medium)"></a><a href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener">43. Multiply Strings (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: num1 = "2", num2 = "3"</span><br><span class="line">Output: "6"</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: num1 = "123", num2 = "456"</span><br><span class="line">Output: "56088"</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The length of both num1 and num2 is <span class="tag">&lt; <span class="attr">110.</span></span></span><br><span class="line"><span class="tag"><span class="attr">Both</span> <span class="attr">num1</span> <span class="attr">and</span> <span class="attr">num2</span> <span class="attr">contain</span> <span class="attr">only</span> <span class="attr">digits</span> <span class="attr">0-9.</span></span></span><br><span class="line"><span class="tag"><span class="attr">Both</span> <span class="attr">num1</span> <span class="attr">and</span> <span class="attr">num2</span> <span class="attr">do</span> <span class="attr">not</span> <span class="attr">contain</span> <span class="attr">any</span> <span class="attr">leading</span> <span class="attr">zero</span>, <span class="attr">except</span> <span class="attr">the</span> <span class="attr">number</span> <span class="attr">0</span> <span class="attr">itself.</span></span></span><br><span class="line"><span class="tag"><span class="attr">You</span> <span class="attr">must</span> <span class="attr">not</span> <span class="attr">use</span> <span class="attr">any</span> <span class="attr">built-in</span> <span class="attr">BigInteger</span> <span class="attr">library</span> <span class="attr">or</span> <span class="attr">convert</span> <span class="attr">the</span> <span class="attr">inputs</span> <span class="attr">to</span> <span class="attr">integer</span> <span class="attr">directly.</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, num1: str, num2: str)</span> -&gt; str:</span></span><br><span class="line">        res = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(num1) + len(num2))]</span><br><span class="line">        num1 = num1[::<span class="number">-1</span>]</span><br><span class="line">        num2 = num2[::<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(num1)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(num2)):</span><br><span class="line">                res[i + j] += int(num1[i]) * int(num2[j])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(res)):</span><br><span class="line">            d = res[i] % <span class="number">10</span></span><br><span class="line">            c = res[i] // <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> i &lt; len(res) - <span class="number">1</span>:</span><br><span class="line">                res[i + <span class="number">1</span>] += c</span><br><span class="line">            res[i] = d</span><br><span class="line"></span><br><span class="line">        res.reverse()</span><br><span class="line">        <span class="keyword">while</span> res[<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">and</span> len(res) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">del</span> res[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>.join(str(i) <span class="keyword">for</span> i <span class="keyword">in</span> res)</span><br></pre></td></tr></table></figure>
<p>高频：…for i in range(len(res)):…res[i] = d…<strong>while</strong> res[0] == 0 and len(res) &gt; 1:…</p>
<h3 id="128-Longest-Consecutive-Sequence-Medium"><a href="#128-Longest-Consecutive-Sequence-Medium" class="headerlink" title="128. Longest Consecutive Sequence (Medium)"></a><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. Longest Consecutive Sequence (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</span><br><span class="line"></span><br><span class="line">Your algorithm should run in O(n) complexity.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [100, 4, 200, 1, 3, 2]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestConsecutive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        nums = set(nums)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> n - <span class="number">1</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                m = n + <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> m <span class="keyword">in</span> nums:</span><br><span class="line">                    m += <span class="number">1</span></span><br><span class="line">                ans = max(ans, m - n)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：不明白为什么要作为高频题，除了惊叹于答案之神乎其技， 几乎学不到任何东西</p>
<h3 id="66-Plus-One-Easy"><a href="#66-Plus-One-Easy" class="headerlink" title="66. Plus One (Easy)"></a><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">66. Plus One (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty array of digits representing a non-negative integer, plus one to the integer.</span><br><span class="line"></span><br><span class="line">The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.</span><br><span class="line"></span><br><span class="line">You may assume the integer does not contain any leading zero, except the number 0 itself.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3]</span><br><span class="line">Output: [1,2,4]</span><br><span class="line">Explanation: The array represents the integer 123.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [4,3,2,1]</span><br><span class="line">Output: [4,3,2,2]</span><br><span class="line">Explanation: The array represents the integer 4321.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span><span class="params">(self, digits: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        digits.reverse()</span><br><span class="line">        c = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, d <span class="keyword">in</span> enumerate(digits):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                d += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                d += c</span><br><span class="line">            c = d // <span class="number">10</span></span><br><span class="line">            d = d % <span class="number">10</span></span><br><span class="line">            digits[i] = d</span><br><span class="line">        <span class="keyword">if</span> c &gt; <span class="number">0</span>:</span><br><span class="line">            digits.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p>高频</p>
<h3 id="9-Palindrome-Number-Easy"><a href="#9-Palindrome-Number-Easy" class="headerlink" title="9. Palindrome Number (Easy)"></a><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">9. Palindrome Number (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 121</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -121</span><br><span class="line">Output: false</span><br><span class="line">Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 10</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Reads 01 from right to left. Therefore it is not a palindrome.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">Coud you solve it without converting the integer to a string?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, x: int)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        ox = x</span><br><span class="line">        nx = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            t = x % <span class="number">10</span></span><br><span class="line">            nx = nx * <span class="number">10</span> + t</span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> nx == ox</span><br></pre></td></tr></table></figure>
<p>高频：…nx = nx * 10 + t…</p>
<h3 id="59-Spiral-Matrix-II-Medium"><a href="#59-Spiral-Matrix-II-Medium" class="headerlink" title="59. Spiral Matrix II (Medium)"></a><a href="https://leetcode.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. Spiral Matrix II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 8, 9, 4 ],</span><br><span class="line"> [ 7, 6, 5 ]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateMatrix</span><span class="params">(self, n: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        ans = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        mode, r, c, circle = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n * n + <span class="number">1</span>):</span><br><span class="line">            ans[r][c] = i</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="number">0</span>:</span><br><span class="line">                c += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c == n - <span class="number">1</span> - circle:</span><br><span class="line">                    mode = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">1</span>:</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> r == n - <span class="number">1</span> - circle:</span><br><span class="line">                    mode = <span class="number">2</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">2</span>:</span><br><span class="line">                c -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c == circle:</span><br><span class="line">                    mode = <span class="number">3</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> r == circle + <span class="number">1</span>:</span><br><span class="line">                    mode = <span class="number">0</span></span><br><span class="line">                    circle += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：…if c == n - 1 - circle:…if r == n - 1 - circle:…if c == circle:…if r = circle + 1:…</p>
<h3 id="48-Rotate-Image-Medium"><a href="#48-Rotate-Image-Medium" class="headerlink" title="48. Rotate Image (Medium)"></a><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">48. Rotate Image (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">You are given an n x n 2D matrix representing an image.</span><br><span class="line">Rotate the image by 90 degrees (clockwise).</span><br><span class="line">Note:</span><br><span class="line">You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [4,5,6],</span><br><span class="line">  [7,8,9]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [7,4,1],</span><br><span class="line">  [8,5,2],</span><br><span class="line">  [9,6,3]</span><br><span class="line">]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given input matrix =</span><br><span class="line">[</span><br><span class="line">  [ 5, 1, 9,11],</span><br><span class="line">  [ 2, 4, 8,10],</span><br><span class="line">  [13, 3, 6, 7],</span><br><span class="line">  [15,14,12,16]</span><br><span class="line">],</span><br><span class="line"></span><br><span class="line">rotate the input matrix in-place such that it becomes:</span><br><span class="line">[</span><br><span class="line">  [15,13, 2, 5],</span><br><span class="line">  [14, 3, 4, 1],</span><br><span class="line">  [12, 6, 8, 9],</span><br><span class="line">  [16, 7,10,11]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotate</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify matrix in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(matrix)</span><br><span class="line">        matrix.reverse()</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(r, n):</span><br><span class="line">                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]</span><br></pre></td></tr></table></figure>
<p>高频：需要懂得顺时针转就是上下翻转以后对角线翻转，逆时针转就是左右翻转以后对角线翻转。懂list(zip(*list))的话就是一行代码</p>
<h3 id="54-Spiral-Matrix-Medium"><a href="#54-Spiral-Matrix-Medium" class="headerlink" title="54. Spiral Matrix (Medium)"></a><a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. Spiral Matrix (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line"> [ 1, 2, 3 ],</span><br><span class="line"> [ 4, 5, 6 ],</span><br><span class="line"> [ 7, 8, 9 ]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,6,9,8,7,4,5]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  [1, 2, 3, 4],</span><br><span class="line">  [5, 6, 7, 8],</span><br><span class="line">  [9,10,11,12]</span><br><span class="line">]</span><br><span class="line">Output: [1,2,3,4,8,12,11,10,9,5,6,7]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span><span class="params">(self, matrix: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        mode, circle, r, c = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        m, n = len(matrix), len(matrix[<span class="number">0</span>])</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m * n):</span><br><span class="line">            ans.append(matrix[r][c])</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> c == n - <span class="number">1</span> - circle:</span><br><span class="line">                    mode = <span class="number">1</span></span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> r == m - <span class="number">1</span> - circle:</span><br><span class="line">                    mode = <span class="number">2</span></span><br><span class="line">                    c -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span> c == circle:</span><br><span class="line">                    mode = <span class="number">3</span></span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    c -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> mode == <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">if</span> r == circle + <span class="number">1</span>:</span><br><span class="line">                    mode = <span class="number">0</span></span><br><span class="line">                    circle += <span class="number">1</span></span><br><span class="line">                    c += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：相比其他答案，更喜欢这个sprial matrix II用过的模板，不同之处是这里要先处理转向，用来应对[[1],[2]]这种输入</p>
<h3 id="68-Text-Justification-Hard"><a href="#68-Text-Justification-Hard" class="headerlink" title="68. Text Justification (Hard)"></a><a href="https://leetcode.com/problems/text-justification/" target="_blank" rel="noopener">68. Text Justification (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.</span><br><span class="line"></span><br><span class="line">You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.</span><br><span class="line"></span><br><span class="line">Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.</span><br><span class="line"></span><br><span class="line">For the last line of text, it should be left justified and no extra space is inserted between words.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">A word is defined as a character sequence consisting of non-space characters only.</span><br><span class="line">Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.</span><br><span class="line">The input array words contains at least one word.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">words = ["This", "is", "an", "example", "of", "text", "justification."]</span><br><span class="line">maxWidth = 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">   "This    is    an",</span><br><span class="line">   "example  of text",</span><br><span class="line">   "justification.  "</span><br><span class="line">]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">words = ["What","must","be","acknowledgment","shall","be"]</span><br><span class="line">maxWidth = 16</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  "What   must   be",</span><br><span class="line">  "acknowledgment  ",</span><br><span class="line">  "shall be        "</span><br><span class="line">]</span><br><span class="line">Explanation: Note that the last line is "shall be    " instead of "shall     be",</span><br><span class="line">             because the last line must be left-justified instead of fully-justified.</span><br><span class="line">             Note that the second line is also left-justified becase it contains only one word.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">words = ["Science","is","what","we","understand","well","enough","to","explain",</span><br><span class="line">         "to","a","computer.","Art","is","everything","else","we","do"]</span><br><span class="line">maxWidth = 20</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  "Science  is  what we",</span><br><span class="line">  "understand      well",</span><br><span class="line">  "enough to explain to",</span><br><span class="line">  "a  computer.  Art is",</span><br><span class="line">  "everything  else  we",</span><br><span class="line">  "do                  "</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fullJustify</span><span class="params">(self, words: List[str], maxWidth: int)</span> -&gt; List[str]:</span></span><br><span class="line">        ans, line, letter_count = [], [], <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> words:</span><br><span class="line">            <span class="keyword">if</span> letter_count + len(w) + len(line) &gt; maxWidth:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(maxWidth - letter_count):</span><br><span class="line">                    line[i % (len(line) - <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span>)] += <span class="string">' '</span></span><br><span class="line">                ans.append(<span class="string">''</span>.join(line))</span><br><span class="line">                line = []</span><br><span class="line">                letter_count = <span class="number">0</span></span><br><span class="line">            line += [w]</span><br><span class="line">            letter_count += len(w)        </span><br><span class="line">        ans.append(<span class="string">' '</span>.join(line).ljust(maxWidth))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：需要知道很巧妙的round robin填空格的方法：…line[i % (len(line) - 1 or 1)] += ‘ ‘…，str.ljust(width[, fillchar])默认填空格</p>
<h3 id="36-Valid-Sudoku-Medium"><a href="#36-Valid-Sudoku-Medium" class="headerlink" title="36. Valid Sudoku (Medium)"></a><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. Valid Sudoku (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:</span><br><span class="line"></span><br><span class="line">Each row must contain the digits 1-9 without repetition.</span><br><span class="line">Each column must contain the digits 1-9 without repetition.</span><br><span class="line">Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.</span><br><span class="line"></span><br><span class="line">A partially filled sudoku which is valid.</span><br><span class="line">The Sudoku board could be partially filled, where empty cells are filled with the character '.'.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  ["5","3",".",".","7",".",".",".","."],</span><br><span class="line">  ["6",".",".","1","9","5",".",".","."],</span><br><span class="line">  [".","9","8",".",".",".",".","6","."],</span><br><span class="line">  ["8",".",".",".","6",".",".",".","3"],</span><br><span class="line">  ["4",".",".","8",".","3",".",".","1"],</span><br><span class="line">  ["7",".",".",".","2",".",".",".","6"],</span><br><span class="line">  [".","6",".",".",".",".","2","8","."],</span><br><span class="line">  [".",".",".","4","1","9",".",".","5"],</span><br><span class="line">  [".",".",".",".","8",".",".","7","9"]</span><br><span class="line">]</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  ["8","3",".",".","7",".",".",".","."],</span><br><span class="line">  ["6",".",".","1","9","5",".",".","."],</span><br><span class="line">  [".","9","8",".",".",".",".","6","."],</span><br><span class="line">  ["8",".",".",".","6",".",".",".","3"],</span><br><span class="line">  ["4",".",".","8",".","3",".",".","1"],</span><br><span class="line">  ["7",".",".",".","2",".",".",".","6"],</span><br><span class="line">  [".","6",".",".",".",".","2","8","."],</span><br><span class="line">  [".",".",".","4","1","9",".",".","5"],</span><br><span class="line">  [".",".",".",".","8",".",".","7","9"]</span><br><span class="line">]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: Same as Example 1, except with the 5 in the top left corner being</span><br><span class="line">    modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">A Sudoku board (partially filled) could be valid but is not necessarily solvable.</span><br><span class="line">Only the filled cells need to be validated according to the mentioned rules.</span><br><span class="line">The given board contain only digits 1-9 and the character '.'.</span><br><span class="line">The given board size is always 9x9.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidSudoku</span><span class="params">(self, board: List[List[str]])</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">row</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> board:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> valid(r):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">col</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> zip(*board):</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> valid(c):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>]:</span><br><span class="line">                    flat = [board[r][c] <span class="keyword">for</span> r <span class="keyword">in</span> range(i, i + <span class="number">3</span>) <span class="keyword">for</span> c <span class="keyword">in</span> range(j, j + <span class="number">3</span>)]</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> valid(flat):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">valid</span><span class="params">(arr)</span>:</span></span><br><span class="line">            t = [i <span class="keyword">for</span> i <span class="keyword">in</span> arr <span class="keyword">if</span> i != <span class="string">"."</span>]</span><br><span class="line">            <span class="keyword">return</span> len(t) == len(set(t))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> row() <span class="keyword">and</span> col() <span class="keyword">and</span> sub()</span><br></pre></td></tr></table></figure>
<p>高频：…for…zip(*board)… t = [i for…if i…]… len(t) == len(set(t))…</p>
<h3 id="38-Count-and-Say-Easy"><a href="#38-Count-and-Say-Easy" class="headerlink" title="38. Count and Say (Easy)"></a><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">38. Count and Say (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">The count-and-say sequence is the sequence of integers with the first five terms as following:</span><br><span class="line"></span><br><span class="line">1.     1</span><br><span class="line">2.     11</span><br><span class="line">3.     21</span><br><span class="line">4.     1211</span><br><span class="line">5.     111221</span><br><span class="line">1 is read off as "one 1" or 11.</span><br><span class="line">11 is read off as "two 1s" or 21.</span><br><span class="line">21 is read off as "one 2, then one 1" or 1211.</span><br><span class="line"></span><br><span class="line">Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.</span><br><span class="line">Note: Each term of the sequence of integers will be represented as a string.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1</span><br><span class="line">Output: "1"</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 4</span><br><span class="line">Output: "1211"</span><br></pre></td></tr></table></figure>
<p>用itertools.groupby():<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        ans = <span class="string">"1"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            t = <span class="string">""</span></span><br><span class="line">            <span class="keyword">for</span> d, g <span class="keyword">in</span> itertools.groupby(ans):</span><br><span class="line">                cnt = len(list(g))</span><br><span class="line">                t += str(cnt) + str(d)</span><br><span class="line">            ans = t</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>不用groupby:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countAndSay</span><span class="params">(self, n: int)</span> -&gt; str:</span></span><br><span class="line">        ans = <span class="string">"1"</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            res = <span class="string">""</span></span><br><span class="line">            t = ans + <span class="string">"#"</span></span><br><span class="line">            cnt = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(t) - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> t[i] == t[i + <span class="number">1</span>]:</span><br><span class="line">                    cnt += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res += str(cnt) + t[i]</span><br><span class="line">                    cnt = <span class="number">1</span></span><br><span class="line">            ans = res</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>高频：题目描述不是很清楚，用groupby：…for d, g in itertools.groupby():…。不用groupby：…res = “”; t = ans + “#”…</p>
<h3 id="14-Longest-Common-Prefix-Easy"><a href="#14-Longest-Common-Prefix-Easy" class="headerlink" title="14. Longest Common Prefix (Easy)"></a><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. Longest Common Prefix (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Write a function to find the longest common prefix string amongst an array of strings.</span><br><span class="line"></span><br><span class="line">If there is no common prefix, return an empty string "".</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: ["flower","flow","flight"]</span><br><span class="line">Output: "fl"</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: ["dog","racecar","car"]</span><br><span class="line">Output: ""</span><br><span class="line">Explanation: There is no common prefix among the input strings.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All given inputs are in lowercase letters a-z.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestCommonPrefix</span><span class="params">(self, strs: List[str])</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> strs:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">        ans = strs[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(strs)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> ans:</span><br><span class="line">                <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                j = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> j &lt; len(ans) <span class="keyword">and</span> j &lt; len(strs[i]) <span class="keyword">and</span> ans[j] == strs[i][j]:</span><br><span class="line">                    j += <span class="number">1</span></span><br><span class="line">                ans = ans[:j]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：<br>面经：Quora。删掉了高频的总结，换成我自己想出来的解法。</p>
<h3 id="119-Pascal’s-Triangle-II-Easy"><a href="#119-Pascal’s-Triangle-II-Easy" class="headerlink" title="119. Pascal’s Triangle II (Easy)"></a><a href="https://leetcode.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">119. Pascal’s Triangle II (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.</span><br><span class="line">Note that the row index starts from 0.</span><br><span class="line">In Pascal's triangle, each number is the sum of the two numbers directly above it.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">Input: 3</span><br><span class="line">Output: [1,3,3,1]</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Could you optimize your algorithm to use only O(k) extra space?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRow</span><span class="params">(self, rowIndex: int)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(rowIndex):</span><br><span class="line">            ans = [x + y <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(ans + [<span class="number">0</span>], [<span class="number">0</span>] + ans)]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：很巧妙的…[x + y for x, y in zip(ans + [0], [0] + ans)]…</p>
<h3 id="6-ZigZag-Conversion-Medium"><a href="#6-ZigZag-Conversion-Medium" class="headerlink" title="6. ZigZag Conversion (Medium)"></a><a href="https://leetcode.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. ZigZag Conversion (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)</span><br><span class="line"></span><br><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br><span class="line">And then read line by line: "PAHNAPLSIIGYIR"</span><br><span class="line"></span><br><span class="line">Write the code that will take a string and make this conversion given a number of rows:</span><br><span class="line"></span><br><span class="line">string convert(string s, int numRows);</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s = "PAYPALISHIRING", numRows = 3</span><br><span class="line">Output: "PAHNAPLSIIGYIR"</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s = "PAYPALISHIRING", numRows = 4</span><br><span class="line">Output: "PINALSIGYAHRPI"</span><br><span class="line">Explanation:</span><br><span class="line"></span><br><span class="line">P     I    N</span><br><span class="line">A   L S  I G</span><br><span class="line">Y A   H R</span><br><span class="line">P     I</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, s: str, numRows: int)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">if</span> numRows == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        res = [<span class="string">''</span>] * numRows</span><br><span class="line">        r, move = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> s:</span><br><span class="line">            res[r] += l</span><br><span class="line">            r += move</span><br><span class="line">            <span class="keyword">if</span> r == numRows - <span class="number">1</span>:</span><br><span class="line">                move = <span class="number">-1</span></span><br><span class="line">            <span class="keyword">elif</span> r == <span class="number">0</span>:</span><br><span class="line">                move = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span>.join(res)</span><br></pre></td></tr></table></figure>
<p>高频：想太多反而写不出来，直接粗暴拼反而能拼出来，注意numRows为1时单独处理</p>
<h3 id="8-String-to-Integer-atoi-Medium"><a href="#8-String-to-Integer-atoi-Medium" class="headerlink" title="8. String to Integer (atoi) (Medium)"></a><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. String to Integer (atoi) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Implement atoi which converts a string to an integer.</span><br><span class="line"></span><br><span class="line">The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.</span><br><span class="line"></span><br><span class="line">The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.</span><br><span class="line"></span><br><span class="line">If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.</span><br><span class="line"></span><br><span class="line">If no valid conversion could be performed, a zero value is returned.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Only the space character ' ' is considered as whitespace character.</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "42"</span><br><span class="line">Output: 42</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "   -42"</span><br><span class="line">Output: -42</span><br><span class="line">Explanation: The first non-whitespace character is '-', which is the minus sign.</span><br><span class="line">             Then take as many numerical digits as possible, which gets 42.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: "4193 with words"</span><br><span class="line">Output: 4193</span><br><span class="line">Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: "words and 987"</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: The first non-whitespace character is 'w', which is not a numerical</span><br><span class="line">             digit or a +/- sign. Therefore no valid conversion could be performed.</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: "-91283472332"</span><br><span class="line">Output: -2147483648</span><br><span class="line">Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.</span><br><span class="line">             Thefore INT_MIN (−231) is returned.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myAtoi</span><span class="params">(self, str: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(str)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        s = s.strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        valid = [str(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        signs = <span class="string">'+-'</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> valid <span class="keyword">and</span> s[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> signs:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">'-'</span>:</span><br><span class="line">            sign = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] <span class="keyword">in</span> signs:</span><br><span class="line">            s = s[<span class="number">1</span>:]</span><br><span class="line">        ans = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> l <span class="keyword">in</span> valid:</span><br><span class="line">                ans += l</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="number">-1</span> <span class="keyword">and</span> -int(ans) &lt; -pow(<span class="number">2</span>, <span class="number">31</span>):</span><br><span class="line">                    <span class="keyword">return</span> -pow(<span class="number">2</span>, <span class="number">31</span>)</span><br><span class="line">                <span class="keyword">if</span> sign == <span class="number">1</span> <span class="keyword">and</span> int(ans) &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> sign * int(ans) <span class="keyword">if</span> ans <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> sign * int(ans) <span class="keyword">if</span> ans <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>高频：从例子之多就能看出来要考虑的case非常多。比的是细致</p>
<h3 id="57-Insert-Interval-Hard"><a href="#57-Insert-Interval-Hard" class="headerlink" title="57. Insert Interval (Hard)"></a><a href="https://leetcode.com/problems/insert-interval/description/" target="_blank" rel="noopener">57. Insert Interval (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</span><br><span class="line"></span><br><span class="line">You may assume that the intervals were initially sorted according to their start times.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: intervals = [[1,3],[6,9]], newInterval = [2,5]</span><br><span class="line">Output: [[1,5],[6,9]]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]</span><br><span class="line">Output: [[1,2],[3,10],[12,16]]</span><br><span class="line">Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</span><br><span class="line">NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals, newInterval)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> [newInterval]</span><br><span class="line">        ans = []</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(intervals):</span><br><span class="line">            <span class="keyword">if</span> intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]:</span><br><span class="line">                ans.append(intervals[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; len(intervals) <span class="keyword">and</span> intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]:</span><br><span class="line">            newInterval[<span class="number">0</span>] = min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>])</span><br><span class="line">            newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        ans.append(newInterval)</span><br><span class="line">        <span class="keyword">while</span> i &lt; len(intervals):</span><br><span class="line">            ans.append(intervals[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：重点是知道先把，结束小于新开始的…if intervals[i][1] &lt; newInterval[0]:…加到ans里，然后过开始小于新结束的…if…and intervals[i][0] &lt;= newInterval[1]: …min…max…这个方法</p>
<h3 id="937-Reorder-Log-Files-Easy"><a href="#937-Reorder-Log-Files-Easy" class="headerlink" title="937. Reorder Log Files (Easy)"></a><a href="https://leetcode.com/problems/reorder-log-files/" target="_blank" rel="noopener">937. Reorder Log Files (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">You have an array of logs.  Each log is a space delimited string of words.</span><br><span class="line"></span><br><span class="line">For each log, the first word in each log is an alphanumeric identifier.  Then, either:</span><br><span class="line"></span><br><span class="line">Each word after the identifier will consist only of lowercase letters, or;</span><br><span class="line">Each word after the identifier will consist only of digits.</span><br><span class="line">We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.</span><br><span class="line"></span><br><span class="line">Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.</span><br><span class="line"></span><br><span class="line">Return the final order of the logs.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]</span><br><span class="line">Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">0 &lt;= logs.length &lt;= 100</span><br><span class="line">3 &lt;= logs[i].length &lt;= 100</span><br><span class="line">logs[i] is guaranteed to have an identifier, and a word after the identifier.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reorderLogFiles</span><span class="params">(self, logs: List[str])</span> -&gt; List[str]:</span></span><br><span class="line">        nums, letters = [], []</span><br><span class="line">        <span class="keyword">for</span> log <span class="keyword">in</span> logs:</span><br><span class="line">            words = log.split(<span class="string">' '</span>)</span><br><span class="line">            <span class="keyword">if</span> words[<span class="number">1</span>].isdigit():</span><br><span class="line">                nums.append(log)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                letters.append(log)</span><br><span class="line">        letters.sort(key = <span class="keyword">lambda</span> x: x.split(<span class="string">' '</span>)[<span class="number">0</span>])</span><br><span class="line">        letters.sort(key = <span class="keyword">lambda</span> x: x.split(<span class="string">' '</span>)[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">return</span> letters + nums</span><br></pre></td></tr></table></figure>
<p>面经：Amazon，用key function，sort是stable</p>
<h2 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List 链表"></a>Linked List 链表</h2><h3 id="21-Merge-Two-Sorted-Lists-Easy"><a href="#21-Merge-Two-Sorted-Lists-Easy" class="headerlink" title="21. Merge Two Sorted Lists (Easy)"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure>
<p>高频：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        head = dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">            <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">                head.next = l1</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head.next = l2</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            head = head.next</span><br><span class="line">        <span class="keyword">if</span> l1:</span><br><span class="line">            head.next = l1</span><br><span class="line">        <span class="keyword">if</span> l2:</span><br><span class="line">            head.next = l2</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure></p>
<p>总结：while…: if l1.val &lt; l2.val:…记得nm = nm.next<br>面经：Cruise。</p>
<h3 id="86-Partition-List-Medium"><a href="#86-Partition-List-Medium" class="headerlink" title="86. Partition List (Medium)"></a><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">86. Partition List (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span><br><span class="line"></span><br><span class="line">You should preserve the original relative order of the nodes in each of the two partitions.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>
<p>思路：慢快指针，慢指针在最后一个 &lt; x 的位置， 快指针在最后一个 &gt;= x 的位置，快指针碰到一个 &lt; x 的就和慢指针换<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        fakie = ListNode(<span class="number">-1</span>)</span><br><span class="line">        fakie.next = head</span><br><span class="line">        slow, fast = fakie, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> slow != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">while</span> slow != <span class="keyword">None</span> <span class="keyword">and</span> slow.next != <span class="keyword">None</span> <span class="keyword">and</span> slow.next.val &lt; x:</span><br><span class="line">                slow = slow.next</span><br><span class="line">            <span class="keyword">if</span> fast == <span class="keyword">None</span>:</span><br><span class="line">                fast = slow</span><br><span class="line">            <span class="keyword">while</span> fast != <span class="keyword">None</span> <span class="keyword">and</span> fast.next != <span class="keyword">None</span> <span class="keyword">and</span> fast.next.val &gt;= x:</span><br><span class="line">                fast = fast.next</span><br><span class="line">            <span class="keyword">if</span> fast.next == <span class="keyword">None</span> <span class="keyword">or</span> slow.next == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            savedFastNext = fast.next</span><br><span class="line">            fast.next = fast.next.next</span><br><span class="line">            savedSlowNext = slow.next</span><br><span class="line">            slow.next = savedFastNext</span><br><span class="line">            savedFastNext.next = savedSlowNext</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> fakie.next</span><br></pre></td></tr></table></figure></p>
<p>总结：链表的问题需要先放一个假头，注意 1-&gt;1 x = 0, 1-&gt;1 x = 2, 2-&gt;1 x = 2 这三种情况和题中的例子情况 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 才能写对。</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">      <span class="keyword">if</span> head <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">          <span class="keyword">return</span> head</span><br><span class="line">      fake = ListNode(<span class="number">-1</span>)</span><br><span class="line">      fake.next = head</span><br><span class="line">      l, rl, rr = fake, fake, fake</span><br><span class="line">      <span class="keyword">while</span> head <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">          <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">              l.next = head</span><br><span class="line">              l = l.next</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              <span class="keyword">if</span> rl == fake:</span><br><span class="line">                  rl, rr = head, head</span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                  rr.next = head</span><br><span class="line">                  rr = rr.next</span><br><span class="line">          head = head.next</span><br><span class="line">      <span class="keyword">if</span> rl != fake:</span><br><span class="line">          l.next = rl</span><br><span class="line">          rr.next = <span class="keyword">None</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          l.next = <span class="keyword">None</span></span><br><span class="line">      <span class="keyword">return</span> fake.next</span><br></pre></td></tr></table></figure></p>
<p>总结：按一刷的经验放假头。二刷不同之处：1.前进 head；2.对于 &gt;= x 的情况，增加了 rl 和 rr 两个新边界。 head 结束后，如 rl 存在， 则连接 l 与 r，r 断尾，否则 l 断尾。需检测 1-&gt;1 x = 2, 2-&gt;2 x = 1 和题中给出的正常测试数据共三种情况</p>
<p>三刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head: ListNode, x: int)</span> -&gt; ListNode:</span></span><br><span class="line">        before = before_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        after = after_head = ListNode(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            <span class="keyword">if</span> head.val &lt; x:</span><br><span class="line">                before.next = head</span><br><span class="line">                before = before.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                after.next = head</span><br><span class="line">                after = after.next</span><br><span class="line">            head = head.next</span><br><span class="line">        after.next = <span class="keyword">None</span></span><br><span class="line">        before.next = after_head.next</span><br><span class="line">        <span class="keyword">return</span> before_head.next</span><br></pre></td></tr></table></figure></p>
<p>高频：更好理解的一个算法，before = before_head = ListNode(0)…before = before.next…return before_head.next…</p>
<h3 id="160-Intersection-of-Two-Linked-Lists-Easy"><a href="#160-Intersection-of-Two-Linked-Lists-Easy" class="headerlink" title="160. Intersection of Two Linked Lists (Easy)"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">160. Intersection of Two Linked Lists (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Write a program to find the node at which the intersection of two singly linked lists begins.</span><br><span class="line"></span><br><span class="line">For example, the following two linked lists:</span><br><span class="line"></span><br><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br><span class="line">begin to intersect at node c1.</span><br><span class="line"></span><br><span class="line">Notes:</span><br><span class="line">If the two linked lists have no intersection at all, return null.</span><br><span class="line">The linked lists must retain their original structure after the function returns.</span><br><span class="line">You may assume there are no cycles anywhere in the entire linked structure.</span><br><span class="line">Your code should preferably run in O(n) time and use only O(1) memory.</span><br></pre></td></tr></table></figure>
<p>思路：统计两条链走到头的长度，lenA 和 lenB, 然后让长的那条先走两者的差值，然后一起走，返回相遇的那点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        savedHeadA, savedHeadB = headA, headB</span><br><span class="line">        <span class="keyword">if</span> headA == <span class="keyword">None</span> <span class="keyword">or</span> headB == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        lenA, lenB = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> headA.next != <span class="keyword">None</span>:</span><br><span class="line">            headA = headA.next</span><br><span class="line">            lenA += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> headB.next != <span class="keyword">None</span>:</span><br><span class="line">            headB = headB.next</span><br><span class="line">            lenB += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">            diff = lenA - lenB</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> xrange(diff):</span><br><span class="line">                savedHeadA = savedHeadA.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            diff = lenB - lenA</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> xrange(diff):</span><br><span class="line">                savedHeadB = savedHeadB.next</span><br><span class="line">        <span class="keyword">while</span> savedHeadA != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> savedHeadA == savedHeadB:</span><br><span class="line">                <span class="keyword">return</span> savedHeadA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                savedHeadA = savedHeadA.next</span><br><span class="line">                savedHeadB = savedHeadB.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>总结：1.注意空输入（不能假设 headA 或 B 有 next）2.注意 headA headB 是一个节点 i.e. 合体的情况</p>
<h3 id="141-Linked-List-Cycle-Easy"><a href="#141-Linked-List-Cycle-Easy" class="headerlink" title="141. Linked List Cycle (Easy)"></a><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">141. Linked List Cycle (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given a linked list, determine if it has a cycle in it.</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Can you solve it without using extra space?</span><br></pre></td></tr></table></figure>
<p>思路：记得应该是慢的 +1 快的 +2 如果有 loop 会重逢。。。可能不那么值得做，热身吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        slow, fast = head, head.next.next</span><br><span class="line">        <span class="keyword">while</span> fast != <span class="keyword">None</span> <span class="keyword">and</span> fast.next != <span class="keyword">None</span> <span class="keyword">and</span> fast.next.next != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：有点意思，适合热身，代码写好后要测的情况比较多， 1 -&gt; 2 无 loop，1 -&gt; 2 -&gt; 3 -&gt; 4 loop 回 2 这些情况都要测一下。防止 next 和 next.next 不存在的情况</p>
<p>二刷：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        slow, fast = head, head.next.next</span><br><span class="line">        <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：一次写对确实不易，要考虑多种情况。</p>
<h3 id="142-Linked-List-Cycle-II-Medium"><a href="#142-Linked-List-Cycle-II-Medium" class="headerlink" title="142. Linked List Cycle II (Medium)"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">142. Linked List Cycle II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</span><br><span class="line"></span><br><span class="line">Note: Do not modify the linked list.</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Can you solve it without using extra space?</span><br></pre></td></tr></table></figure>
<p>思路：记得好像是找到有 loop 以后走多久能找到 cycle 的起点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast.next != <span class="keyword">None</span> <span class="keyword">and</span> fast.next.next != <span class="keyword">None</span>:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next            </span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">while</span> head != slow:</span><br><span class="line">                    head = head.next</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">```        </span><br><span class="line">总结：slow fast 同时在 head，先走再判断。不然容易出错。有数学关系，面试当场不一定能推导出来。就算推导出来也要注意前面的 slow，fast写法。</span><br><span class="line">    a            b</span><br><span class="line">A ------ B --------+</span><br><span class="line">         |         |</span><br><span class="line">       c |         |</span><br><span class="line">         +-------- C</span><br><span class="line"></span><br><span class="line">* A: 起始点</span><br><span class="line">* B: Cycle Begins</span><br><span class="line">* C: <span class="number">1</span>st 快慢指针相遇点</span><br><span class="line"></span><br><span class="line">* A-&gt;B: a</span><br><span class="line">* B-&gt;C: b</span><br><span class="line">* C-&gt;B: c</span><br><span class="line">* 环的长度 (b+c) 为 R</span><br><span class="line"></span><br><span class="line">第一次相遇时，慢指针所走步数为 a + b 快指针走的步数为 *a + b + nR*</span><br><span class="line">我们知道快指针是慢指针速度的<span class="number">2</span>倍，因此 <span class="number">2</span>(a + b) = a + b + nR 那么 a + b = nR</span><br><span class="line">同时 b + c = R 所以 a = (n - <span class="number">1</span>)R + c;</span><br><span class="line">也就是说，从A点和C点同时出发，以相同的速度前进，相遇的位置将是B。</span><br><span class="line"></span><br><span class="line">二刷：</span><br><span class="line">```python</span><br><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">while</span> head != slow:</span><br><span class="line">                    head = head.next</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>总结：比较重要的是 slow 和 fast 都要从 head 开始，循环中先向前走， 否则有些测试数据会死循环</p>
<h3 id="24-Swap-Nodes-in-Pairs-Medium"><a href="#24-Swap-Nodes-in-Pairs-Medium" class="headerlink" title="24. Swap Nodes in Pairs (Medium)"></a><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. Swap Nodes in Pairs (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given a linked list, swap every two adjacent nodes and return its head.</span><br><span class="line"></span><br><span class="line">You may not modify the values in the list's nodes, only nodes itself may be changed.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">swapPairs</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        dummy = pre = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        <span class="keyword">while</span> pre.next <span class="keyword">and</span> pre.next.next:</span><br><span class="line">            curr = pre.next</span><br><span class="line">            next = pre.next.next</span><br><span class="line">            curr.next = next.next</span><br><span class="line">            next.next = curr</span><br><span class="line">            pre.next = next</span><br><span class="line">            pre = curr    </span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure></p>
<p>总结：需要先把如何交换的顺序画出来，定位curr在pre.next, 定位next在pre.next.next，将cur.next指向next.next(因为翻转以后cur是尾巴了)，将next.next指向cur（实现翻转），将pre.next指向next（翻转后新的头），将pre挪到curr（新的尾巴）</p>
<h3 id="2-Add-Two-Numbers-Medium"><a href="#2-Add-Two-Numbers-Medium" class="headerlink" title="2. Add Two Numbers (Medium)"></a><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. Add Two Numbers (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</span><br><span class="line"></span><br><span class="line">You may assume the two numbers do not contain any leading zero, except the number 0 itself.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1: ListNode, l2: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">return</span> self.n2l(self.l2n(l1) + self.l2n(l2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">l2n</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        num = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            num = str(root.val) + num</span><br><span class="line">            root = root.next</span><br><span class="line">        <span class="keyword">return</span> int(num)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">n2l</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        num = str(num)</span><br><span class="line">        head = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> num:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> head:</span><br><span class="line">                head = ListNode(int(d))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                old_head = head</span><br><span class="line">                head = ListNode(int(d))</span><br><span class="line">                head.next = old_head</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p>
<p>总结：写l2n和n2l两个函数</p>
<h3 id="83-Remove-Duplicates-from-Sorted-List-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List (Easy)"></a><a href="83. Remove Duplicates from Sorted List">83. Remove Duplicates from Sorted List (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted linked list, delete all duplicates such that each element appear only once.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;1-&gt;2</span><br><span class="line">Output: 1-&gt;2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;1-&gt;2-&gt;3-&gt;3</span><br><span class="line">Output: 1-&gt;2-&gt;3</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        temp = head</span><br><span class="line">        <span class="keyword">while</span> temp <span class="keyword">and</span> temp.next:</span><br><span class="line">            <span class="keyword">if</span> temp.val == temp.next.val:</span><br><span class="line">                temp.next = temp.next.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                temp = temp.next</span><br><span class="line">        <span class="keyword">return</span> head</span><br></pre></td></tr></table></figure></p>
<p>总结：…<strong>temp = head</strong>; while temp and temp.next: …temp.next = temp.next.next; else: temp = temp.next…</p>
<h3 id="82-Remove-Duplicates-from-Sorted-List-II-Medium"><a href="#82-Remove-Duplicates-from-Sorted-List-II-Medium" class="headerlink" title="82. Remove Duplicates from Sorted List II (Medium)"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. Remove Duplicates from Sorted List II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5</span><br><span class="line">Output: 1-&gt;2-&gt;5</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;1-&gt;1-&gt;2-&gt;3</span><br><span class="line">Output: 2-&gt;3</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteDuplicates</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        cur = dummy</span><br><span class="line">        <span class="keyword">while</span> cur:</span><br><span class="line">            has_dupe = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">and</span> cur.next.next <span class="keyword">and</span> cur.next.val == cur.next.next.val:</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">                has_dupe = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> has_dupe:</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<p>高频：…cur = dummy…has_dupe = False…cur.next = cur.next.next…</p>
<h3 id="61-Rotate-List-Medium"><a href="#61-Rotate-List-Medium" class="headerlink" title="61. Rotate List (Medium)"></a><a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="noopener">61. Rotate List (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given a linked list, rotate the list to the right by k places, where k is non-negative.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2</span><br><span class="line">Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4</span><br><span class="line">Output: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">Explanation:</span><br><span class="line">rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br><span class="line">rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL</span><br><span class="line">rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL</span><br><span class="line">rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rotateRight</span><span class="params">(self, head: ListNode, k: int)</span> -&gt; ListNode:</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">l2q</span><span class="params">(head)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> head:</span><br><span class="line">                q.append(head.val)</span><br><span class="line">                head = head.next</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">q2l</span><span class="params">(q)</span>:</span></span><br><span class="line">            dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">            cur = dummy</span><br><span class="line">            <span class="keyword">while</span> q:</span><br><span class="line">                v = q.popleft()</span><br><span class="line">                n = ListNode(v)</span><br><span class="line">                cur.next = n</span><br><span class="line">                cur = n</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line">        l2q(head)</span><br><span class="line">        q.rotate(k)</span><br><span class="line">        <span class="keyword">return</span> q2l(q)</span><br></pre></td></tr></table></figure>
<p>高频：正统的解法应该是统计链长n，k %= n, f走k步，s，f同时走到底，s.next 为新head，f.next接到head上，s.next = None</p>
<h3 id="92-Reverse-Linked-List-II-Medium"><a href="#92-Reverse-Linked-List-II-Medium" class="headerlink" title="92. Reverse Linked List II (Medium)"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse Linked List II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reverse a linked list from position m to n. Do it in one-pass.</span><br><span class="line"></span><br><span class="line">Note: 1 ≤ m ≤ n ≤ length of list.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, m: int, n: int)</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = ListNode(<span class="number">0</span>)</span><br><span class="line">        dummy.next = head</span><br><span class="line">        pre = dummy</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(m - <span class="number">1</span>):</span><br><span class="line">            pre = pre.next</span><br><span class="line">        cur = pre.next</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(n - m):</span><br><span class="line">            t = cur.next</span><br><span class="line">            cur.next = t.next</span><br><span class="line">            t.next = pre.next</span><br><span class="line">            pre.next = t</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure>
<p>高频：…t = <strong>cur</strong>.next; cur.next = t.next…</p>
<h3 id="146-LRU-Cache-Medium"><a href="#146-LRU-Cache-Medium" class="headerlink" title="146. LRU Cache (Medium)"></a><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</span><br><span class="line"></span><br><span class="line">get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.</span><br><span class="line">put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</span><br><span class="line"></span><br><span class="line">The cache is initialized with a positive capacity.</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Could you do both operations in O(1) time complexity?</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">LRUCache cache = new LRUCache( 2 /* capacity */ );</span><br><span class="line"></span><br><span class="line">cache.put(1, 1);</span><br><span class="line">cache.put(2, 2);</span><br><span class="line">cache.get(1);       // returns 1</span><br><span class="line">cache.put(3, 3);    // evicts key 2</span><br><span class="line">cache.get(2);       // returns -1 (not found)</span><br><span class="line">cache.put(4, 4);    // evicts key 1</span><br><span class="line">cache.get(1);       // returns -1 (not found)</span><br><span class="line">cache.get(3);       // returns 3</span><br><span class="line">cache.get(4);       // returns 4</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k, v)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.val = v</span><br><span class="line">        self.prev = <span class="keyword">None</span></span><br><span class="line">        self.next = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, capacity: int)</span>:</span></span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.mapping = &#123;&#125;</span><br><span class="line">        self.head, self.tail = Node(<span class="number">0</span>, <span class="number">0</span>), Node(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        self.head.next = self.tail</span><br><span class="line">        self.tail.prev = self.head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.mapping:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = self.mapping[key]</span><br><span class="line">        self._remove(n)</span><br><span class="line">        self._add(n)</span><br><span class="line">        <span class="keyword">return</span> n.val</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key: int, value: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.mapping:</span><br><span class="line">            self._remove(self.mapping[key])</span><br><span class="line">        n = Node(key, value)</span><br><span class="line">        self.mapping[key] = n</span><br><span class="line">        <span class="keyword">if</span> len(self.mapping) &gt; self.capacity:</span><br><span class="line">            t = self.head.next</span><br><span class="line">            <span class="keyword">del</span> self.mapping[t.key]</span><br><span class="line">            self._remove(t)</span><br><span class="line">        self._add(n)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_remove</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        node.next.prev = node.prev</span><br><span class="line">        node.prev.next = node.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_add</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        self.tail.prev.next = node</span><br><span class="line">        node.prev = self.tail.prev</span><br><span class="line">        node.next = self.tail</span><br><span class="line">        self.tail.prev = node</span><br></pre></td></tr></table></figure>
<p>高频：O(1)的get和put需要dict存key和双向链表的节点。或者OrderedDict这个数据结构。…<strong>&gt;</strong> self.capacity: t = self.head.next; del …self._remove(t)， 可以省一个pop函数。然后注意put的时候要先把旧的重复key对从双链表中删除。…put(…): if key in self.mapping: self._remove(self.mapping[key])…</p>
<h3 id="206-Reverse-Linked-List-Easy"><a href="#206-Reverse-Linked-List-Easy" class="headerlink" title="206. Reverse Linked List (Easy)"></a><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse Linked List (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Reverse a singly linked list.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">A linked list can be reversed either iteratively or recursively. Could you implement both?</span><br></pre></td></tr></table></figure>
<p>遍历：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        newHead = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> head:</span><br><span class="line">            t = head.next</span><br><span class="line">            head.next = newHead</span><br><span class="line">            newHead = head</span><br><span class="line">            head = t</span><br><span class="line">        <span class="keyword">return</span> newHead</span><br></pre></td></tr></table></figure></p>
<p>递归：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">revert</span><span class="params">(head, newHead)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> head == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> newHead</span><br><span class="line">            t = head.next</span><br><span class="line">            head.next = newHead</span><br><span class="line">            <span class="keyword">return</span> revert(t, head)</span><br><span class="line">        <span class="keyword">return</span> revert(head, <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure></p>
<p>高频：遍历的模板比较好记，递归的模板好理解但是难记…(head, newHead): if not head: return newHead; t = head.next; head.next = <strong>newHead</strong>…(t, head)<br>二刷：遍历：newHead = <strong>None</strong>…t = <strong>head.next</strong>…递归：…f(head, newHead):…return f(t, head)…</p>
<h3 id="234-Palindrome-Linked-List-Easy"><a href="#234-Palindrome-Linked-List-Easy" class="headerlink" title="234. Palindrome Linked List (Easy)"></a><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a singly linked list, determine if it is a palindrome.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br><span class="line">Follow up:</span><br><span class="line">Could you do it in O(n) time and O(1) space?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> head <span class="keyword">or</span> <span class="keyword">not</span> head.next:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        s = f = head</span><br><span class="line">        newHead = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> f <span class="keyword">and</span> f.next:</span><br><span class="line">            f = f.next.next</span><br><span class="line">            t = s.next</span><br><span class="line">            s.next = newHead</span><br><span class="line">            newHead = s</span><br><span class="line">            s = t</span><br><span class="line">        <span class="keyword">if</span> f:</span><br><span class="line">            s = s.next</span><br><span class="line">        <span class="keyword">while</span> s:</span><br><span class="line">            <span class="keyword">if</span> newHead.val != s.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                s = s.next</span><br><span class="line">                newHead = newHead.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>高频：利用上一题的翻转模板，注意当链表是奇数个时需要：…if f: s = s.next…跳过中间那个节点</p>
<h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h2><h3 id="20-Valid-Parentheses-Easy"><a href="#20-Valid-Parentheses-Easy" class="headerlink" title="20. Valid Parentheses (Easy)"></a><a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">20. Valid Parentheses (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Given a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.</span><br><span class="line"></span><br><span class="line">An input string is valid if:</span><br><span class="line"></span><br><span class="line">Open brackets must be closed by the same type of brackets.</span><br><span class="line">Open brackets must be closed in the correct order.</span><br><span class="line">Note that an empty string is also considered valid.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "()"</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "()[]&#123;&#125;"</span><br><span class="line">Output: true</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: "(]"</span><br><span class="line">Output: false</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: "([)]"</span><br><span class="line">Output: false</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: "&#123;[]&#125;"</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        l = <span class="string">'(&#123;['</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> l:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> stack:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                t = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> t == <span class="string">'('</span> <span class="keyword">and</span> c != <span class="string">')'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> t == <span class="string">'&#123;'</span> <span class="keyword">and</span> c != <span class="string">'&#125;'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> t == <span class="string">'['</span> <span class="keyword">and</span> c != <span class="string">']'</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> stack:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>高频：注意在出栈前检验栈是否为空，走完以后检查栈是否为空</p>
<h3 id="71-Simplify-Path-Medium"><a href="#71-Simplify-Path-Medium" class="headerlink" title="71. Simplify Path (Medium)"></a><a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="noopener">71. Simplify Path (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.</span><br><span class="line"></span><br><span class="line">In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix</span><br><span class="line"></span><br><span class="line">Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "/home/"</span><br><span class="line">Output: "/home"</span><br><span class="line">Explanation: Note that there is no trailing slash after the last directory name.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "/../"</span><br><span class="line">Output: "/"</span><br><span class="line">Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: "/home//foo/"</span><br><span class="line">Output: "/home/foo"</span><br><span class="line">Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: "/a/./b/../../c/"</span><br><span class="line">Output: "/c"</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: "/a/../../b/../c//.//"</span><br><span class="line">Output: "/c"</span><br><span class="line">Example 6:</span><br><span class="line"></span><br><span class="line">Input: "/a//b////c/d//././/.."</span><br><span class="line">Output: "/a/b/c"</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">simplifyPath</span><span class="params">(self, path: str)</span> -&gt; str:</span></span><br><span class="line">        t = path.split(<span class="string">'/'</span>)</span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> t:</span><br><span class="line">            <span class="keyword">if</span> p <span class="keyword">and</span> p != <span class="string">'.'</span>:</span><br><span class="line">                <span class="keyword">if</span> p == <span class="string">'..'</span>:</span><br><span class="line">                    <span class="keyword">if</span> s:</span><br><span class="line">                        s.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    s.append(p)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'/'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'/'</span> + <span class="string">'/'</span>.join(s)</span><br></pre></td></tr></table></figure>
<p>高频：注意split(‘/‘)是’/‘的会变成数组里一个空的元素</p>
<h3 id="150-Evaluate-Reverse-Polish-Notation-Medium"><a href="#150-Evaluate-Reverse-Polish-Notation-Medium" class="headerlink" title="150. Evaluate Reverse Polish Notation (Medium)"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. Evaluate Reverse Polish Notation (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Evaluate the value of an arithmetic expression in Reverse Polish Notation.</span><br><span class="line"></span><br><span class="line">Valid operators are +, -, *, /. Each operand may be an integer or another expression.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Division between two integers should truncate toward zero.</span><br><span class="line">The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: ["2", "1", "+", "3", "*"]</span><br><span class="line">Output: 9</span><br><span class="line">Explanation: ((2 + 1) * 3) = 9</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: ["4", "13", "5", "/", "+"]</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: (4 + (13 / 5)) = 6</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]</span><br><span class="line">Output: 22</span><br><span class="line">Explanation:</span><br><span class="line">  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / (12 * -11))) + 17) + 5</span><br><span class="line">= ((10 * (6 / -132)) + 17) + 5</span><br><span class="line">= ((10 * 0) + 17) + 5</span><br><span class="line">= (0 + 17) + 5</span><br><span class="line">= 17 + 5</span><br><span class="line">= 22</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">evalRPN</span><span class="params">(self, tokens: List[str])</span> -&gt; int:</span></span><br><span class="line">        operators = <span class="string">"+-*/"</span></span><br><span class="line">        s = []</span><br><span class="line">        <span class="keyword">for</span> op <span class="keyword">in</span> tokens:</span><br><span class="line">            <span class="keyword">if</span> op <span class="keyword">not</span> <span class="keyword">in</span> operators:</span><br><span class="line">                s.append(int(op))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                b = s.pop()</span><br><span class="line">                a = s.pop()</span><br><span class="line">                <span class="keyword">if</span> op == <span class="string">"+"</span>:</span><br><span class="line">                    res = a + b</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">"-"</span>:</span><br><span class="line">                    res = a - b</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">'*'</span>:</span><br><span class="line">                    res = a * b</span><br><span class="line">                <span class="keyword">elif</span> op == <span class="string">"/"</span>:</span><br><span class="line">                    <span class="keyword">if</span> a * b &lt; <span class="number">0</span> <span class="keyword">and</span> a % b != <span class="number">0</span>:</span><br><span class="line">                        res = a // b + <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        res = a // b</span><br><span class="line">                s.append(res)</span><br><span class="line">        <span class="keyword">return</span> s[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>高频：需要注意leetcode里-1//20为0，而python里为-1，-21//20python里为-2。需要单独处理一下</p>
<h3 id="155-Min-Stack-Easy"><a href="#155-Min-Stack-Easy" class="headerlink" title="155. Min Stack (Easy)"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">155. Min Stack (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</span><br><span class="line"></span><br><span class="line">push(x) -- Push element x onto stack.</span><br><span class="line">pop() -- Removes the element on top of the stack.</span><br><span class="line">top() -- Get the top element.</span><br><span class="line">getMin() -- Retrieve the minimum element in the stack.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; Returns -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 0.</span><br><span class="line">minStack.getMin();   --&gt; Returns -2.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.stack = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, x: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        curMin = self.getMin() <span class="keyword">if</span> self.stack <span class="keyword">else</span> sys.maxsize</span><br><span class="line">        <span class="keyword">if</span> x &lt; curMin:</span><br><span class="line">            curMin = x</span><br><span class="line">        self.stack.append((x, curMin))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.stack.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMin</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> self.stack:</span><br><span class="line">            <span class="keyword">return</span> self.stack[<span class="number">-1</span>][<span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：一个stack就用tuple，两个stack就相当于第二个stack来维持curMin</p>
<h3 id="224-Basic-Calculator-Hard"><a href="#224-Basic-Calculator-Hard" class="headerlink" title="224. Basic Calculator (Hard)"></a><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">224. Basic Calculator (Hard)</a></h3><p>Implement a basic calculator to evaluate a simple expression string.<br>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p>
<p>Example 1:<br>Input: “1 + 1”<br>Output: 2<br>Example 2:</p>
<p>Input: “ 2-1 + 2 “<br>Output: 3<br>Example 3:</p>
<p>Input: “(1+(4+5+2)-3)+(6+8)”<br>Output: 23<br>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        num, ans = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> c.isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + int(c)</span><br><span class="line">            <span class="keyword">elif</span> c <span class="keyword">in</span> <span class="string">"+-"</span>:</span><br><span class="line">                ans += sign * num</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span> <span class="keyword">if</span> c == <span class="string">"+"</span> <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">"("</span>:</span><br><span class="line">                stack.append(ans)</span><br><span class="line">                stack.append(sign)</span><br><span class="line">                ans = <span class="number">0</span></span><br><span class="line">                sign = <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">")"</span>:</span><br><span class="line">                ans += sign * num</span><br><span class="line">                ans *= stack.pop()</span><br><span class="line">                ans += stack.pop()</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> ans + sign * num</span><br></pre></td></tr></table></figure></p>
<p>面经：Cruise …num = 0…ans = 0; sign = 1…num = 0…</p>
<h3 id="227-Basic-Calculator-II-Medium"><a href="#227-Basic-Calculator-II-Medium" class="headerlink" title="227. Basic Calculator II (Medium)"></a><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. Basic Calculator II (Medium)</a></h3><p>Implement a basic calculator to evaluate a simple expression string.<br>The expression string contains only non-negative integers, +, -, * , / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>Example 1:<br>Input: “3+2*2”<br>Output: 7<br>Example 2:</p>
<p>Input: “ 3/2 “<br>Output: 1<br>Example 3:</p>
<p>Input: “ 3+5 / 2 “<br>Output: 5</p>
<p>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calculate</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> s:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        num = <span class="number">0</span></span><br><span class="line">        operator = <span class="string">"+"</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> s[i].isdigit():</span><br><span class="line">                num = num * <span class="number">10</span> + int(s[i])</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">not</span> s[i].isdigit() <span class="keyword">and</span> s[i] != <span class="string">" "</span>) <span class="keyword">or</span> i == len(s) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> operator == <span class="string">"+"</span>:</span><br><span class="line">                    stack.append(num)</span><br><span class="line">                <span class="keyword">elif</span> operator == <span class="string">"-"</span>:</span><br><span class="line">                    stack.append(-num)</span><br><span class="line">                <span class="keyword">elif</span> operator == <span class="string">"*"</span>:</span><br><span class="line">                    stack.append(stack.pop() * num)</span><br><span class="line">                <span class="keyword">elif</span> operator == <span class="string">"/"</span>:</span><br><span class="line">                    stack.append(int(stack.pop() / num))</span><br><span class="line">                num = <span class="number">0</span></span><br><span class="line">                operator = s[i]</span><br><span class="line">        <span class="keyword">return</span> sum(stack)</span><br></pre></td></tr></table></figure></p>
<p>面经：Cruise。符号或操作符均是在最后变化。因为要处理最后一个字符的问题，所以要么两个if，要么得在s后面跟一个“+”</p>
<h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2><h3 id="LinC-642-Moving-Average-from-Data-Stream-Easy"><a href="#LinC-642-Moving-Average-from-Data-Stream-Easy" class="headerlink" title="LinC 642. Moving Average from Data Stream (Easy)"></a><a href="https://www.lintcode.com/problem/moving-average-from-data-stream/description" target="_blank" rel="noopener">LinC 642. Moving Average from Data Stream (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">MovingAverage m = new MovingAverage(3);</span><br><span class="line">m.next(1) = 1 // return 1.00000</span><br><span class="line">m.next(10) = (1 + 10) / 2 // return 5.50000</span><br><span class="line">m.next(3) = (1 + 10 + 3) / 3 // return 4.66667</span><br><span class="line">m.next(5) = (10 + 3 + 5) / 3 // return 6.00000</span><br></pre></td></tr></table></figure>
<p>思路：建个 window size 的队列，返回队列的平均值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span>:</span></span><br><span class="line">    q = collections.deque()</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    maxLen = <span class="number">0</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: size: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size)</span>:</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.maxLen = size</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: val: An integer</span></span><br><span class="line"><span class="string">    @return:  </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        self.q.append(val)</span><br><span class="line">        self.sum += val</span><br><span class="line">        <span class="keyword">if</span> len(self.q) &gt; self.maxLen:</span><br><span class="line">            temp = self.q.popleft()</span><br><span class="line">            self.sum -= temp</span><br><span class="line">        avg = self.sum / len(self.q)</span><br><span class="line">        <span class="keyword">return</span> avg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MovingAverage(size)</span></span><br><span class="line"><span class="comment"># param = obj.next(val)</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意 class 变量要加 self，另外 sum 不要每次都 loop 一遍算， 直接放到 class 变量里，每次只增 and / or 减一次。</p>
<h2 id="Hash-哈希表"><a href="#Hash-哈希表" class="headerlink" title="Hash 哈希表"></a>Hash 哈希表</h2><h3 id="290-Word-Pattern-Easy"><a href="#290-Word-Pattern-Easy" class="headerlink" title="290. Word Pattern (Easy)"></a><a href="https://leetcode.com/problems/word-pattern/description/" target="_blank" rel="noopener">290. Word Pattern (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Given a pattern and a string str, find if str follows the same pattern.</span><br><span class="line"></span><br><span class="line">Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: pattern = "abba", str = "dog cat cat dog"</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:pattern = "abba", str = "dog cat cat fish"</span><br><span class="line">Output: false</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: pattern = "aaaa", str = "dog cat cat dog"</span><br><span class="line">Output: false</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: pattern = "abba", str = "dog dog dog dog"</span><br><span class="line">Output: false</span><br><span class="line">Notes:</span><br><span class="line">You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.</span><br></pre></td></tr></table></figure>
<p>思路：关键在于懂得建立 pattern 里每个字母和 str 里每个 word 的映射。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span><span class="params">(self, pattern, str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        words = str.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">if</span> len(words) != len(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mapping = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(pattern):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> mapping:</span><br><span class="line">                <span class="keyword">if</span> mapping[char] != words[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> words[i] <span class="keyword">in</span> mapping.values():</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                mapping[char] = words[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意需要用 enumerate， 因为要同时遍历 pattern 和 str. 很好的哈希表热身题。Word Pattern II 的 str 里没有空格了，不能直接 split，难度直接推到 Hard。目前刷题的水平先跳过吧 :(</p>
<h3 id="387-First-Unique-Character-in-a-String-Easy"><a href="#387-First-Unique-Character-in-a-String-Easy" class="headerlink" title="387. First Unique Character in a String (Easy)"></a><a href="https://leetcode.com/problems/first-unique-character-in-a-string/description/" target="_blank" rel="noopener">387. First Unique Character in a String (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"></span><br><span class="line">s = "leetcode"</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = "loveleetcode",</span><br><span class="line">return 2.</span><br><span class="line">Note: You may assume the string contain only lowercase letters.</span><br></pre></td></tr></table></figure>
<p>思路：过两遍，第一遍数出现多少次， 第二遍把第一个为 1 的 index 返回<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[char] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> index, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> dict[char] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：基本题，注意 dict entry 初始化为 1 的情况</p>
<h3 id="409-Longest-Palindrome-Easy"><a href="#409-Longest-Palindrome-Easy" class="headerlink" title="409. Longest Palindrome (Easy)"></a><a href="https://leetcode.com/problems/longest-palindrome/description/" target="_blank" rel="noopener">409. Longest Palindrome (Easy)</a></h3><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.<br>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>
<p>Note:<br>Assume the length of given string will not exceed 1,010.</p>
<p>Example:<br>Input:<br>“abccccdd”<br>Output:<br>7</p>
<p>Explanation:<br>One longest palindrome that can be built is “dccaccd”, whose length is 7.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        counter = Counter(s)</span><br><span class="line">        <span class="keyword">for</span> c, v <span class="keyword">in</span> counter.items():</span><br><span class="line">            <span class="keyword">if</span> v % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> ans % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                ans += v</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans += v - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。去掉了一刷二刷的hashmap和dp解法。就用简单好懂的解法吧</p>
<h3 id="380-Insert-Delete-GetRandom-O-1-Medium"><a href="#380-Insert-Delete-GetRandom-O-1-Medium" class="headerlink" title="380. Insert Delete GetRandom O(1) (Medium)"></a><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/" target="_blank" rel="noopener">380. Insert Delete GetRandom O(1) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Design a data structure that supports all following operations in average O(1) time.</span><br><span class="line"></span><br><span class="line">insert(val): Inserts an item val to the set if not already present.</span><br><span class="line">remove(val): Removes an item val from the set if present.</span><br><span class="line">getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">// Returns false as 2 does not exist in the set.</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">// Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// getRandom should return either 1 or 2 randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">// 2 was already in the set, so return false.</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// Since 2 is the only number in the set, getRandom always return 2.</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure>
<p>思路：看答案知道需要用 list 和 dictionary，因为要满足 O(1), 因为仅有 list 的 in 操作不能满足 O(1)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.list = []</span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.list.append(val)</span><br><span class="line">            self.dict[val] = len(self.list) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">            index, lastVal = self.dict[val], self.list[len(self.list) - <span class="number">1</span>]</span><br><span class="line">            self.list[index], self.dict[lastVal] = lastVal, index</span><br><span class="line">            self.list.pop()</span><br><span class="line">            self.dict.pop(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.list[random.randint(<span class="number">0</span>, len(self.list) - <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RandomizedSet()</span></span><br><span class="line"><span class="comment"># param_1 = obj.insert(val)</span></span><br><span class="line"><span class="comment"># param_2 = obj.remove(val)</span></span><br><span class="line"><span class="comment"># param_3 = obj.getRandom()</span></span><br></pre></td></tr></table></figure></p>
<p>总结：可能是用 python 的原因，搞明白问什么了一次过</p>
<h3 id="LinC-960-First-Unique-Number-in-a-Stream-II-Medium"><a href="#LinC-960-First-Unique-Number-in-a-Stream-II-Medium" class="headerlink" title="LinC 960. First Unique Number in a Stream II (Medium)"></a><a href="960. First Unique Number in a Stream II">LinC 960. First Unique Number in a Stream II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Description</span><br><span class="line">We need to implement a data structure named DataStream. There are two methods required to be implemented:</span><br><span class="line"></span><br><span class="line">void add(number) // add a new number</span><br><span class="line">int firstUnique() // return first unique number</span><br><span class="line">You can assume that there must be at least one unique number in the stream when calling the firstUnique.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">add(1)</span><br><span class="line">add(2)</span><br><span class="line">firstUnique() =&gt; 1</span><br><span class="line">add(1)</span><br><span class="line">firstUnique() =&gt; 2</span><br></pre></td></tr></table></figure>
<p>思路：维持一个 deque / queue，碰到相同的就 popleft 出去<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataStream</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.q = collections.deque()</span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param num: next number in stream</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> self.dict:</span><br><span class="line">            self.dict[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dict[num] = <span class="number">1</span></span><br><span class="line">            self.q.append(num)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @return: the first unique number in stream</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUnique</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">while</span> len(self.q) &gt; <span class="number">0</span> <span class="keyword">and</span> self.dict[self.q[<span class="number">0</span>]] &gt; <span class="number">1</span>:</span><br><span class="line">                self.q.popleft()</span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：1.popleft 要在 firstUnique 里面，不然有些 testcase 过不了；2.注意 popleft 的条件要用 while， 用 for 会出错</p>
<h3 id="49-Group-Anagrams-Medium"><a href="#49-Group-Anagrams-Medium" class="headerlink" title="49. Group Anagrams (Medium)"></a><a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">49. Group Anagrams (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given an array of strings, group anagrams together.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: ["eat", "tea", "tan", "ate", "nat", "bat"],</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  ["ate","eat","tea"],</span><br><span class="line">  ["nat","tan"],</span><br><span class="line">  ["bat"]</span><br><span class="line">]</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All inputs will be in lowercase.</span><br><span class="line">The order of your output does not matter.</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span><span class="params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span></span><br><span class="line">        d = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            tmps = <span class="string">""</span>.join(sorted(s))</span><br><span class="line">            d[tmps].append(s)</span><br><span class="line">        <span class="keyword">return</span> list(d.values())</span><br></pre></td></tr></table></figure></p>
<p>总结：sorted(s)返回一个char list，“”.join(list)将这个list拼回字符串。list(d.values())可返回defaultdict的值</p>
<h2 id="Heap-Priority-Queue"><a href="#Heap-Priority-Queue" class="headerlink" title="Heap (Priority Queue)"></a>Heap (Priority Queue)</h2><h3 id="264-Ugly-Number-II-Medium"><a href="#264-Ugly-Number-II-Medium" class="headerlink" title="264. Ugly Number II (Medium)"></a><a href="https://leetcode.com/problems/ugly-number-ii/description/" target="_blank" rel="noopener">264. Ugly Number II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Write a program to find the n-th ugly number.</span><br><span class="line"></span><br><span class="line">Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: n = 10</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</span><br><span class="line">Note:  </span><br><span class="line"></span><br><span class="line">1 is typically treated as an ugly number.</span><br><span class="line">n does not exceed 1690.</span><br></pre></td></tr></table></figure>
<p>思路：九章的 python 答案可以 work，但是实在是不好理解。写个好理解一点的版本。heapq 和 hashMap, 从 heapq 中取 n - 1 次（第一个数为 1），每取一次将原始 ugly numbers 2, 3, 5 过一遍<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        q = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        hashMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            hashMap[q[i]] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            ans = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                new_val = ans * primes[j]</span><br><span class="line">                <span class="keyword">if</span> new_val <span class="keyword">not</span> <span class="keyword">in</span> hashMap:</span><br><span class="line">                    heapq.heappush(q, new_val)</span><br><span class="line">                    hashMap[new_val] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：可以 AC，也可以理解，good enough<br>二刷：其实是道dp题，用set和heapq也能过，但是时间上没有优势</p>
<h3 id="973-K-Closest-Points-to-Origin-Medium"><a href="#973-K-Closest-Points-to-Origin-Medium" class="headerlink" title="973. K Closest Points to Origin (Medium)"></a><a href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. K Closest Points to Origin (Medium)</a></h3><p><a href="https://www.lintcode.com/problem/k-closest-points/description" target="_blank" rel="noopener">LinC 612. K Closest Points (Medium)</a><br>We have a list of points on the plane.  Find the K closest points to the origin (0, 0).<br>(Here, the distance between two points on a plane is the Euclidean distance.)<br>You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)</p>
<p>Example 1:<br>Input: points = [[1,3],[-2,2]], K = 1<br>Output: [[-2,2]]<br>Explanation:<br>The distance between (1, 3) and the origin is sqrt(10).<br>The distance between (-2, 2) and the origin is sqrt(8).<br>Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.<br>We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].</p>
<p>Example 2:<br>Input: points = [[3,3],[5,-1],[-2,4]], K = 2<br>Output: [[3,3],[-2,4]]<br>(The answer [[-2,4],[3,3]] would also be accepted.)</p>
<p>Note:<br>1 &lt;= K &lt;= points.length &lt;= 10000<br>-10000 &lt; points[i][0] &lt; 10000<br>-10000 &lt; points[i][1] &lt; 10000<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span><span class="params">(self, points: List[List[int]], K: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">        arr = [[p[<span class="number">0</span>] ** <span class="number">2</span> + p[<span class="number">1</span>] ** <span class="number">2</span>, p] <span class="keyword">for</span> p <span class="keyword">in</span> points]</span><br><span class="line">        arr.sort(key = <span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> [i[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> arr[:K]]</span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。删掉一刷的思路和总结。简化代码，非常欣慰</p>
<h3 id="LinC-545-Top-k-Largest-Numbers-II-Medium"><a href="#LinC-545-Top-k-Largest-Numbers-II-Medium" class="headerlink" title="LinC 545. Top k Largest Numbers II (Medium)"></a><a href="https://www.lintcode.com/problem/top-k-largest-numbers-ii/description" target="_blank" rel="noopener">LinC 545. Top k Largest Numbers II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Implement a data structure, provide two interfaces:</span><br><span class="line">add(number). Add a new number in the data structure.</span><br><span class="line">topk(). Return the top k largest numbers in this data structure. k is given when we create the data structure.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">s = new Solution(3);</span><br><span class="line">&gt;&gt; create a new data structure.</span><br><span class="line">s.add(3)</span><br><span class="line">s.add(10)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [10, 3]</span><br><span class="line">s.add(1000)</span><br><span class="line">s.add(-99)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [1000, 10, 3]</span><br><span class="line">s.add(4)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [1000, 10, 4]</span><br><span class="line">s.add(100)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [1000, 100, 10]</span><br></pre></td></tr></table></figure>
<p>思路：看着是非常直观的 min heap 问题。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: k: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.q = []</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: num: Number to be added</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heappush(self.q, num)</span><br><span class="line">        <span class="keyword">if</span> len(self.q) &gt; self.k:</span><br><span class="line">            heapq.heappop(self.q)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @return: Top k element</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> sorted(self.q, reverse = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：一句 sorted(self.q, reverse = True) 完爆。。。哎， python 的 buit-in function 返回一个 sorted new list…学习了。</p>
<h3 id="LinC-486-Merge-K-Sorted-Arrays-Medium"><a href="#LinC-486-Merge-K-Sorted-Arrays-Medium" class="headerlink" title="LinC 486. Merge K Sorted Arrays (Medium)"></a><a href="https://www.lintcode.com/problem/merge-k-sorted-arrays/description" target="_blank" rel="noopener">LinC 486. Merge K Sorted Arrays (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given k sorted integer arrays, merge them into one sorted array.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given 3 sorted arrays:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1, 3, 5, 7],</span><br><span class="line">  [2, 4, 6],</span><br><span class="line">  [0, 8, 9, 10, 11]</span><br><span class="line">]</span><br><span class="line">return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">Do it in O(N log k).</span><br><span class="line"></span><br><span class="line">N is the total number of integers.</span><br><span class="line">k is the number of arrays.</span><br></pre></td></tr></table></figure>
<p>思路：看答案，用 heap 屌爆了。加了链接到上面 heap 的部分<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param arrays: k sorted integer arrays</span></span><br><span class="line"><span class="string">    @return: a sorted array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergekSortedArrays</span><span class="params">(self, arrays)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        q = []</span><br><span class="line">        <span class="keyword">for</span> level, array <span class="keyword">in</span> enumerate(arrays):</span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            heapq.heappush(q, (array[<span class="number">0</span>], level, <span class="number">0</span>))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur, level, index = heapq.heappop(q)</span><br><span class="line">            ans.append(cur)</span><br><span class="line">            <span class="keyword">if</span> index + <span class="number">1</span> &lt; len(arrays[level]):</span><br><span class="line">                heapq.heappush(q, (arrays[level][index + <span class="number">1</span>], level, index + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：只能说 python 的 heapq 屌爆了</p>
<h3 id="23-Merge-k-Sorted-Lists-Hard"><a href="#23-Merge-k-Sorted-Lists-Hard" class="headerlink" title="23. Merge k Sorted Lists (Hard)"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">23. Merge k Sorted Lists (Hard)</a></h3><p>三种方法，都需要练习. 方法一:使用 PriorityQueue 方法二:类似归并排序的分治算法 方法三:自底向上的两两归并算法. 时间复杂度均为 O(NlogK) Strong Hire: 能够用至少2种方法进行实现，代码无大 BUG<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure></p>
<p>PriorityQueue:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        dummy = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">        h = []</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(lists):</span><br><span class="line">            <span class="keyword">if</span> n:</span><br><span class="line">                heapq.heappush(h, (n.val, i, n))</span><br><span class="line">        <span class="keyword">while</span> h:</span><br><span class="line">            v, i, n = heapq.heappop(h)</span><br><span class="line">            cur.next = n</span><br><span class="line">            cur = cur.next</span><br><span class="line">            <span class="keyword">if</span> n.next:</span><br><span class="line">                heapq.heappush(h, (n.next.val, i, n.next))</span><br><span class="line">        <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure></p>
<p>分治：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeKLists</span><span class="params">(self, lists: List[ListNode])</span> -&gt; ListNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> lists:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        n = len(lists)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>]</span><br><span class="line">        mid = n // <span class="number">2</span></span><br><span class="line">        l = self.mergeKLists(lists[:mid])</span><br><span class="line">        r = self.mergeKLists(lists[mid:])</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            dummy = cur = ListNode(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> l <span class="keyword">and</span> r:</span><br><span class="line">                <span class="keyword">if</span> l.val &lt; r.val:</span><br><span class="line">                    cur.next = l</span><br><span class="line">                    l = l.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.next = r</span><br><span class="line">                    r = r.next</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = l <span class="keyword">if</span> <span class="keyword">not</span> r <span class="keyword">else</span> r</span><br><span class="line">            <span class="keyword">return</span> dummy.next</span><br><span class="line">        <span class="keyword">return</span> merge(l, r)</span><br></pre></td></tr></table></figure></p>
<p>高频：如果不能加<strong>lt</strong>()，就用(n.val, i, n)tuple防v.val重复的。</p>
<h3 id="295-Find-Median-from-Data-Stream-Hard"><a href="#295-Find-Median-from-Data-Stream-Hard" class="headerlink" title="295. Find Median from Data Stream (Hard)"></a><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. Find Median from Data Stream (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</span><br><span class="line"></span><br><span class="line">For example,</span><br><span class="line">[2,3,4], the median is 3</span><br><span class="line"></span><br><span class="line">[2,3], the median is (2 + 3) / 2 = 2.5</span><br><span class="line"></span><br><span class="line">Design a data structure that supports the following two operations:</span><br><span class="line"></span><br><span class="line">void addNum(int num) - Add a integer number from the data stream to the data structure.</span><br><span class="line">double findMedian() - Return the median of all elements so far.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">addNum(1)</span><br><span class="line">addNum(2)</span><br><span class="line">findMedian() -&gt; 1.5</span><br><span class="line">addNum(3)</span><br><span class="line">findMedian() -&gt; 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">If all integer numbers from the stream are between 0 and 100, how would you optimize it?</span><br><span class="line">If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MedianFinder</span>:</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.upper = []</span><br><span class="line">        self.lower = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.upper) == len(self.lower):</span><br><span class="line">            heapq.heappush(self.upper, -heapq.heappushpop(self.lower, -num))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            heapq.heappush(self.lower, -heapq.heappushpop(self.upper, num))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.upper) == len(self.lower):</span><br><span class="line">            <span class="keyword">return</span> self.upper[<span class="number">0</span>] * <span class="number">0.5</span> - self.lower[<span class="number">0</span>] * <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> float(self.upper[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>面经：Amazon，maxheap + minheap，lower要用负数来模拟maxheap, 数据范围小可以用hashmap</p>
<h3 id="743-Network-Delay-Time-Medium"><a href="#743-Network-Delay-Time-Medium" class="headerlink" title="743. Network Delay Time (Medium)"></a><a href="https://leetcode.com/problems/network-delay-time/" target="_blank" rel="noopener">743. Network Delay Time (Medium)</a></h3><p>There are N network nodes, labelled 1 to N.<br>Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.<br>Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.<br><img src="https://i.imgur.com/e6P0mDW.png" alt="network example"><br>Example 1:<br>Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2<br>Output: 2<br>Note:<br>N will be in the range [1, 100].<br>K will be in the range [1, N].<br>The length of times will be in the range [1, 6000].<br>All edges times[i] = (u, v, w) will have 1 &lt;= u, v &lt;= N and 0 &lt;= w &lt;= 100.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">networkDelayTime</span><span class="params">(self, times: List[List[int]], N: int, K: int)</span> -&gt; int:</span></span><br><span class="line">        graph = collections.defaultdict(dict)</span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> times:</span><br><span class="line">            graph[u - <span class="number">1</span>][v - <span class="number">1</span>] = w</span><br><span class="line">        distances = [sys.maxsize] * N</span><br><span class="line">        distances[K - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        pq = [(<span class="number">0</span>, K - <span class="number">1</span>)]</span><br><span class="line">        seen = set()</span><br><span class="line">        <span class="keyword">while</span> pq:</span><br><span class="line">            dist, v1 = heapq.heappop(pq)</span><br><span class="line">            <span class="keyword">if</span> v1 <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                seen.add(v1)</span><br><span class="line">                <span class="keyword">for</span> v2 <span class="keyword">in</span> graph[v1]:</span><br><span class="line">                    <span class="keyword">if</span> v2 <span class="keyword">not</span> <span class="keyword">in</span> seen:</span><br><span class="line">                        prev = distances[v2]</span><br><span class="line">                        cur = dist + graph[v1][v2]</span><br><span class="line">                        <span class="keyword">if</span> cur &lt; prev:</span><br><span class="line">                            distances[v2] = cur</span><br><span class="line">                            heapq.heappush(pq, (cur, v2))</span><br><span class="line">        ans = max(distances)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> ans == sys.maxsize <span class="keyword">else</span> ans</span><br></pre></td></tr></table></figure></p>
<p>面经：练习某家小公司的OA，Dijkstra Graph 最短路径，Dijkstra有很多变种问题，不同写法。</p>
<h3 id="787-Cheapest-Flights-Within-K-Stops-Medium"><a href="#787-Cheapest-Flights-Within-K-Stops-Medium" class="headerlink" title="787. Cheapest Flights Within K Stops (Medium)"></a><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/" target="_blank" rel="noopener">787. Cheapest Flights Within K Stops (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.</span><br><span class="line"></span><br><span class="line">Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 1</span><br><span class="line">Output: 200</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line"></span><br><span class="line">The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.</span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]</span><br><span class="line">src = 0, dst = 2, k = 0</span><br><span class="line">Output: 500</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line"></span><br><span class="line">The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.</span><br><span class="line">The size of flights will be in range [0, n * (n - 1) / 2].</span><br><span class="line">The format of each flight will be (src, dst, price).</span><br><span class="line">The price of each flight will be in the range [1, 10000].</span><br><span class="line">k is in the range of [0, n - 1].</span><br><span class="line">There will not be any duplicated flights or self cycles.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCheapestPrice</span><span class="params">(self, n: int, flights: List[List[int]], src: int, dst: int, K: int)</span> -&gt; int:</span></span><br><span class="line">        graph = collections.defaultdict(dict)</span><br><span class="line">        <span class="keyword">for</span> u, v, w <span class="keyword">in</span> flights:</span><br><span class="line">            graph[u][v] = w</span><br><span class="line">        costs = [sys.maxsize] * n</span><br><span class="line">        costs[src] = <span class="number">0</span></span><br><span class="line">        pq = [(<span class="number">0</span>,  src, <span class="number">0</span>)]</span><br><span class="line">        <span class="keyword">while</span> pq:</span><br><span class="line">            <span class="keyword">import</span> heapq</span><br><span class="line">            cost, v1, stop = heapq.heappop(pq)</span><br><span class="line">            <span class="keyword">if</span> stop - <span class="number">1</span> &lt;= K:</span><br><span class="line">                <span class="keyword">if</span> v1 == dst:</span><br><span class="line">                    <span class="keyword">return</span> cost</span><br><span class="line">                <span class="keyword">for</span> v2 <span class="keyword">in</span> graph[v1]:</span><br><span class="line">                    pre = costs[v2]</span><br><span class="line">                    cur = cost + graph[v1][v2]</span><br><span class="line">                    <span class="keyword">if</span> cur &lt; pre:</span><br><span class="line">                        heapq.heappush(pq, (cur, v2, stop + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>面经：与上题不同之处是这里问的不是全局最优，而是符合条件的最优，同一个点可能需要重复访问才能找到符合条件的最优，因此无需seen这个set</p>
<h3 id="855-Exam-Room-Medium"><a href="#855-Exam-Room-Medium" class="headerlink" title="855. Exam Room (Medium)"></a><a href="https://leetcode.com/problems/exam-room/" target="_blank" rel="noopener">855. Exam Room (Medium)</a></h3><p>In an exam room, there are N seats in a single row, numbered 0, 1, 2, …, N-1.<br>When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)<br>Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.</p>
<p>Example 1:<br>Input: [“ExamRoom”,”seat”,”seat”,”seat”,”seat”,”leave”,”seat”], [[10],[],[],[],[],[4],[]]<br>Output: [null,0,9,4,2,null,5]<br>Explanation:<br>ExamRoom(10) -&gt; null<br>seat() -&gt; 0, no one is in the room, then the student sits at seat number 0.<br>seat() -&gt; 9, the student sits at the last seat number 9.<br>seat() -&gt; 4, the student sits at the last seat number 4.<br>seat() -&gt; 2, the student sits at the last seat number 2.<br>leave(4) -&gt; null<br>seat() -&gt; 5, the student sits at the last seat number 5.<br>​​​​​​​<br>Note:<br>1 &lt;= N &lt;= 10^9<br>ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases.<br>Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExamRoom</span>:</span></span><br><span class="line">    <span class="keyword">import</span> heapq</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, N: int)</span>:</span></span><br><span class="line">        self.N = N</span><br><span class="line">        self.L = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">seat</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.L:</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            d, res = self.L[<span class="number">0</span>], <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> x, y <span class="keyword">in</span> zip(self.L, self.L[<span class="number">1</span>:]):</span><br><span class="line">                <span class="keyword">if</span> (y - x) // <span class="number">2</span> &gt; d:</span><br><span class="line">                    d = (y - x) // <span class="number">2</span></span><br><span class="line">                    res = x + (y - x) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> self.N - <span class="number">1</span> - self.L[<span class="number">-1</span>] &gt; d:</span><br><span class="line">                res = self.N - <span class="number">1</span></span><br><span class="line">        bisect.insort(self.L, res)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">leave</span><span class="params">(self, p: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.L.remove(p)</span><br></pre></td></tr></table></figure></p>
<p>面经： Cruise。正常思路是得用PriorityQueue。但是corner case写不出来，讨论区答案里java用个特殊的数据结构搭配pq，加上一个trick，不适合模板解题。…if <strong>y - x // 2</strong> &gt; d:…if <strong>self.N - 1 - self.L[-1]</strong> &gt; d: res = self.N - 1…bisect.<strong>insort</strong>(…)…</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h3 id="208-Implement-Trie-Prefix-Tree-Medium"><a href="#208-Implement-Trie-Prefix-Tree-Medium" class="headerlink" title="208. Implement Trie (Prefix Tree) (Medium)"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Implement a trie with insert, search, and startsWith methods.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert("apple");</span><br><span class="line">trie.search("apple");   // returns true</span><br><span class="line">trie.search("app");     // returns false</span><br><span class="line">trie.startsWith("app"); // returns true</span><br><span class="line">trie.insert("app");   </span><br><span class="line">trie.search("app");     // returns true</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">You may assume that all inputs are consist of lowercase letters a-z.</span><br><span class="line">All inputs are guaranteed to be non-empty strings.</span><br></pre></td></tr></table></figure>
<p>思路：没啥思路，看答案<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="comment"># Initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.word=<span class="keyword">False</span></span><br><span class="line">        self.children=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; word</span></span><br><span class="line">    <span class="comment"># @return &#123;void&#125;</span></span><br><span class="line">    <span class="comment"># Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        node=self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                node.children[i]=TrieNode()</span><br><span class="line">            node=node.children[i]</span><br><span class="line">        node.word=<span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; word</span></span><br><span class="line">    <span class="comment"># @return &#123;boolean&#125;</span></span><br><span class="line">    <span class="comment"># Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        node=self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            node=node.children[i]</span><br><span class="line">        <span class="keyword">return</span> node.word</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; prefix</span></span><br><span class="line">    <span class="comment"># @return &#123;boolean&#125;</span></span><br><span class="line">    <span class="comment"># Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment"># that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix)</span>:</span></span><br><span class="line">        node=self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            node=node.children[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line">    <span class="comment"># obj = Trie()</span></span><br><span class="line">    <span class="comment"># obj.insert(word)</span></span><br><span class="line">    <span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line">    <span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure></p>
<p>总结：1.需要加 TrieNode 2. Leetcode 的 python3 找不到 class 是个 bug</p>
<h3 id="211-Add-and-Search-Word-Data-structure-design-Medium"><a href="#211-Add-and-Search-Word-Data-structure-design-Medium" class="headerlink" title="211. Add and Search Word - Data structure design (Medium)"></a><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">211. Add and Search Word - Data structure design (Medium)</a></h3><p>Design a data structure that supports the following two operations:</p>
<p>void addWord(word)<br>bool search(word)<br>search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p>
<p>Example:</p>
<p>addWord(“bad”)<br>addWord(“dad”)<br>addWord(“mad”)<br>search(“pad”) -&gt; false<br>search(“bad”) -&gt; true<br>search(“.ad”) -&gt; true<br>search(“b..”) -&gt; true<br>Note:<br>You may assume that all words are consist of lowercase letters a-z.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.end = <span class="keyword">False</span></span><br><span class="line">        self.children = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordDictionary</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addWord</span><span class="params">(self, word: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Adds a word into the data structure.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        root = self.root</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> root.children:</span><br><span class="line">                root.children[c] = TrieNode()</span><br><span class="line">            root = root.children[c]</span><br><span class="line">        root.end = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = <span class="keyword">False</span></span><br><span class="line">        self.helper(self.root, word)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, word)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> word:</span><br><span class="line">            <span class="keyword">if</span> root.end:</span><br><span class="line">                self.ans = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> word[<span class="number">0</span>] == <span class="string">"."</span>:</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> root.children.values():</span><br><span class="line">                self.helper(v, word[<span class="number">1</span>:])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> word[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> root.children:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            self.helper(root.children[word[<span class="number">0</span>]], word[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></p>
<p>面经：Celo。insert:…root.end = True…</p>
<h2 id="Union-Find-MST"><a href="#Union-Find-MST" class="headerlink" title="Union Find / MST"></a>Union Find / MST</h2><h3 id="LinC-629-Minimum-Spanning-Tree-Hard"><a href="#LinC-629-Minimum-Spanning-Tree-Hard" class="headerlink" title="LinC 629. Minimum Spanning Tree (Hard)"></a><a href="https://www.lintcode.com/problem/minimum-spanning-tree/description" target="_blank" rel="noopener">LinC 629. Minimum Spanning Tree (Hard)</a></h3><p>Given a list of Connections, which is the Connection class (the city name at both ends of the edge and a cost between them), find edges that can connect all the cities and spend the least amount.<br>Return the connects if can connect all the cities, otherwise return empty list.</p>
<p>Example<br>Example 1:</p>
<p>Input:<br>[“Acity”,”Bcity”,1]<br>[“Acity”,”Ccity”,2]<br>[“Bcity”,”Ccity”,3]<br>Output:<br>[“Acity”,”Bcity”,1]<br>[“Acity”,”Ccity”,2]<br>Example 2:</p>
<p>Input:<br>[“Acity”,”Bcity”,2]<br>[“Bcity”,”Dcity”,5]<br>[“Acity”,”Dcity”,4]<br>[“Ccity”,”Ecity”,1]<br>Output:<br>[]</p>
<p>Explanation:<br>No way<br>Notice<br>Return the connections sorted by the cost, or sorted city1 name if their cost is same, or sorted city2 if their city1 name is also same.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Definition for a Connection</span></span><br><span class="line"><span class="string">class Connection:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    def __init__(self, city1, city2, cost):</span></span><br><span class="line"><span class="string">        self.city1, self.city2, self.cost = city1, city2, cost</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Union</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        self.size = n</span><br><span class="line">        self.graph = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            self.graph[i] = i</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(self, v1, v2)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.find(v1) == self.find(v2)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, v)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.graph[v] == v:</span><br><span class="line">            <span class="keyword">return</span> v</span><br><span class="line">        self.graph[v] = self.find(self.graph[v])</span><br><span class="line">        <span class="keyword">return</span> self.graph[v]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">(self, v1, v2)</span>:</span></span><br><span class="line">        root_a = self.find(v1)</span><br><span class="line">        root_b = self.find(v2)</span><br><span class="line">        <span class="keyword">if</span> root_a != root_b:</span><br><span class="line">            self.size -= <span class="number">1</span></span><br><span class="line">            self.graph[root_a] = self.graph[root_b]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">all_connected</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.size == <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param &#123;Connection[]&#125; connections given a list of connections</span></span><br><span class="line">    <span class="comment"># include two cities and cost</span></span><br><span class="line">    <span class="comment"># @return &#123;Connection[]&#125; a list of connections from results</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCost</span><span class="params">(self, connections)</span>:</span></span><br><span class="line">        <span class="comment"># Write your code here</span></span><br><span class="line">        connections.sort(key = <span class="keyword">lambda</span> x: x.city2)</span><br><span class="line">        connections.sort(key = <span class="keyword">lambda</span> x: x.city1)</span><br><span class="line">        connections.sort(key = <span class="keyword">lambda</span> x: x.cost)</span><br><span class="line">        citymap = &#123;&#125;</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> connections:</span><br><span class="line">            <span class="keyword">if</span> c.city1 <span class="keyword">not</span> <span class="keyword">in</span> citymap:</span><br><span class="line">                citymap[c.city1] = cnt</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c.city2 <span class="keyword">not</span> <span class="keyword">in</span> citymap:</span><br><span class="line">                citymap[c.city2] = cnt</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">        union = Union(cnt)</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> connections:</span><br><span class="line">            c1 = citymap[c.city1]</span><br><span class="line">            c2 = citymap[c.city2]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> union.query(c1, c2):</span><br><span class="line">                union.connect(c1, c2)</span><br><span class="line">                ans.append(c)</span><br><span class="line">        <span class="keyword">return</span> ans <span class="keyword">if</span> union.all_connected() <span class="keyword">else</span> []</span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。todo：刷些 union find 的题看看</p>
<h1 id="DP-Dynamic-Programming-动态规划"><a href="#DP-Dynamic-Programming-动态规划" class="headerlink" title="DP Dynamic Programming 动态规划"></a>DP Dynamic Programming 动态规划</h1><p>题型多为： 1. 求最大值或者最小值 2. 判断方案是否可行 3. 统计方案的个数<br>DP 四要素：1. 状态 state，也就是f[i]或者f[i][j]的物理意义是什么 2. 方程 function，也就是f[i]和f[i - 1]的关系 3. 初始化 initialization，这个方程涉及2个相邻state所以对于state 0肯定是需要初始化的 4. 答案 最大的状态是什么？规划的重点是什么？</p>
<h3 id="70-Climbing-Stairs-Easy"><a href="#70-Climbing-Stairs-Easy" class="headerlink" title="70. Climbing Stairs (Easy)"></a><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">70. Climbing Stairs (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">You are climbing a stair case. It takes n steps to reach to the top.</span><br><span class="line"></span><br><span class="line">Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</span><br><span class="line"></span><br><span class="line">Note: Given n will be a positive integer.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>
<p>思路：f[n] 是为 n 时的方案数，f[1] 是为 1 时的方案数 = 1。<strong>那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的</strong>，所以递推公式非常容易的就得出了：f[n] = f[n - 1] + f[n - 2]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure></p>
<p>总结：和三年前比没有变化，呵呵呵<br>高频：没有太多优化空间，背：爬到第n层的方法要么是从第n-1层1步上来的，要不就是从n-2层2步上来的</p>
<h3 id="120-Triangle-Medium"><a href="#120-Triangle-Medium" class="headerlink" title="120. Triangle (Medium)"></a><a href="https://leetcode.com/problems/triangle/description/" target="_blank" rel="noopener">120. Triangle (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</span><br><span class="line"></span><br><span class="line">For example, given the following triangle</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line">The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</span><br></pre></td></tr></table></figure>
<p>思路：看了 top down 的 DP， 还是比较好理解的。f 代表到达 row 和 col 位置的最小 sum，f[i][j] 和 f[i - 1][j - 1] 的关系是：f[i][j] = mins(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]. 规划的目标是最后一行中的最小值。；DP 以外还有三种解法，DFS：Traverse， DFS：Divide and Conquer， DFS：Divide and Conquer 加 memorization<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(triangle) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(triangle) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        f = []</span><br><span class="line">        f.append([triangle[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">        n = len(triangle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            f.append([<span class="number">0</span>] * (i + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">            f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">1</span>, row):</span><br><span class="line">                f[row][col] = min(f[row - <span class="number">1</span>][col - <span class="number">1</span>], f[row - <span class="number">1</span>][col]) + triangle[row][col]</span><br><span class="line">        ans = f[n - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            ans = min(ans, f[n - <span class="number">1</span>][i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>高频：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        f = [[<span class="number">0</span>] * (i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> j == <span class="number">0</span>:</span><br><span class="line">                    f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][j]</span><br><span class="line">                <span class="keyword">elif</span> j == i:</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + triangle[i][j]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i][j] = min(f[i - <span class="number">1</span>][j - <span class="number">1</span>], f[i - <span class="number">1</span>][j]) + triangle[i][j]</span><br><span class="line">        <span class="keyword">return</span> min(f[n - <span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>bottom up:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        n = len(triangle)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        f = [[<span class="number">0</span>] * (i + <span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        f[n - <span class="number">1</span>] = triangle[<span class="number">-1</span>][:]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(n - <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(r + <span class="number">1</span>):</span><br><span class="line">                f[r][c] = min(f[r + <span class="number">1</span>][c], f[r + <span class="number">1</span>][c + <span class="number">1</span>]) + triangle[r][c]</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">0</span>][<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：填充 f 每行第一个和最后一个的时候别忘了 + triangle[i][0] 和 triangle[i][i]<br>高频：注意topdown：下一层f[i][j]的时候要根据j的情况来分类判断f的值如何获得， 一刷的时候提前把三角的两条边先初始化了，循环的时候不循环那些元素。也是个好办法。代码稍微长一点。bottomup：代码简单很多。还可以进一步将空间降为O(n)，因为之前算出来的f[r + 1][]都没用</p>
<h3 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</span><br><span class="line"></span><br><span class="line">Note that you cannot sell a stock before you buy one.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">             Not 7-1 = 6, as selling price needs to be larger than buying price.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<p>DP：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        lowest = prices[<span class="number">0</span>]</span><br><span class="line">        n = len(prices)</span><br><span class="line">        f = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            lowest = min(prices[i], lowest)</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] <span class="keyword">if</span> prices[i] &lt;= prices[i - <span class="number">1</span>] <span class="keyword">else</span> max(f[i - <span class="number">1</span>], prices[i] - lowest)</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>greedy:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> prices:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        low = prices[<span class="number">0</span>]</span><br><span class="line">        p = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            p = max(p, prices[i] - low)</span><br><span class="line">            low = min(low, prices[i])</span><br><span class="line">        <span class="keyword">return</span> p</span><br></pre></td></tr></table></figure></p>
<p>高频：删了1，2刷的思路答案总结，DP: 要么…f[i] = f[i - 1] if…else max(…)…要么不要max，return max(f)。greedy:</p>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy" class="headerlink" title="122. Best Time to Buy and Sell Stock II (Easy)"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).</span><br><span class="line"></span><br><span class="line">Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,4,5]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.</span><br><span class="line">             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are</span><br><span class="line">             engaging multiple transactions at the same time. You must sell before buying again.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices: List[int])</span> -&gt; int:</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(prices)):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &gt; prices[i - <span class="number">1</span>]:</span><br><span class="line">                ans += prices[i] - prices[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：可以无限买卖=可以抓住所有价格上升的机会</p>
<h3 id="91-Decode-Ways-Medium"><a href="#91-Decode-Ways-Medium" class="headerlink" title="91. Decode Ways (Medium)"></a><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">91. Decode Ways (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">A message containing letters from A-Z is being encoded to numbers using the following mapping:</span><br><span class="line"></span><br><span class="line">'A' -&gt; 1</span><br><span class="line">'B' -&gt; 2</span><br><span class="line">...</span><br><span class="line">'Z' -&gt; 26</span><br><span class="line">Given a non-empty string containing only digits, determine the total number of ways to decode it.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "12"</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: It could be decoded as "AB" (1 2) or "L" (12).</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "226"</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numDecodings</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> s[<span class="number">0</span>] == <span class="string">"0"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            one = int(s[i - <span class="number">1</span>: i])</span><br><span class="line">            two = int(s[i - <span class="number">2</span>: i])</span><br><span class="line">            <span class="keyword">if</span> one &gt; <span class="number">0</span>:</span><br><span class="line">                f[i] += f[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> <span class="number">10</span> &lt;= two &lt;= <span class="number">26</span>:</span><br><span class="line">                f[i] += f[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure></p>
<p>总结：f[n]为第n个数的方案数，0个字1个方案，1个字1个方案，…if 10 &lt;= two &lt;= 26:…防止误判“05”， “06”等情况</p>
<h3 id="62-Unique-Paths-Medium"><a href="#62-Unique-Paths-Medium" class="headerlink" title="62. Unique Paths (Medium)"></a><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">62. Unique Paths (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).</span><br><span class="line"></span><br><span class="line">The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</span><br><span class="line"></span><br><span class="line">How many possible unique paths are there?</span><br><span class="line"></span><br><span class="line">Above is a 7 x 3 grid. How many possible unique paths are there?</span><br><span class="line"></span><br><span class="line">Note: m and n will be at most 100.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: m = 3, n = 2</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:</span><br><span class="line">1. Right -&gt; Right -&gt; Down</span><br><span class="line">2. Right -&gt; Down -&gt; Right</span><br><span class="line">3. Down -&gt; Right -&gt; Right</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: m = 7, n = 3</span><br><span class="line">Output: 28</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        f = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">2</span>, m + <span class="number">1</span>):</span><br><span class="line">                f[r][c] = f[r - <span class="number">1</span>][c] + f[r][c - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n][m]</span><br></pre></td></tr></table></figure>
<p>高频</p>
<h3 id="53-Maximum-Subarray-Easy"><a href="#53-Maximum-Subarray-Easy" class="headerlink" title="53. Maximum Subarray (Easy)"></a><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">53. Maximum Subarray (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">Output: 6</span><br><span class="line">Explanation: [4,-1,2,1] has the largest sum = 6.</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        ans = f[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            <span class="keyword">if</span> f[i - <span class="number">1</span>] &lt; <span class="number">0</span>:</span><br><span class="line">                f[i] = nums[i]    </span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>] + nums[i]</span><br><span class="line">            <span class="keyword">if</span> f[i] &gt; ans:</span><br><span class="line">                ans = f[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：…if f[i - 1] &lt; 0:…</p>
<h3 id="63-Unique-Paths-II-Medium"><a href="#63-Unique-Paths-II-Medium" class="headerlink" title="63. Unique Paths II (Medium)"></a><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. Unique Paths II (Medium)</a></h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>Now consider if some obstacles are added to the grids. How many unique paths would there be?<br>An obstacle and empty space is marked as 1 and 0 respectively in the grid.<br>Note: m and n will be at most 100.</p>
<p>Example 1:<br>Input:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>Output: 2<br>Explanation:<br>There is one obstacle in the middle of the 3x3 grid above.<br>There are two ways to reach the bottom-right corner:</p>
<ol>
<li>Right -&gt; Right -&gt; Down -&gt; Down</li>
<li>Down -&gt; Down -&gt; Right -&gt; Right</li>
</ol>
<p>space O(mxn):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">      m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">      dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)]</span><br><span class="line">      obs = <span class="keyword">False</span></span><br><span class="line">      <span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(obstacleGrid[<span class="number">0</span>]):</span><br><span class="line">          <span class="keyword">if</span> v == <span class="number">1</span>:</span><br><span class="line">              obs = <span class="keyword">True</span></span><br><span class="line">          <span class="keyword">if</span> obs:</span><br><span class="line">              dp[<span class="number">0</span>][i] = <span class="number">0</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">      obs = <span class="keyword">False</span></span><br><span class="line">      <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">          <span class="keyword">if</span> obstacleGrid[i][<span class="number">0</span>] == <span class="number">1</span>:</span><br><span class="line">              obs = <span class="keyword">True</span></span><br><span class="line">          <span class="keyword">if</span> obs:</span><br><span class="line">              dp[i][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">      <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">          <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">              <span class="keyword">if</span> obstacleGrid[r][c] == <span class="number">1</span>:</span><br><span class="line">                  dp[r][c] = <span class="number">0</span></span><br><span class="line">              <span class="keyword">else</span>:</span><br><span class="line">                  dp[r][c] = dp[r - <span class="number">1</span>][c] + dp[r][c - <span class="number">1</span>]</span><br><span class="line">      <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>space: O(n):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(self, obstacleGrid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(obstacleGrid), len(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span> <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        obs = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][i] == <span class="number">1</span>:</span><br><span class="line">                obs = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> obs:</span><br><span class="line">                dp[i] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            dp[<span class="number">0</span>] = dp[<span class="number">0</span>] <span class="keyword">if</span> obstacleGrid[r][<span class="number">0</span>] == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[r][c] == <span class="number">1</span>:</span><br><span class="line">                    dp[c] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    dp[c] = dp[c - <span class="number">1</span>] + dp[c]</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>高频<br>面经：Celo, todo: space: O(1)</p>
<h3 id="64-Minimum-Path-Sum-Medium"><a href="#64-Minimum-Path-Sum-Medium" class="headerlink" title="64. Minimum Path Sum (Medium)"></a><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. Minimum Path Sum (Medium)</a></h3><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<p>Example:</p>
<p>Input:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>Output: 7<br>Explanation: Because the path 1→3→1→1→1 minimizes the sum.<br>空间O(m*n):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        rl = len(grid)</span><br><span class="line">        cl = len(grid[<span class="number">0</span>])</span><br><span class="line">        f = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(cl)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(rl)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">1</span>, rl):</span><br><span class="line">            f[r][<span class="number">0</span>] = f[r - <span class="number">1</span>][<span class="number">0</span>] + grid[r][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, cl):</span><br><span class="line">            f[<span class="number">0</span>][c] = f[<span class="number">0</span>][c - <span class="number">1</span>] + grid[<span class="number">0</span>][c]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">1</span>, rl):</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, cl):</span><br><span class="line">                f[r][c] = min(f[r - <span class="number">1</span>][c], f[r][c - <span class="number">1</span>]) + grid[r][c]</span><br><span class="line">        <span class="keyword">return</span> f[rl - <span class="number">1</span>][cl - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>空间O(n):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minPathSum</span><span class="params">(self, grid: List[List[int]])</span> -&gt; int:</span></span><br><span class="line">        m, n = len(grid), len(grid[<span class="number">0</span>])</span><br><span class="line">        dp = [<span class="number">0</span>] * n</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            dp[c] = dp[c - <span class="number">1</span>] + grid[<span class="number">0</span>][c]</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            dp[<span class="number">0</span>] += grid[r][<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">                dp[c] = min(dp[c], dp[c - <span class="number">1</span>]) + grid[r][c]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>高频：优化空间可以将二维数组f压缩为一维，因为答案不关心中间值<br>面经：Amazon。优化空间</p>
<h3 id="72-Edit-Distance-Hard"><a href="#72-Edit-Distance-Hard" class="headerlink" title="72. Edit Distance (Hard)"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">72. Edit Distance (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</span><br><span class="line"></span><br><span class="line">You have the following 3 operations permitted on a word:</span><br><span class="line"></span><br><span class="line">Insert a character</span><br><span class="line">Delete a character</span><br><span class="line">Replace a character</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: word1 = "horse", word2 = "ros"</span><br><span class="line">Output: 3</span><br><span class="line">Explanation:</span><br><span class="line">horse -&gt; rorse (replace 'h' with 'r')</span><br><span class="line">rorse -&gt; rose (remove 'r')</span><br><span class="line">rose -&gt; ros (remove 'e')</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: word1 = "intention", word2 = "execution"</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">intention -&gt; inention (remove 't')</span><br><span class="line">inention -&gt; enention (replace 'i' with 'e')</span><br><span class="line">enention -&gt; exention (replace 'n' with 'x')</span><br><span class="line">exention -&gt; exection (replace 'n' with 'c')</span><br><span class="line">exection -&gt; execution (insert 'u')</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>高频：f 为从 m 的前 i 个变到 n 的前 j 个字符串所需的最少步骤, 第前 i 个字符串 == word1[i - 1]…if word1[i - 1] == word2[j - 1]: f[i][j] = f[i - 1][j - 1]…else: f[i][j] = min(f[i - 1][j - 1], f[i - 1][j], f[i][j - 1]) + 1</p>
<h3 id="132-Palindrome-Partitioning-II-Hard"><a href="#132-Palindrome-Partitioning-II-Hard" class="headerlink" title="132. Palindrome Partitioning II (Hard)"></a><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. Palindrome Partitioning II (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Given a string s, partition s such that every substring of the partition is a palindrome.</span><br><span class="line"></span><br><span class="line">Return the minimum cuts needed for a palindrome partitioning of s.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: "aab"</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minCut</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        p = [[<span class="keyword">False</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            f[i] = i</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (i - j &lt; <span class="number">2</span> <span class="keyword">or</span> p[j + <span class="number">1</span>][i - <span class="number">1</span>]):</span><br><span class="line">                    p[j][i] = <span class="keyword">True</span></span><br><span class="line">                    f[i] = <span class="number">0</span> <span class="keyword">if</span> j == <span class="number">0</span> <span class="keyword">else</span> min(f[i], f[j - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：f为从0到i(i从0到n-1)字符串的mincut数。p为从j到i是否是回文，因为j（从0到i，i从0到n-1）可能到j+1，因此p […in range(n <strong>+ 1</strong>)]。…for j in range(i + 1):…and (i - j &lt; 2 <strong>or</strong> p[j + 1][i - 1])…</p>
<h3 id="5-Longest-Palindromic-Substring-Medium"><a href="#5-Longest-Palindromic-Substring-Medium" class="headerlink" title="5. Longest Palindromic Substring (Medium)"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. Longest Palindromic Substring (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "babad"</span><br><span class="line">Output: "bab"</span><br><span class="line">Note: "aba" is also a valid answer.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "cbbd"</span><br><span class="line">Output: "bb"</span><br></pre></td></tr></table></figure>
<p>暴力：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">palAroundI</span><span class="params">(l, r)</span>:</span></span><br><span class="line">            <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt; len(s) <span class="keyword">and</span> s[l] == s[r]:</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> s[l + <span class="number">1</span> : r]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            t = palAroundI(i, i)</span><br><span class="line">            <span class="keyword">if</span> len(t) &gt; len(ans):</span><br><span class="line">                ans = t</span><br><span class="line">            t = palAroundI(i, i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> len(t) &gt; len(ans):</span><br><span class="line">                ans = t</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>dp：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        f = [[<span class="keyword">False</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(j + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> s[i] == s[j] <span class="keyword">and</span> (j - i &lt;= <span class="number">2</span> <span class="keyword">or</span> f[i + <span class="number">1</span>][j - <span class="number">1</span>]):</span><br><span class="line">                    f[i][j] = <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">if</span> f[i][j] <span class="keyword">and</span> len(ans) &lt; j - i + <span class="number">1</span>:</span><br><span class="line">                    ans = s[i:j + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>高频：暴力：…def palAroundI(l, r):…return s[l + 1, r]…。dp: f为从i到j是否为回文串，…for j in range(n): for i in range(j <strong>+ 1</strong>):…</p>
<h3 id="55-Jump-Game-Medium"><a href="#55-Jump-Game-Medium" class="headerlink" title="55. Jump Game (Medium)"></a><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">55. Jump Game (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given an array of non-negative integers, you are initially positioned at the first index of the array.</span><br><span class="line"></span><br><span class="line">Each element in the array represents your maximum jump length at that position.</span><br><span class="line"></span><br><span class="line">Determine if you are able to reach the last index.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [2,3,1,1,4]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [3,2,1,0,4]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: You will always arrive at index 3 no matter what. Its maximum</span><br><span class="line">             jump length is 0, which makes it impossible to reach the last index.</span><br></pre></td></tr></table></figure>
<p>dp:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        f = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums))]</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums)):</span><br><span class="line">            f[i] = max(f[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> f[i] &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>greedy:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        reach = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i, n <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> reach &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; reach:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            reach = max(reach, i + n)</span><br></pre></td></tr></table></figure></p>
<p>高频：dp: f为当前位置的剩余步数 f[i] = max(f[i - 1], nums[i - 1]) - 1。greedy：reach为从0点能到的最远距离</p>
<h3 id="96-Unique-Binary-Search-Trees-Medium"><a href="#96-Unique-Binary-Search-Trees-Medium" class="headerlink" title="96. Unique Binary Search Trees (Medium)"></a><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. Unique Binary Search Trees (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: 5</span><br><span class="line">Explanation:</span><br><span class="line">Given n = 3, there are a total of 5 unique BST's:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">                f[i] += f[j - <span class="number">1</span>] * f[i - j]</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure>
<p>高频：关键是要知道f推导公式：g[i, n]代表以i为root的bst，f[n] = g[1, n] + g[2, n] +…+ g[n, n], g[i, n] = f[i - 1] * f[n - i]。以i为root的左边是i - 1个数，右边是n - i个数，具体数值对于f方案数并不是那么重要。</p>
<h3 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II (Medium)"></a><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. Unique Binary Search Trees II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,null,3,2],</span><br><span class="line">  [3,2,null,1],</span><br><span class="line">  [3,1,null,null,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [1,null,2,null,3]</span><br><span class="line">]</span><br><span class="line">Explanation:</span><br><span class="line">The above output corresponds to the 5 unique BST's shown below:</span><br><span class="line"></span><br><span class="line">   1         3     3      2      1</span><br><span class="line">    \       /     /      / \      \</span><br><span class="line">     3     2     1      1   3      2</span><br><span class="line">    /     /       \                 \</span><br><span class="line">   2     1         2                 3</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateTrees</span><span class="params">(self, n: int)</span> -&gt; List[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(s, e)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> s &gt; e: <span class="keyword">return</span> [<span class="keyword">None</span>]</span><br><span class="line">            res = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(s, e + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> gen(s, i - <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">for</span> r <span class="keyword">in</span> gen(i + <span class="number">1</span>, e):</span><br><span class="line">                        root = TreeNode(i)</span><br><span class="line">                        root.left = l</span><br><span class="line">                        root.right = r</span><br><span class="line">                        res.append(root)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">return</span> gen(<span class="number">1</span>, n)</span><br></pre></td></tr></table></figure>
<p>高频：看着像非主流dp题。…def gen(s, e):…res = []…for l in gen(s, i <strong>- 1</strong>):…return gen(1, n)</p>
<h3 id="198-House-Robber-Easy"><a href="#198-House-Robber-Easy" class="headerlink" title="198. House Robber (Easy)"></a><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.</span><br><span class="line"></span><br><span class="line">Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3,1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).</span><br><span class="line">             Total amount you can rob = 1 + 3 = 4.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: [2,7,9,3,1]</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).</span><br><span class="line">             Total amount you can rob = 2 + 9 + 1 = 12.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        f = [<span class="number">0</span>] * n</span><br><span class="line">        f[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        f[<span class="number">1</span>] = max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            f[i] = max(f[i - <span class="number">2</span>] + nums[i], f[i - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<p>高频：f[i]有两个决定， 一个是抢，或不抢当前的房，取max即可<br>面经：Quora。</p>
<h3 id="213-House-Robber-II-Medium"><a href="#213-House-Robber-II-Medium" class="headerlink" title="213. House Robber II (Medium)"></a><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. House Robber II (Medium)</a></h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.<br>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:<br>Input: [2,3,2]<br>Output: 3<br>Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),<br>             because they are adjacent houses.<br>Example 2:<br>Input: [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>             Total amount you can rob = 1 + 3 = 4.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rob</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">        dp1 = [<span class="number">0</span>] * n</span><br><span class="line">        dp2 = [<span class="number">0</span>] * n</span><br><span class="line">        dp1[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">        dp2[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        dp1[<span class="number">1</span>] = dp1[<span class="number">0</span>]</span><br><span class="line">        dp2[<span class="number">1</span>] = nums[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n - <span class="number">1</span>):</span><br><span class="line">            dp1[i] = max(dp1[i - <span class="number">1</span>], dp1[i - <span class="number">2</span>] + nums[i])</span><br><span class="line">            dp2[i] = max(dp2[i - <span class="number">1</span>], dp2[i - <span class="number">2</span>] + nums[i])  </span><br><span class="line">        <span class="keyword">return</span> max(dp1[n - <span class="number">2</span>], max(dp2[n - <span class="number">2</span>], dp2[n - <span class="number">3</span>] + nums[n - <span class="number">1</span>]))</span><br></pre></td></tr></table></figure></p>
<p>面经：Quora。</p>
<h3 id="10-Regular-Expression-Matching-Hard"><a href="#10-Regular-Expression-Matching-Hard" class="headerlink" title="10. Regular Expression Matching (Hard)"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. Regular Expression Matching (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.</span><br><span class="line"></span><br><span class="line">'.' Matches any single character.</span><br><span class="line">'*' Matches zero or more of the preceding element.</span><br><span class="line">The matching should cover the entire input string (not partial).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">s could be empty and contains only lowercase letters a-z.</span><br><span class="line">p could be empty and contains only lowercase letters a-z, and characters like . or *.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = "aa"</span><br><span class="line">p = "a"</span><br><span class="line">Output: false</span><br><span class="line">Explanation: "a" does not match the entire string "aa".</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = "aa"</span><br><span class="line">p = "a*"</span><br><span class="line">Output: true</span><br><span class="line">Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = "ab"</span><br><span class="line">p = ".*"</span><br><span class="line">Output: true</span><br><span class="line">Explanation: ".*" means "zero or more (*) of any character (.)".</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = "aab"</span><br><span class="line">p = "c*a*b"</span><br><span class="line">Output: true</span><br><span class="line">Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">s = "mississippi"</span><br><span class="line">p = "mis*is*p*."</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>DP：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        ls, lp = len(s), len(p)</span><br><span class="line">        f = [[<span class="keyword">False</span>] * (lp + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(ls + <span class="number">1</span>)]</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, lp):</span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                f[<span class="number">0</span>][j + <span class="number">1</span>] = f[<span class="number">0</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(ls):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(lp):</span><br><span class="line">                <span class="keyword">if</span> p[j] == <span class="string">'.'</span> <span class="keyword">or</span> s[i] == p[j]:</span><br><span class="line">                    f[i + <span class="number">1</span>][j + <span class="number">1</span>] = f[i][j]</span><br><span class="line">                <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                    <span class="keyword">if</span> s[i] != p[j - <span class="number">1</span>] <span class="keyword">and</span> p[j - <span class="number">1</span>] != <span class="string">'.'</span>:</span><br><span class="line">                        f[i + <span class="number">1</span>][j + <span class="number">1</span>] = f[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        f[i + <span class="number">1</span>][j + <span class="number">1</span>] =  f[i][j + <span class="number">1</span>] <span class="keyword">or</span> f[i + <span class="number">1</span>][j] <span class="keyword">or</span> f[i + <span class="number">1</span>][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> f[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>Backtracking：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> p:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">not</span> s</span><br><span class="line">        first_matched = len(s) &gt; <span class="number">0</span> <span class="keyword">and</span> (s[<span class="number">0</span>] == p[<span class="number">0</span>] <span class="keyword">or</span> p[<span class="number">0</span>] == <span class="string">'.'</span>)</span><br><span class="line">        <span class="keyword">if</span> len(p) &gt; <span class="number">1</span> <span class="keyword">and</span> p[<span class="number">1</span>] == <span class="string">'*'</span>:</span><br><span class="line">            <span class="keyword">return</span> self.isMatch(s, p[<span class="number">2</span>:]) <span class="keyword">or</span> (first_matched <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> first_matched <span class="keyword">and</span> self.isMatch(s[<span class="number">1</span>:], p[<span class="number">1</span>:])</span><br></pre></td></tr></table></figure></p>
<p>高频：dp:怎么写都不是很直观，目前采用range和p[],s[]取值简化写。当前p的字符位’.’或者和s当前字符相等即前进。’*‘分两种情况：1.p前一位不是’.’与当前s字符也不等，a<em> counts as empty 2.等或者是’.(\</em>)’，a<em> counts as multiple a / a</em> counts as single a / a<em> counts as empty。时间空间复杂度均为O(ls</em>lp)<br>backtracking: 关键要用s = “aab” p = “c<em>a</em>b”来记住如果有*，要么忽略这部分p，要么删掉第一个匹配的字符这个算法。…if not p:…firt_matched = len(s) &gt; 0 and (s[0]…)…时间空间复杂度：<a href="https://leetcode.com/problems/regular-expression-matching/solution/" target="_blank" rel="noopener">leetcode solution</a>里有，较复杂</p>
<h3 id="44-Wildcard-Matching-Hard"><a href="#44-Wildcard-Matching-Hard" class="headerlink" title="44. Wildcard Matching (Hard)"></a><a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. Wildcard Matching (Hard)</a></h3><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘<em>‘.<br>‘?’ Matches any single character.<br>‘</em>‘ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>
<p>Note:<br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like ? or * .</p>
<p>Example 1:<br>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p>
<p>Example 2:<br>Input:<br>s = “aa”<br>p = “<em>“<br>Output: true<br>Explanation: ‘</em>‘ matches any sequence.</p>
<p>Example 3:<br>Input:<br>s = “cb”<br>p = “?a”<br>Output: false<br>Explanation: ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.</p>
<p>Example 4:<br>Input:<br>s = “adceb”<br>p = “<em>a</em>b”<br>Output: true<br>Explanation: The first ‘<em>‘ matches the empty sequence, while the second ‘</em> ‘ matches the substring “dce”.</p>
<p>Example 5:<br>Input:<br>s = “acdcb”<br>p = “a*c?b”<br>Output: false<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span><span class="params">(self, s: str, p: str)</span> -&gt; bool:</span></span><br><span class="line">        ls, lp = len(s), len(p)</span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (lp + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(ls + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(lp):</span><br><span class="line">            <span class="keyword">if</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                dp[<span class="number">0</span>][j + <span class="number">1</span>] = dp[<span class="number">0</span>][j]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(ls):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(lp):</span><br><span class="line">                <span class="keyword">if</span> s[i] == p[j] <span class="keyword">or</span> p[j] == <span class="string">'?'</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j]</span><br><span class="line">                <span class="keyword">elif</span> p[j] == <span class="string">'*'</span>:</span><br><span class="line">                    dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j + <span class="number">1</span>] <span class="keyword">or</span> dp[i + <span class="number">1</span>][j]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>高频：和上题统一的模板，当j位置的p是’?’ 或者和i位置的s相等时，均前进…f[i + 1][j + 1] = f[i][j],当j位置是’*‘时，两种情况，<em> count as multiple char / </em> count as single char …f[i + 1][j + 1] = f[i][j + 1] or f[i + 1][j]…<br>面经：Quora。</p>
<h3 id="139-Word-Break-Medium"><a href="#139-Word-Break-Medium" class="headerlink" title="139. Word Break (Medium)"></a><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">139. Word Break (Medium)</a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:<br>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.</p>
<p>Example 1:<br>Input: s = “leetcode”, wordDict = [“leet”, “code”]<br>Output: true<br>Explanation: Return true because “leetcode” can be segmented as “leet code”.</p>
<p>Example 2:<br>Input: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>Output: true<br>Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”.<br>             Note that you are allowed to reuse a dictionary word.<br>Example 3:<br>Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output: false<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordBreak</span><span class="params">(self, s: str, wordDict: List[str])</span> -&gt; bool:</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        dp = [<span class="keyword">False</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">for</span> w <span class="keyword">in</span> wordDict:</span><br><span class="line">                <span class="keyword">if</span> w == s[i - len(w) + <span class="number">1</span>:i + <span class="number">1</span>] <span class="keyword">and</span> (dp[i - len(w)] <span class="keyword">or</span> i == len(w) - <span class="number">1</span>):</span><br><span class="line">                    dp[i] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。这题的关键是搞明白dp[i]的意义是代表此处为结束的单词w在表中，并且w前一位置的dp也为True</p>
<h3 id="377-Combination-Sum-IV-Medium"><a href="#377-Combination-Sum-IV-Medium" class="headerlink" title="377. Combination Sum IV (Medium)"></a><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. Combination Sum IV (Medium)</a></h3><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<p>Example:<br>nums = [1, 2, 3]<br>target = 4</p>
<p>The possible combination ways are:<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)</p>
<p>Note that different sequences are counted as different combinations.<br>Therefore the output is 7.</p>
<p>Follow up:<br>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative numbers?<br>memo[4] = memo[4 - 1] + memo[4 - 3] + memo[4 - 1]的方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        memo = [<span class="number">-1</span>] * (target + <span class="number">1</span>)</span><br><span class="line">        memo[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(nums, target, memo)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, nums, target, memo)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> memo[target] != <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> memo[target]</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[i]:</span><br><span class="line">                cnt += self.helper(nums, target - nums[i], memo)</span><br><span class="line">        memo[target] = cnt</span><br><span class="line">        <span class="keyword">return</span> cnt</span><br></pre></td></tr></table></figure></p>
<p>稍微DFS一点的模板：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum4</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.dfs(nums, target, &#123;&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, target, memo)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> target <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[target]</span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> target &gt;= nums[i]:</span><br><span class="line">                res += self.dfs(nums, target - nums[i], memo)        </span><br><span class="line">        memo[target] = res</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p>
<p>面经：Amazon。</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="322-Coin-Change-Medium"><a href="#322-Coin-Change-Medium" class="headerlink" title="322. Coin Change (Medium)"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change (Medium)</a></h3><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1</p>
<p>Example 2:<br>Input: coins = [2], amount = 3<br>Output: -1</p>
<p>Note:<br>You may assume that you have an infinite number of each kind of coin.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(self, coins: List[int], amount: int)</span> -&gt; int:</span></span><br><span class="line">        MAX = float(<span class="string">'inf'</span>)</span><br><span class="line">        dp = [MAX] * (amount + <span class="number">1</span>)</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount + <span class="number">1</span>):</span><br><span class="line">            dp[i] = min([dp[i - coin] <span class="keyword">if</span> i - coin &gt;= <span class="number">0</span> <span class="keyword">else</span> MAX <span class="keyword">for</span> coin <span class="keyword">in</span> coins]) + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dp[amount] == MAX:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> dp[amount]</span><br></pre></td></tr></table></figure></p>
<p>面经: Cruise。sys.maxsize和float(‘inf’)是有区别的，前者可以被+1，后者+1还是inf</p>
<h3 id="474-Ones-and-Zeroes-Medium"><a href="#474-Ones-and-Zeroes-Medium" class="headerlink" title="474. Ones and Zeroes (Medium)"></a><a href="https://leetcode.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. Ones and Zeroes (Medium)</a></h3><p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.<br>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.<br>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.<br>Note:<br>The given numbers of 0s and 1s will both not exceed 100<br>The size of given string array won’t exceed 600.</p>
<p>Example 1:<br>Input: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br>Output: 4<br>Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</p>
<p>Example 2:<br>Input: Array = {“10”, “0”, “1”}, m = 1, n = 1<br>Output: 2<br>Explanation: You could form “10”, but then you’d have nothing left. Better form “0” and “1”.<br>Bruteforce:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">            <span class="keyword">return</span> self.helper(strs, m, n, <span class="number">0</span>, collections.defaultdict(dict))</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, strs, m, n, idx, memo)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> m <span class="keyword">in</span> memo <span class="keyword">and</span> n <span class="keyword">in</span> memo[m] <span class="keyword">and</span> idx <span class="keyword">in</span> memo[m][n]:</span><br><span class="line">                <span class="keyword">return</span> memo[m][n][idx]</span><br><span class="line">            memo.setdefault(m, &#123;&#125;).setdefault(n, &#123;&#125;)[idx] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(idx, len(strs)):</span><br><span class="line">                zeros, ones = strs[i].count(<span class="string">'0'</span>), strs[i].count(<span class="string">'1'</span>)</span><br><span class="line">                <span class="keyword">if</span> zeros &lt;= m <span class="keyword">and</span> ones &lt;= n:</span><br><span class="line">                    memo[m][n][idx] = max(memo[m][n][idx], self.helper(strs, m - zeros, n - ones, i + <span class="number">1</span>, memo) + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[m][n][idx]</span><br></pre></td></tr></table></figure></p>
<p>DP:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxForm</span><span class="params">(self, strs: List[str], m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        dp = [[[<span class="number">0</span>] * (n + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(m + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(strs) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(strs) + <span class="number">1</span>):</span><br><span class="line">            zeros, ones = strs[i - <span class="number">1</span>].count(<span class="string">'0'</span>), strs[i - <span class="number">1</span>].count(<span class="string">'1'</span>)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(m + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(n + <span class="number">1</span>):</span><br><span class="line">                    <span class="keyword">if</span> j &gt;= zeros <span class="keyword">and</span> k &gt;= ones:</span><br><span class="line">                        dp[i][j][k] = max(dp[i - <span class="number">1</span>][j][k], dp[i - <span class="number">1</span>][j - zeros][k - ones] + <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        dp[i][j][k] = dp[i - <span class="number">1</span>][j][k]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>面经：Cruise。可惜两种方法都过不了python3的oj</p>
<h3 id="416-Partition-Equal-Subset-Sum-Medium"><a href="#416-Partition-Equal-Subset-Sum-Medium" class="headerlink" title="416. Partition Equal Subset Sum (Medium)"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum (Medium)</a></h3><p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p>Note:<br>Each of the array element will not exceed 100.<br>The array size will not exceed 200.</p>
<p>Example 1:<br>Input: [1, 5, 11, 5]<br>Output: true<br>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>
<p>Example 2:<br>Input: [1, 2, 3, 5]<br>Output: false<br>Explanation: The array cannot be partitioned into equal sum subsets.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canPartition</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        target = sum(nums)</span><br><span class="line">        <span class="keyword">if</span> target % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        target //= <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> max(nums) &gt; target:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        dp = [[<span class="keyword">False</span>] * (target + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(len(nums) + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums) + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(nums) + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, target + <span class="number">1</span>):</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> j &gt;= nums[i - <span class="number">1</span>]:</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] <span class="keyword">or</span> dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]]</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>面经：Cruise。dp为从前i个序列中是否能有组成和为j的组合，要么用i - 1，要么不用i - 1，用的话那么取决于dp[i - 1][j - nums[i -1]]</p>
<h1 id="Bit-Manipulation"><a href="#Bit-Manipulation" class="headerlink" title="Bit Manipulation"></a>Bit Manipulation</h1><h3 id="231-Power-of-Two-Easy"><a href="#231-Power-of-Two-Easy" class="headerlink" title="231. Power of Two (Easy)"></a><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="noopener">231. Power of Two (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given an integer, write a function to determine if it is a power of two.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 2^0 = 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 2^4 = 16</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 218</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>思路：既然是 bit manipulation 的题，肯定是变成 bits 操作，稍微看一下 2 的倍数都是 1 后面全是 0。怎么用 python 检查这个比较没思路。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> bin(n)[<span class="number">2</span>:] == <span class="string">'1'</span>.ljust(len(bin(n)) - <span class="number">2</span>, <span class="string">'0'</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：看了三年前比较屌的 trick 是 return n &amp; n - 1, 当然 bin 这种土办法也 OK 的。</p>
<h3 id="29-Divide-Two-Integers-Medium"><a href="#29-Divide-Two-Integers-Medium" class="headerlink" title="29. Divide Two Integers (Medium)"></a><a href="https://leetcode.com/problems/divide-two-integers/description/" target="_blank" rel="noopener">29. Divide Two Integers (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</span><br><span class="line"></span><br><span class="line">Return the quotient after dividing dividend by divisor.</span><br><span class="line"></span><br><span class="line">The integer division should truncate toward zero.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Both dividend and divisor will be 32-bit signed integers.</span><br><span class="line">The divisor will never be 0.</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend: int, divisor: int)</span> -&gt; int:</span></span><br><span class="line">        positive = (dividend &lt; <span class="number">0</span>) <span class="keyword">is</span> (divisor &lt; <span class="number">0</span>)</span><br><span class="line">        dividend, divisor = abs(dividend), abs(divisor)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> dividend &gt;= divisor:</span><br><span class="line">            t, p = divisor, <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> dividend &gt;= t:</span><br><span class="line">                dividend -= t</span><br><span class="line">                ans += p</span><br><span class="line">                t &lt;&lt;= <span class="number">1</span></span><br><span class="line">                p &lt;&lt;= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> positive:</span><br><span class="line">            ans = -ans</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (-pow(<span class="number">2</span>, <span class="number">31</span>) &lt;= ans &lt;= pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：…while dividend &gt;= divisor: …while dividend &gt;= t: dividend -= t; ans += p; t &lt;&lt;= 1; p &lt;&lt;= 1…</p>
<h3 id="89-Gray-Code-Medium"><a href="#89-Gray-Code-Medium" class="headerlink" title="89. Gray Code (Medium)"></a><a href="https://leetcode.com/problems/gray-code/" target="_blank" rel="noopener">89. Gray Code (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">The gray code is a binary numeral system where two successive values differ in only one bit.</span><br><span class="line"></span><br><span class="line">Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2</span><br><span class="line">Output: [0,1,3,2]</span><br><span class="line">Explanation:</span><br><span class="line">00 - 0</span><br><span class="line">01 - 1</span><br><span class="line">11 - 3</span><br><span class="line">10 - 2</span><br><span class="line"></span><br><span class="line">For a given n, a gray code sequence may not be uniquely defined.</span><br><span class="line">For example, [0,2,3,1] is also a valid gray code sequence.</span><br><span class="line"></span><br><span class="line">00 - 0</span><br><span class="line">10 - 2</span><br><span class="line">11 - 3</span><br><span class="line">01 - 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 0</span><br><span class="line">Output: [0]</span><br><span class="line">Explanation: We define the gray code sequence to begin with 0.</span><br><span class="line">             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.</span><br><span class="line">             Therefore, for n = 0 the gray code sequence is [0].</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grayCode</span><span class="params">(self, n: int)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans += [x + pow(<span class="number">2</span>, i) <span class="keyword">for</span> x <span class="keyword">in</span> reversed(ans)]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：这道题无面试意义，考点在于知道格雷码的<a href="https://www.cnblogs.com/grandyang/p/4315649.html" target="_blank" rel="noopener">镜像性质</a></p>
<h1 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h1><h3 id="65-Valid-Number-Hard"><a href="#65-Valid-Number-Hard" class="headerlink" title="65. Valid Number (Hard)"></a><a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">65. Valid Number (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Validate if a given string can be interpreted as a decimal number.</span><br><span class="line"></span><br><span class="line">Some examples:</span><br><span class="line">"0" =&gt; true</span><br><span class="line">" 0.1 " =&gt; true</span><br><span class="line">"abc" =&gt; false</span><br><span class="line">"1 a" =&gt; false</span><br><span class="line">"2e10" =&gt; true</span><br><span class="line">" -90e3   " =&gt; true</span><br><span class="line">" 1e" =&gt; false</span><br><span class="line">"e3" =&gt; false</span><br><span class="line">" 6e-1" =&gt; true</span><br><span class="line">" 99e2.5 " =&gt; false</span><br><span class="line">"53.5e93" =&gt; true</span><br><span class="line">" --6 " =&gt; false</span><br><span class="line">"-+3" =&gt; false</span><br><span class="line">"95a54e53" =&gt; false</span><br><span class="line"></span><br><span class="line">Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:</span><br><span class="line"></span><br><span class="line">Numbers 0-9</span><br><span class="line">Exponent - "e"</span><br><span class="line">Positive/negative sign - "+"/"-"</span><br><span class="line">Decimal point - "."</span><br><span class="line">Of course, the context of these characters also matters in the input.</span><br></pre></td></tr></table></figure>
<p>高频：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isNumber</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        pattern = <span class="string">r'^[+-]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(e[+-]?[0-9]+)?$'</span></span><br><span class="line">        <span class="keyword">return</span> re.match(pattern, s.strip()) != <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>总结：学习了^, [], ?, +, *, |, $的用法</p>
<h1 id="Misc-杂类型，偏门-特殊算法"><a href="#Misc-杂类型，偏门-特殊算法" class="headerlink" title="Misc 杂类型，偏门/特殊算法"></a>Misc 杂类型，偏门/特殊算法</h1><h3 id="7-Reverse-Integer-Easy"><a href="#7-Reverse-Integer-Easy" class="headerlink" title="7. Reverse Integer (Easy)"></a><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">7. Reverse Integer (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a 32-bit signed integer, reverse digits of an integer.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 123</span><br><span class="line">Output: 321</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: -123</span><br><span class="line">Output: -321</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 120</span><br><span class="line">Output: 21</span><br><span class="line">Note:</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.</span><br></pre></td></tr></table></figure>
<p>高频<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(self, x: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> x == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>       </span><br><span class="line">        <span class="keyword">if</span> x &gt; <span class="number">0</span>:</span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            sign = <span class="number">-1</span></span><br><span class="line">            x = -x       </span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> x:</span><br><span class="line">            ans = ans * <span class="number">10</span> + x % <span class="number">10</span></span><br><span class="line">            x //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">if</span> (sign == <span class="number">1</span> <span class="keyword">and</span> ans &gt; pow(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span>) <span class="keyword">or</span> (sign == <span class="number">-1</span> <span class="keyword">and</span> ans &gt; pow(<span class="number">2</span>, <span class="number">31</span>)):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> sign * ans</span><br></pre></td></tr></table></figure></p>
<p>总结：…while x:…ans = ans * 10 + x <strong>%</strong> 10。转成字符串[::-1]是更优解</p>
<h3 id="31-Next-Permutation-Medium"><a href="#31-Next-Permutation-Medium" class="headerlink" title="31. Next Permutation (Medium)"></a><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener">31. Next Permutation (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.</span><br><span class="line"></span><br><span class="line">If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).</span><br><span class="line"></span><br><span class="line">The replacement must be in-place and use only constant extra memory.</span><br><span class="line"></span><br><span class="line">Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.</span><br><span class="line"></span><br><span class="line">1,2,3 → 1,3,2</span><br><span class="line">3,2,1 → 1,2,3</span><br><span class="line">1,1,5 → 1,5,1</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextPermutation</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> sorted(nums) == nums[::<span class="number">-1</span>]:</span><br><span class="line">            nums.sort()</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        i = len(nums) - <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i <span class="keyword">and</span> nums[i] &gt;= nums[i + <span class="number">1</span>]:</span><br><span class="line">            i -= <span class="number">1</span></span><br><span class="line">        j = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j <span class="keyword">and</span> nums[j] &lt;= nums[i]:</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[i], nums[j] = nums[j], nums[i]</span><br><span class="line">        nums[i + <span class="number">1</span>:] = sorted(nums[i + <span class="number">1</span>:])</span><br></pre></td></tr></table></figure>
<p>高频：傻逼题，高频题表可能被坑了，这道题取决于知道<a href="https://leetcode.com/problems/next-permutation/discuss/13867/C%2B%2B-from-Wikipedia" target="_blank" rel="noopener">十四世纪的一个算法</a>，…i = len(nums) - 2; while…nums[i] <strong>&gt;=</strong> nums[i + 1]:…while…nums[j] <strong>&lt;=</strong> nums[i]:…<br>还有 Next Permutation II (Medium)</p>
<h3 id="60-Permutation-Sequence-Medium"><a href="#60-Permutation-Sequence-Medium" class="headerlink" title="60. Permutation Sequence (Medium)"></a><a href="https://leetcode.com/problems/permutation-sequence/" target="_blank" rel="noopener">60. Permutation Sequence (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">The set [1,2,3,...,n] contains a total of n! unique permutations.</span><br><span class="line"></span><br><span class="line">By listing and labeling all of the permutations in order, we get the following sequence for n = 3:</span><br><span class="line"></span><br><span class="line">"123"</span><br><span class="line">"132"</span><br><span class="line">"213"</span><br><span class="line">"231"</span><br><span class="line">"312"</span><br><span class="line">"321"</span><br><span class="line">Given n and k, return the kth permutation sequence.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Given n will be between 1 and 9 inclusive.</span><br><span class="line">Given k will be between 1 and n! inclusive.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: n = 3, k = 3</span><br><span class="line">Output: "213"</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: n = 4, k = 9</span><br><span class="line">Output: "2314"</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPermutation</span><span class="params">(self, n: int, k: int)</span> -&gt; str:</span></span><br><span class="line">        nums = [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        <span class="keyword">while</span> len(nums) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">import</span> math</span><br><span class="line">            nf = math.factorial(n - <span class="number">1</span>)</span><br><span class="line">            i = (k - <span class="number">1</span>) // nf</span><br><span class="line">            k = (k - <span class="number">1</span>) % nf + <span class="number">1</span></span><br><span class="line">            n -= <span class="number">1</span></span><br><span class="line">            ans += str(nums.pop(i))</span><br><span class="line">        ans += str(nums.pop())</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：和上题一样无语。讨论区的python答案都不太行，提交结果里的高频可以。…while len(el) &gt; 1:…i = (k - 1) <strong>//</strong> nf; k = (k - 1) % nf <strong>+ 1</strong>…</p>
<h3 id="238-Product-of-Array-Except-Self-Medium"><a href="#238-Product-of-Array-Except-Self-Medium" class="headerlink" title="238. Product of Array Except Self (Medium)"></a><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. Product of Array Except Self (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:  [1,2,3,4]</span><br><span class="line">Output: [24,12,8,6]</span><br><span class="line">Note: Please solve it without division and in O(n).</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">productExceptSelf</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">        p = <span class="number">1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        ans = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            ans[i] = p</span><br><span class="line">            p *= nums[i]</span><br><span class="line">        p = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            ans[i] *= p</span><br><span class="line">            p *= nums[i]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>高频：这题取决于知道从左到右，再从右到左把元素乘一遍放到结果里这个方法</p>
<h2 id="Sliding-Window-滑动窗口"><a href="#Sliding-Window-滑动窗口" class="headerlink" title="Sliding Window 滑动窗口"></a>Sliding Window 滑动窗口</h2><h3 id="438-Find-All-Anagrams-in-a-String-Medium"><a href="#438-Find-All-Anagrams-in-a-String-Medium" class="headerlink" title="438. Find All Anagrams in a String (Medium)"></a><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. Find All Anagrams in a String (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.</span><br><span class="line">Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.</span><br><span class="line">The order of output does not matter.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">s: "cbaebabacd" p: "abc"</span><br><span class="line">Output:</span><br><span class="line">[0, 6]</span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is "cba", which is an anagram of "abc".</span><br><span class="line">The substring with start index = 6 is "bac", which is an anagram of "abc".</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">s: "abab" p: "ab"</span><br><span class="line">Output:</span><br><span class="line">[0, 1, 2]</span><br><span class="line">Explanation:</span><br><span class="line">The substring with start index = 0 is "ab", which is an anagram of "ab".</span><br><span class="line">The substring with start index = 1 is "ba", which is an anagram of "ab".</span><br><span class="line">The substring with start index = 2 is "ab", which is an anagram of "ab".</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findAnagrams</span><span class="params">(self, s: str, p: str)</span> -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        n, m = len(s), len(p)</span><br><span class="line">        <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">        pCounter = Counter(p)</span><br><span class="line">        sCounter = Counter(s[:m - <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m - <span class="number">1</span>, n):</span><br><span class="line">            si = i - m + <span class="number">1</span></span><br><span class="line">            sCounter[s[i]] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> pCounter == sCounter:</span><br><span class="line">                ans.append(si)</span><br><span class="line">            sCounter[s[si]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> sCounter[s[si]] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">del</span> sCounter[s[si]]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>面经：Amazon。注意sCounter[s[si]] -= 1需要减相应字母的计数，否则会产生bug。todo：也用sliding window的模板改下代码</p>
<h3 id="3-Longest-Substring-Without-Repeating-Characters-Medium"><a href="#3-Longest-Substring-Without-Repeating-Characters-Medium" class="headerlink" title="3. Longest Substring Without Repeating Characters (Medium)"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given a string, find the length of the longest substring without repeating characters.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "abcabcbb"</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is "abc", with the length of 3.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "bbbbb"</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is "b", with the length of 1.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: "pwwkew"</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is "wke", with the length of 3.</span><br><span class="line">             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">      l, cnt, window = <span class="number">0</span>, <span class="number">0</span>, collections.defaultdict(int)</span><br><span class="line">      res = <span class="number">0</span></span><br><span class="line">      <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">          window[c] += <span class="number">1</span></span><br><span class="line">          <span class="keyword">if</span> window[c] &gt; <span class="number">1</span>:</span><br><span class="line">              cnt += <span class="number">1</span></span><br><span class="line">          <span class="keyword">while</span> cnt &gt; <span class="number">0</span>:</span><br><span class="line">              sChar = s[l]</span><br><span class="line">              <span class="keyword">if</span> i - l &gt; res:</span><br><span class="line">                  res = i - l</span><br><span class="line">              <span class="keyword">if</span> window[sChar] &gt; <span class="number">1</span>:</span><br><span class="line">                  cnt -= <span class="number">1</span></span><br><span class="line">              window[sChar] -= <span class="number">1</span></span><br><span class="line">              l += <span class="number">1</span></span><br><span class="line">      <span class="keyword">return</span> max(res, len(s) - l)</span><br></pre></td></tr></table></figure>
<p>面经：Amazon。注意:…if i - l &gt; res:…</p>
<h3 id="76-Minimum-Window-Substring-Hard"><a href="#76-Minimum-Window-Substring-Hard" class="headerlink" title="76. Minimum Window Substring (Hard)"></a><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. Minimum Window Substring (Hard)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: S = "ADOBECODEBANC", T = "ABC"</span><br><span class="line">Output: "BANC"</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">If there is no such window in S that covers all characters in T, return the empty string "".</span><br><span class="line">If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minWindow</span><span class="params">(self, s: str, t: str)</span> -&gt; str:</span></span><br><span class="line">        mapping = collections.Counter(t)</span><br><span class="line">        window = collections.defaultdict(int)</span><br><span class="line">        l, tc, cnt = <span class="number">0</span>, len(mapping), <span class="number">0</span></span><br><span class="line">        ans = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i, c <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            window[c] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> mapping <span class="keyword">and</span> window[c] == mapping[c]:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> cnt == tc:</span><br><span class="line">                sChar = s[l]</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> ans <span class="keyword">or</span> i - l + <span class="number">1</span> &lt; len(ans):</span><br><span class="line">                    ans = s[l:i + <span class="number">1</span>]</span><br><span class="line">                window[sChar] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> sChar <span class="keyword">in</span> mapping <span class="keyword">and</span> window[sChar] &lt; mapping[sChar]:</span><br><span class="line">                    cnt -= <span class="number">1</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
<p>面经：Amazon。todo：总结一下 sliding window / substring search 模板，修改上题答案</p>
<h1 id="skipped"><a href="#skipped" class="headerlink" title="skipped"></a>skipped</h1><h2 id="DP-Dynamic-Programming-动态规划-1"><a href="#DP-Dynamic-Programming-动态规划-1" class="headerlink" title="DP Dynamic Programming 动态规划"></a>DP Dynamic Programming 动态规划</h2><h3 id="Best-Time-to-Buy-and-Sell-Stock-II-amp-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-II-amp-III" class="headerlink" title="Best Time to Buy and Sell Stock II &amp; III"></a>Best Time to Buy and Sell Stock II &amp; III</h3><h3 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h3><h3 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h3><h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><h3 id="240-Search-a-2D-Matrix-II-Medium"><a href="#240-Search-a-2D-Matrix-II-Medium" class="headerlink" title="240. Search a 2D Matrix II (Medium)"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/" target="_blank" rel="noopener">240. Search a 2D Matrix II (Medium)</a></h3><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="347-Top-K-Frequent-Elements-Medium"><a href="#347-Top-K-Frequent-Elements-Medium" class="headerlink" title="347. Top K Frequent Elements (Medium)"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener">347. Top K Frequent Elements (Medium)</a></h3><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="349-Intersection-of-Two-Arrays-Easy"><a href="#349-Intersection-of-Two-Arrays-Easy" class="headerlink" title="349. Intersection of Two Arrays (Easy)"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays/description/" target="_blank" rel="noopener">349. Intersection of Two Arrays (Easy)</a></h3><h3 id="350-Intersection-of-Two-Arrays-II-Easy"><a href="#350-Intersection-of-Two-Arrays-II-Easy" class="headerlink" title="350. Intersection of Two Arrays II (Easy)"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener">350. Intersection of Two Arrays II (Easy)</a></h3>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ahtang.com//2018/05/03/2018-五一假期日本大阪京都奈良-6-天-5-晚/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤包个人页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/03/2018-五一假期日本大阪京都奈良-6-天-5-晚/" itemprop="url">
                  2018 五一假期日本大阪京都奈良 6 天 5 晚
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-04 12:10:23" itemprop="dateCreated datePublished" datetime="2018-05-04T12:10:23+08:00">2018-05-04</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##前言</p>
<p>这次五一出行非常不易。 两个人都是平时很忙， 没空做功课， 一路上状况（坑）也很多。 非常感恩小仙女脾气好。 辛苦一路也没有什么抱怨。 圆满回到北京继续搬砖。</p>
<p>首先，五一出行就很贵。 小仙女的护照在元旦去泰国以后就过期了。 一直到出发前个把月才办到新护照。 订机票需要输入护照号， 拿到新护照才知道护照号。等到出发前三周左右小仙女拿到新办好的护照，机票已经没有太多选择了。 我们在去哪网买了一个往返价格￥2873 从韩国转机的红眼航班，毕竟五一，有这个价格已经是较便宜的了。但是，这里埋下出发前的巨大一个坑，随后会介绍。 由于我们没有做功课， 不是很确定要住哪里。 直到出发前两周不到才订了第一晚的酒店：Hotel Brighton City Osaka Kitahama。 住下来这家酒店性价比还是不错。后来听说京都比较好玩就在出发前三天订了三天京都的酒店。 Hotel MyStays Kyoto-Shijo。</p>
<h2 id="行程"><a href="#行程" class="headerlink" title="行程"></a>行程</h2><h3 id="4-月-28"><a href="#4-月-28" class="headerlink" title="4 月 28"></a>4 月 28</h3><h3 id="4-月-29"><a href="#4-月-29" class="headerlink" title="4 月 29"></a>4 月 29</h3><h3 id="4-月-30"><a href="#4-月-30" class="headerlink" title="4 月 30"></a>4 月 30</h3><h3 id="5-月-1"><a href="#5-月-1" class="headerlink" title="5 月 1"></a>5 月 1</h3><h3 id="5-月-2"><a href="#5-月-2" class="headerlink" title="5 月 2"></a>5 月 2</h3><h3 id="5-月-3"><a href="#5-月-3" class="headerlink" title="5 月 3"></a>5 月 3</h3><p>大阪吃吃吃， 买买买。然后回北京~</p>
<h4 id="住"><a href="#住" class="headerlink" title="住"></a>住</h4><p>Hotel Brighton City Osaka Kitahama 退房</p>
<p>####吃</p>
<p>大和屋，大丸百货 13 楼，地铁心斋桥站</p>
<p>####详细</p>
<p>上午睡了个懒觉，收拾好退房以后小仙女英明决定带着行李去心斋桥，行李寄存地铁，然后在心斋桥逛街。结果 700 日元的最大号柜子被人占了，只好租 500 日元第二大的柜子，发挥智慧硬塞了两个登机箱进去。 </p>
<p>出站后觉得应该先吃午饭，在点评上看中了家餐馆叫銀や， 结果跑到门口看到贴纸说五一长假不开/(ㄒoㄒ)/~~。 后来又看到一家大和屋，在大丸百货的 13 层。 这时才发现我们的箱子其实是存在地铁四ツ橋站了。。。心斋桥和四ツ橋站在地下有通道是通的。。。</p>
<p>大丸百货都是高级牌子， 大和屋门口站的是和服服务员， 门口装修讲究， 差点没敢进去。 但是想想既然来了， 吃吧😝。 两人含税约人民币￥810.6 </p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fqzq1yvdlwj31kw23vu0x.jpg"></p>
<p>第一道是海胆，鲍鱼刺身</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fqzpxtnj6yj31kw16pe81.jpg"></p>
<p>后面几道就不一一报菜名了（其实有些可能也说不上来）直接上图吧：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fqzpxq3903j31kw16okjl.jpg"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fqzpxss2k6j31kw16o7wi.jpg"></p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fqzpxor8hbj31kw16okjl.jpg"></p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fqzpxr8kqwj31kw16pe81.jpg"></p>
<p>吃完饭去看了一家墨镜店， 结果特别小。 然后就去四ツ橋站取行李，然后走地下通道前往心斋桥坐地铁去难波站</p>
<p>bic camera 难波店就在地铁站旁，看中富士的一个微单很久了，一直没舍得买。这次木有忍住诱惑。买了 X-T 20 的机身和 35mm 2f WR 的镜头，凭护照免税，刷信用卡可以再打 95 折，折后机身比美亚便宜一点点。 镜头要便宜不少。 镜头一般都要 399 美金，很少打折。我看了下淘宝这款相机在国内卖的要贵不少。唯一的遗憾是赶飞机没有找打折券， 不知道能不能更便宜。不过总的来说价钱方面还是满意的。</p>
<p>买完相机就坐南海难波站坐地铁去关西机场了。</p>
<p>到了关西机场以后简直开启狼狈买买买模式。本来预留了起飞前 3 个小时到机场，由于午饭加买相机花的时间比较久，最后到机场时距航班起飞仅剩约两个半小时的时间。 一顿买到登机时间才往登机口过去。</p>
<p>到了香港有约两小时的转机时间， 本以为转机还能在香港买买买一下。 但是有几件化妆品被转机处安检告知需要托运。 只好狼狈填表入境香港，然后去出发层办托运， 重新安检， 吭哧到登机口也要登机了。 </p>
<p>凌晨两点多到达北京。 出关，拿行李， 打车， 凌晨四点到家。 圆满结束五一假期。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次旅行总结了如下几点经验教训：</p>
<ol>
<li>不要在去哪儿上买机票！如果从韩国转机要多留个心眼搞清楚要不要韩国签证，不同的城市要求不一样。</li>
<li>相机要在第一天买！这样这次旅行就可以用新相机啦</li>
<li>KIX DUTY FREE 免税店从安检出来以后两侧都有， 卖一样的东西。 左侧人较少，右侧简直是菜市场。 可能飞国内的航班大多在右边的登机口。。。我们很不幸的在右边的免税店 “抢购” 了一番，买完就到登机时间了，赶到登机口略狼狈。有几个大包装的化妆品如没有用袋子封起来要告知收银员需要转机。 不然就会跟我们一样面临要么出海关重新办安检， 如果转机时间紧张就要放弃买的东西的窘境。。。</li>
</ol>
<p>插入 KIX 地形图片</p>
<ol start="4">
<li>SK II 的神仙水在日上更合算：插入图片，日本收据 v.s. 日上照片。</li>
</ol>
<h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>大阪比北京要陈旧， 地铁站，地铁车辆，甚至自动售票机和检票闸机都不如北京的新 / 先进。街上的出租车大多是感觉像 80-90 年代的丰田皇冠车型。 极少数普锐斯和较新的车型。</p>
<p>虽然略旧，可是日本确实很干净。街上垃圾桶很少， 据说大家都是把垃圾带回家扔。 实际上有些便利店的门口和地铁里会有少数垃圾桶。</p>
<p>很多细节上做得很好，比如说京都酒店的浴室不是干湿分开的， 镜子照到脸的部分就有电加热，不会起雾。各个地方的标志都非常清楚， 跟着标志走基本都不太会找不到地方。出租车的车门是自动的， 每次看人上下车都要惊叹一番，哈哈哈，比较没见过世面。</p>
<p>第一家烤肉店的夹子放在桌上， 夹子尖不会碰到桌子， 插入图片</p>
<p>服务确实不错， 服务人员的态度都特别好。</p>
<p>要 100% 精确比较难， 执行上也会比较累。 80% 就差不多了。 难免有一两顿饭会踩到坑。 考验两个人的相处方式。</p>
<p>两个人还是要有一个人对旅程上心一点。 不然的话像韩国签证这种事情就会造成一定的经济损失。 没有做好功课需要做好经济损失的心里准备。 在计算机领域有一个说法叫用空间换时间。 在现实生活中更多的选择是拿钱换时间。 这个世界上很多东西钱买不来。 所以能用钱解决的问题的时候还不是最糟的情况。</p>
<p>旅行的意义在于走上这趟旅程之前并不知道这段旅程能带来什么。 而经过这此旅程之后我们对从前未知的世界和我们双方又增进了一份了解。 走出我们的舒适区，发现平时生活中彼此不易露出的一面。 一起解决一些坑。 发现遇到困难时彼此交流的模式。 这个过程中获得了远比为这些坑所付出的成本高得多的回报。 自我心中， 这就是旅行的意义。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ahtang.com//2018/04/21/一个简单的以太坊智能合约开发练习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤包个人页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/21/一个简单的以太坊智能合约开发练习/" itemprop="url">
                  一个简单的以太坊智能合约开发练习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-22 14:40:19" itemprop="dateCreated datePublished" datetime="2018-04-22T14:40:19+08:00">2018-04-22</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>以太坊 V 神在一个采访中说过， 世界上现在分成两种人， 一种是知道什么是比特币的， 一种是不知道的。 对于知道什么是比特币的人， 解释以太坊是什么要相对容易一些。 就是比特币基础上再加了一个智能合约。 对于不知道什么是比特币的， 可以先在网上科普一下。 </p>
<p>最近几天把 hackernoon 上面的一篇以太坊智能合约开发指南教程跑了一遍。 开发的例子灵感是来自于一部电影<a href="https://movie.douban.com/subject/4924142/" target="_blank" rel="noopener">时间规划局</a>。 一部褒贬不一的电影， 但是我挺喜欢的， 题材不错。 就是未来世界，钱就是时间。 所有人的身体都可以定格在 25 岁， 能活多久取决于左手上的计时器。 穷人就得每天打工赚取活下去的时间， 富人就有很多时间 / 钱。 </p>
<p>说回智能合约， 这个智能合约就是很简单的比大小。 两个玩家， 在任何一轮玩家一号打入智能合约的钱是玩家二号打入的两倍或以上的话， 游戏结束，合约里所有的钱就归玩家一号。 反之亦然。 如两倍以内， 则进入下一轮。 每轮双方只能打一次钱进入合约。</p>
<p>我比较喜欢这个教程的第一点是， 一上来不要求装一大堆框架和 SDK，折腾半天也没开始开发。 简单粗暴， 先来智能合约代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Wrestling &#123;</span><br><span class="line">  address public playerA;</span><br><span class="line">  address public playerB;</span><br><span class="line"></span><br><span class="line">  bool public playerAPlayed;</span><br><span class="line">  bool public playerBPlayed;</span><br><span class="line"></span><br><span class="line">  uint private playerADeposit;</span><br><span class="line">  uint private playerBDeposit;</span><br><span class="line"></span><br><span class="line">  bool public gameOver;</span><br><span class="line">  address public theWinner;</span><br><span class="line">  uint public prize;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    playerA = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function registerAnOpponent() public &#123;</span><br><span class="line">    require(playerB == address(0));</span><br><span class="line">    playerB = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function wrestle() public payable &#123;</span><br><span class="line">    require(!gameOver &amp;&amp; (msg.sender == playerA || msg.sender == playerB));</span><br><span class="line"></span><br><span class="line">    if (msg.sender == playerA) &#123;</span><br><span class="line">      require(!playerAPlayed);</span><br><span class="line">      playerAPlayed = true;</span><br><span class="line">      playerADeposit = playerADeposit + msg.value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      require(!playerBPlayed);</span><br><span class="line">      playerBPlayed = true;</span><br><span class="line">      playerBDeposit = playerBDeposit + msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (playerAPlayed &amp;&amp; playerBPlayed) &#123;</span><br><span class="line">      if (playerADeposit &gt; 2 * playerBDeposit) &#123;</span><br><span class="line">        endGame(playerA);</span><br><span class="line">      &#125; else if (playerBDeposit &gt; 2 * playerADeposit) &#123;</span><br><span class="line">        endGame(playerB);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        endRound();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function endGame(address winner) internal &#123;</span><br><span class="line">    gameOver = true;</span><br><span class="line">    theWinner = winner;</span><br><span class="line">    prize = playerADeposit + playerBDeposit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function endRound() internal &#123;</span><br><span class="line">    playerAPlayed = false;</span><br><span class="line">    playerBPlayed = false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一行 pragma solidity ^0.4.18; 是给编译器看的， 意思是用 0.4.18 版本以上的 solidity 编译器， 基本可以忽略。 后面的智能合约，如有任何现代语言的编程基础的话还是比较好懂的。 谁通过创造器（constructor）创造了合约谁就是一号玩家 playerA， playerA 和 playerB 的类型都是 address，根据 solidity 的<a href="https://solidity.readthedocs.io/en/develop/types.html#address" target="_blank" rel="noopener">官方文档</a>，address 是一个 20 个字节放以太坊地址的类型。</p>
<p>合约创造以后，二号玩家可以调用 registerAnOpponent() 来注册。 require(playerB == address(0)); 的意思是要求二号玩家还没有被注册过（地址为 0）。合约的主体是 wrestle()，payable 的意思是这个方法可以接受付款。 后面的代码就是实现上面说的游戏的逻辑。 语法和现代语言 （java，javascript，python）基本没有什么区别。 </p>
<p>至此， 智能合约的开发第一步就完成了， 神奇吧。 你可以把以上的代码复制粘贴到 solidity 的 IDE 中：<a href="http://remix.ethereum.org/" target="_blank" rel="noopener">http://remix.ethereum.org/</a>。然后点击 start to compile，一切顺利的话，你能看到 Wrestling 是绿色的， 表示编译没问题。如下图所示：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fqlhicpf8bj30v40dl77d.jpg"></p>
<p>到这里其实合约还有一个问题。 就是如果赢了的话，奖金如何取出来？我们需要加一个取钱的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function withDraw() public &#123;</span><br><span class="line">  require(gameOver &amp;&amp; msg.sender == theWinner);</span><br><span class="line">  uint amount = prize;</span><br><span class="line">  prize = 0;</span><br><span class="line">  msg.sender.transfer(amount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用了一个为了安全的写法， 先把 prize 赋值为 0， 再把钱发给赢家。 在这个 DApp 不是那么关键， 毕竟钱都是给赢家的。 但是如果合约里的钱是要分批给不同的人这个写法就非常重要了， 如果不这么写，有人可以利用一些手段反复调用这个方法，直到合约里的钱都被取光，还是很可怕的。</p>
<p>有了这些以后，就可以将合约部署到测试网络上试用一下了。 </p>
<p>先下载一个模拟测试网络的工具 Ganache， 在终端任何目录下执行以下命令均可，全局安装 ganache-cli：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g ganache-cli</span><br></pre></td></tr></table></figure>
<p>下一步将写好的合约放到测试网络上，看了好几种方法， 比较下来我认为比较合适的是使用 Truffle 这个框架。 直接用 Node / Web3.js 对我来说还是太原始了一点。 Node / js 大牛可以直接跳过剩下的内容， 移步 <a href="https://medium.com/@mvmurthy/full-stack-hello-world-voting-ethereum-dapp-tutorial-part-1-40d2d0d807c2" target="_blank" rel="noopener">Full Stack Hello World Voting Ethereum Dapp Tutorial — Part 1</a> 有详细的直接用 Node / Web3.js 调用智能合约的介绍。 </p>
<p>先安装 Truffle：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g truffle</span><br></pre></td></tr></table></figure>
<p>为项目创建一个目录。 进入这个目前是空的目录，执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle init</span><br></pre></td></tr></table></figure>
<p>Truffle 会创建几个目录。 在 contracts 目录下创建文件 Wrestling.sol，将上面的合约内容粘贴到 Wrestling.sol 中。 到这里，这个文件内容应该是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.18;</span><br><span class="line"></span><br><span class="line">contract Wrestling &#123;</span><br><span class="line">  address public playerA;</span><br><span class="line">  address public playerB;</span><br><span class="line"></span><br><span class="line">  bool public playerAPlayed;</span><br><span class="line">  bool public playerBPlayed;</span><br><span class="line"></span><br><span class="line">  uint private playerADeposit;</span><br><span class="line">  uint private playerBDeposit;</span><br><span class="line"></span><br><span class="line">  bool public gameOver;</span><br><span class="line">  address public theWinner;</span><br><span class="line">  uint public prize;</span><br><span class="line"></span><br><span class="line">  constructor() public &#123;</span><br><span class="line">    playerA = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function registerAnOpponent() public &#123;</span><br><span class="line">    require(playerB == address(0));</span><br><span class="line">    playerB = msg.sender;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function wrestle() public payable &#123;</span><br><span class="line">    require(!gameOver &amp;&amp; (msg.sender == playerA || msg.sender == playerB));</span><br><span class="line"></span><br><span class="line">    if (msg.sender == playerA) &#123;</span><br><span class="line">      require(!playerAPlayed);</span><br><span class="line">      playerAPlayed = true;</span><br><span class="line">      playerADeposit = playerADeposit + msg.value;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      require(!playerBPlayed);</span><br><span class="line">      playerBPlayed = true;</span><br><span class="line">      playerBDeposit = playerBDeposit + msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (playerAPlayed &amp;&amp; playerBPlayed) &#123;</span><br><span class="line">      if (playerADeposit &gt; 2 * playerBDeposit) &#123;</span><br><span class="line">        endGame(playerA);</span><br><span class="line">      &#125; else if (playerBDeposit &gt; 2 * playerADeposit) &#123;</span><br><span class="line">        endGame(playerB);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        endRound();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function endGame(address winner) internal &#123;</span><br><span class="line">    gameOver = true;</span><br><span class="line">    theWinner = winner;</span><br><span class="line">    prize = playerADeposit + playerBDeposit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function endRound() internal &#123;</span><br><span class="line">    playerAPlayed = false;</span><br><span class="line">    playerBPlayed = false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一步在 “migrations” 目录下建文件 “2_deploy_contracts.js” 用来将合约部署到区块链上。 代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Wrestling = artifacts.require(<span class="string">"./Wrestling.sol"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">	deployer.deploy(Wrestling);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>接下来的步骤我没有在 windows 上面验证过， mac 的话需要在项目根目录下修改 “truffle.js” 文件，内容如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// See &lt;http://truffleframework.com/docs/advanced/configuration&gt;</span></span><br><span class="line">  <span class="comment">// for more about customizing your Truffle configuration!</span></span><br><span class="line">  networks: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      host: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">      port: <span class="number">7545</span>,</span><br><span class="line">      network_id: <span class="string">"*"</span> <span class="comment">// Match any network id</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>据说 windows 下需要删掉“truffle.js” 将以上内容放入 “truffle-config.js”。好了， 下面就要发车了。</p>
<p>先启动模拟测设网络的工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ganache-cli -p 7545</span><br></pre></td></tr></table></figure>
<p>会产生 10 个以太坊账号，每个里面有 100 个 Ether。 效果如下：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fqll8yw1u6j30fv0ey0vs.jpg"></p>
<p>然后编译和部署合约到上面这个假以太坊网络中去，保留上面的终端， 开一个命令在项目的根目录处执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">truffle compile</span><br><span class="line">truffle migrate --network development</span><br></pre></td></tr></table></figure>
<p>第一句话是编译合约，作用和上面 remix IDE 里有的编译功能是一样的， 第二句话是将编译好的合约部署到测试网上。测试网的参数在 ”truffle.js” 上配好了。</p>
<p>部署后执行 truffle 的终端显示如下：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1fqp4zomgtqj30fy08ktah.jpg"></p>
<p>ganache 的终端显示如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fqp4zp1u2zj30gh0gsjtt.jpg"></p>
<p>值得注意的是上面两个终端里 Wresling: 0x… 和 contract created: 0x… 的地址是一致的。</p>
<p>细心的同学会注意到 Gas usage，以太坊上的运算和交易都需要付旷工费。具体 gas 怎么算可以上网查一下， 有不少相关的中文资料。</p>
<p>接下来可以和部署好的合约互动了。 在 truffle 的终端输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truffle console --network development</span><br></pre></td></tr></table></figure>
<p>第一步可以查一下账户的余额：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.fromWei(web3.eth.getBalance(web3.eth.accounts[1]))</span><br></pre></td></tr></table></figure>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fqp6ez4ysgj30fu02lmxp.jpg"></p>
<p>合约是默认 accounts[0] 部署的，ganache 默认的 gas price 是 100,000,000,000 或者 100 gwei，部署这个合约花掉了 1,068,066 的 gas。加上余额，就能对上每个账号默认 100 个 ether 的量了。</p>
<p>接下来就可以开始调用合约的方法了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">playerA = web3.eth.accounts[0]</span><br><span class="line">playerB = web3.eth.accounts[1]</span><br><span class="line">Wrestling.deployed().<span class="keyword">then</span>(inst =&gt; &#123; WrestlingInstance = inst &#125;)</span><br><span class="line">WrestlingInstance.registerAsAnOpponent(&#123;from: playerB&#125;)</span><br><span class="line">WrestlingInstance.wrestle(&#123;from: playerA, value: web3.toWei(2, <span class="string">"ether"</span>)&#125;)</span><br><span class="line">WrestlingInstance.wrestle(&#123;from: playerB, value: web3.toWei(3, <span class="string">"ether"</span>)&#125;)</span><br><span class="line">WrestlingInstance.wrestle(&#123;from: playerA, value: web3.toWei(5, <span class="string">"ether"</span>)&#125;)</span><br><span class="line">WrestlingInstance.wrestle(&#123;from: playerB, value: web3.toWei(20, <span class="string">"ether"</span>)&#125;)</span><br></pre></td></tr></table></figure>
<p>默认合约的调用者是 accounts[0]，根据合约的代码就是 playerA 了。 这里玩了两轮。 第二轮符合游戏结束的条件。 </p>
<p>到这里这个合约基本就开发完成了。 下一步是加上几个事件的代码。 并配上一个前端网页显示相关的信息。 </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ahtang.com//2018/04/18/hello-world-round-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤包个人页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/hello-world-round-2/" itemprop="url">
                  世界你好
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-19 00:26:39" itemprop="dateCreated datePublished" datetime="2018-04-19T00:26:39+08:00">2018-04-19</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>刚要提笔却又觉得无从说起。 还是用我擅长的流水账手法吧。 从很多年前大学甚至高中开始就想有自己的个人主页。 事实是这些年确实都有。 但是由于很多原因没有坚持写。 我爸一直鼓励我多写。 而基于多年的学校教育和我对自身学习方法的认知， 如果我不记笔记， 知识就没有内化，没有充分理解。 写到这里，我想起了大学毕业的一个小遗憾。 当时从比利时搬家回上海， 为了轻车简从，把大学期间打印的讲义和笔记都扔掉了， 堆砌起来目测可能有将近一立方米， 可惜没有照片，现在也是口说无凭。 只能作为永远的遗憾和后辈们引以为鉴的教训了。 </p>
<p>一直没有去写的另一个原因是， 写的东西都零散的散落在互联网的各个阴暗角落。 从 blogger 到 msn space 再到简书。互联网告诉我们，没有任何的平台是永生的。 那为什么要为了这种转瞬即逝的东西去耗费时间精力去写呢？</p>
<p>很惭愧，作为一个科班出身的人， 一直到最近我才开始较频繁的使用程序员神器之一 github。 发现这么些年来， 加入版本管理和云存储的东西永生的几率是最大的。 移动硬盘可能摔坏， 优盘可能丢失。 </p>
<p>长久以来我都想把写的东西弄到版本管理里去。 直到现在才有时间去梳理这些一直想做却因为时间和借口没有做的事情。</p>
<p>这篇文是我用 markdown 真正意义上写的第一篇。 其实一点儿 markdown 的语法都没用到， 而我知道的也就是最基本的标题那些。然而它的意义在于， 这篇文存在 github 上，github 如果倒闭了， 我还可以转到下一个版本管理的平台上。不依赖 github 提供迁移的工具。这一点很重要， 其他的平台如 msn space 如果迁移<del>图片的链接</del>排版会乱的话相当于之前写的都白费了。 </p>
<blockquote>
<p>update: 在写这篇的时候发现 hexo 传图非常不好用， 我现在用的是本地的 markdown 编辑器 Tyora， 如果既要 Typora 里能出图， 又要 index 和点进文章里如： yourdomainname.com/2018/04/19/article-title/ 以后能出图就要依赖图床。呃😓…没想到这么多年还是没有一个彻底的解决方案。 先用图床吧。</p>
</blockquote>
<p>之前有用 Jekyll 和 Octopress， 其中 octopress 的主题 greyshade 最令我满意。 截图如下：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fqi0w67te1j30vf0i2gpa.jpg"></p>
<blockquote>
<p>update: 看了下 github 上 greyshade 的例子， 基本上都被 hexo 和 next 抢走了</p>
</blockquote>
<p>然而， Jekyll 是 Ruby On Rails 写的， 我不熟悉 Ruby， 配置实在是搞不定。 Octopress 维护好像不是很积极了。</p>
<h2 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h2><p>最近发现基于 node.js 的 Hexo， 还有这个主题 next。基于 js 的还是比基于 Ruby 的好上手得多。 两个项目的维护好像都还比较及时。 以后可能还会换静态页面的解决方案， 但是， 文章都会一直用 github 保存下去。 我很满意。</p>
<h2 id="区块链-Hackathon"><a href="#区块链-Hackathon" class="headerlink" title="区块链 Hackathon"></a>区块链 Hackathon</h2><p>最近在看区块链的机会， 6 月 9 号在北京有一个 SegmentFault 办的 hackathon， 我组了个队， 背景都是硅谷海归，还有 2-3 个参队名额。 希望有时间有兴趣的小伙伴联系我一起玩一下。 </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://www.linkedin.com/in/alantang" target="_blank" title="LinkedIn"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://github.com/alant" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/users/3781358/alant" target="_blank" title="StackOverflow"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/tang-hao-3" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan</span>

  

  
</div>








  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
