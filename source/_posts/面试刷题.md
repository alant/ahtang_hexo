---
title: 面试刷题
date: 2018-09-13 21:17:00
tags:
---

# Binary Search & LogN Algorithm

比O(n)更优的时间复杂度几乎只能是O(logn)的二分法
二分法模板: start + 1 < end; start + (end - start) / 2; A[mid] ==, <, >; A[start] A[end] ? target

### [704. Binary Search (Easy)](https://leetcode.com/problems/binary-search/description/)
[lintcode's version](https://www.lintcode.com/problem/classical-binary-search/description)
```html
Find any position of a target number in a sorted array. Return -1 if target does not exist.

Example
Given [1, 2, 2, 4, 5, 5].

For target = 2, return 1 or 2.

For target = 5, return 4 or 5.

For target = 6, return -1.

Challenge
O(logn) time
```

```python
class Solution:
    """
    @param: nums: An integer array sorted in ascending order
    @param: target: An integer
    @return: An integer
    """
    def findPosition(self, nums, target):
        # write your code here
        if (len(nums) == 0):
          return -1
        start, end = 0, len(nums) - 1
        while (start + 1 < end):
            mid = start + (end - start) // 2     
            if (nums[mid] == target):
                return mid
            elif (nums[mid] < target):
                start = mid
            else:
                end = mid    
        if (nums[start] == target):
            return start
        if (nums[end] == target):
            return end
        return -1

```
总结：背好模板，lintcode 的 test case 包含空输入数组，需要 python3 的 // 整除运算符才能过

二刷：
```python
class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if len(nums) == 0 or (len(nums) == 1 and nums[0] != target):
            return -1
        return self.helper(nums, target, 0, len(nums) - 1)
    def helper(self, nums, target, start, end):
        if (start > end):
            return -1
        if (start + 1 == end):
            if nums[end] == target:
                return end
            if nums[start] == target:
                return start
            else:
                return -1
        mid = start + (end - start) // 2
        if (nums[mid] == target):
            return mid
        elif (nums[mid] < target):
            start = mid
        else:
            end = mid
        return self.helper(nums, target, start, end)
```
总结：不背模板也能写。 但是写出来不如模板的优雅。如果递归调用前面不加 return 的话，还会发生不 return 的情况

### [LinC 14. First Position of Target (Easy)](https://www.lintcode.com/problem/first-position-of-target/description)
```html
Description
For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.

If the target number does not exist in the array, return -1.

Have you met this question in a real interview?  
Example
If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.

Challenge
If the count of numbers is bigger than 2^32, can your code work properly?
```
思路：找到了不要 return，扔掉大的一半，继续找
```python
class Solution:
    """
    @param nums: The integer array.
    @param target: Target to find.
    @return: The first position of target. Position starts from 0.
    """
    def binarySearch(self, nums, target):
        # write your code here
        if (len(nums) == 0):
            return -1
        start, end = 0, len(nums) - 1
        while (start + 1 < end):
            mid = start + (end - start) // 2
            if (nums[mid] >= target):
                end = mid
            else:
                start = mid
        if (nums[start] == target):
            return start
        if (nums[end] == target):
            return end
        return -1
```
总结：背好模板，模板 v5

### [278. First Bad Version (Easy)](https://leetcode.com/problems/first-bad-version/description/)
```html
You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

Example:

Given n = 5, and version = 4 is the first bad version.

call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true

Then 4 is the first bad version.
```
思路：前面 first position of target 的变体，可以不做

```python
# The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution(object):
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        start, end = 0, n
        while (start + 1 < end):
            mid = start + (end - start) // 2
            if (isBadVersion(mid)):
                end = mid
            else:
                start = mid
        if (isBadVersion(start)):
            return start
        if (isBadVersion(end)):
            return end
        return -1
```
总结：可不做

二刷：
```python
# The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 1 if isBadVersion(1) else -1
        return self.helper(1, n)
    def helper(self, start, end):
        if start + 1 == end:
            return start if isBadVersion(start) else end
        mid = start + (end - start) // 2
        if isBadVersion(mid):
            end = mid
        else:
            start = mid
        return self.helper(start, end)
```
总结：递归思维更自然。二刷之前没有看模板。模板大法更普适

### [34. Find First and Last Position of Element in Sorted Array (Medium)](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
```html
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
```
思路：二分法找 Target, 两次二分法，一次找左边界，一次找右边界
```python
class Solution(object):
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        ans = [-1, -1]
        if len(nums) == 0:
            return ans
        l, r = 0, len(nums) - 1
        # 找左边界
        while l + 1 < r:
            mid = l + (r - l ) // 2
            if nums[mid] < target:
                l = mid
            else:
                r = mid

        if nums[l] == target:
            ans[0] = l
        elif nums[r] == target:
            ans[0] = r
        else:
            return ans

        # 找右边界
        r = len(nums) - 1
        while l + 1 < r:
            mid = l + (r - l) // 2
            if nums[mid] <= target:
                l = mid
            else:
                r = mid
        if nums[r] == target:
            ans[1] = r
        elif nums[l] == target:
            ans[1] = l
        return ans
```
总结：按今天的水平，写的时候注意 while 的终止条件是 while l + 1 < r (l, r 不要重合就终止循环)。 两年多前写了稍微更简洁些的版本。可以回头再看看能不能写得出。

二刷：
```python
class Solution:
    def searchRange(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """

        if len(nums) == 0:
            return [-1, -1]

        if len(nums) == 1:
            return [0, 0] if nums[0] == target else [-1, -1]

        start, end = 0, len(nums) - 1
        while (start + 1 < end):
            mid = start + (end - start) // 2
            if nums[mid] == target:
                end = mid
            if nums[mid] < target:
                start = mid
            if nums[mid] > target:
                end = mid
        res1 = end if nums[end] == target else -1
        res1 = start if nums[start] == target else res1
        if res1 == -1:
            return [-1, -1]

        start, end = res1, len(nums) - 1
        while(start + 1 < end):
            mid = start + (end - start) // 2
            if nums[mid] == target:
                start = mid
            if nums[mid] < target:
                start = mid
            if nums[mid] > target:
                end = mid
        res2 = start if nums[start] == target else -1
        res2 = end if nums[end] == target else res2
        if res2 == -1:
            return [res1, res1]
        else:
            return [res1, res2]
```
总结： 凭借模板大法战胜 100% 的 python 选手。
高频：...if **nums[mid] == target**: r = **mid**...res1 = r ... res1 = l ...else res1; if res1 == -1: return [-1, -1]...res2 = l ... res2 = r ...else res2; if ...: return [res1, res1]...

### [LinC 61. Search for a Range (Medium)](https://www.lintcode.com/problem/search-for-a-range/description)
```html
Given a sorted array of n integers, find the starting and ending position of a given target value.

If the target is not found in the array, return [-1, -1].

Example
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].

Challenge
O(log n) time.
```
思路：找一个数的第一次和最后一次出现的 index
```python
class Solution:
    """
    @param A: an integer sorted array
    @param target: an integer to be inserted
    @return: a list of length 2, [index1, index2]
    """
    def searchRange(self, A, target):
        # write your code here
        firstO, lastO = -1, -1
        if len(A) == 0:
            return [firstO, lastO]
        start, end = 0, len(A) - 1
        while (start + 1 < end):
            mid = start + (end - start) // 2
            if (A[mid] < target):
                start = mid
            else:
                end = mid
        if (A[end] == target):
            firstO = end        
        if (A[start] == target):
            firstO = start
        start, end = 0, len(A) - 1
        while (start + 1 < end):
            mid = start + (end - start) // 2
            if (A[mid] <= target):
                start = mid
            else:
                end = mid
        if (A[start] == target):
            lastO = start
        if (A[end] == target):
            lastO = end
        return [firstO, lastO]
```
总结：注意检查空输入！

### [852. Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/description/)
[LinC 585. Maximum Number in Mountain Sequence (Medium)](https://www.lintcode.com/problem/maximum-number-in-mountain-sequence/description)
Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.
Example
Given nums = [1, 2, 4, 8, 6, 3] return 8
Given nums = [10, 9, 8, 7], return 10

思路：切一刀，判断递增就扔左边，递减就扔右边， 不然就找到了中点
二刷：
```python
class Solution:
    def peakIndexInMountainArray(self, A):
        """
        :type A: List[int]
        :rtype: int
        """
        start, end = 0, len(A) - 1
        while start + 1 < end:
            mid = start + (end - start) // 2
            if A[mid - 1] < A[mid] < A[mid + 1]:
                start = mid
            elif A[mid - 1] > A[mid] > A[mid + 1]:
                end = mid
            else:
                return mid
        return start if A[start] > A[end] else end
```
总结：二刷写法跟一刷一样，哪怕是简单的题，题要看清楚， mid min 不要拼错

### [162. Find Peak Element (Medium)](https://leetcode.com/problems/find-peak-element/description/)
A peak element is an element that is greater than its neighbors.
Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that nums[-1] = nums[n] = -∞.

Example 1:
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.

Example 2:
Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5
Explanation: Your function can return either index number 1 where the peak element is 2,
             or index number 5 where the peak element is 6.
Note:
Your solution should be in logarithmic complexity.
```python
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        l, r = 0, len(nums) - 1
        while l + 1 < r:
            mid = l + (r - l) // 2
            if nums[mid - 1] < nums[mid] < nums[mid + 1]:
                l = mid
            elif nums[mid - 1] < nums[mid] > nums[mid + 1]:
                return mid
            else:
                r = mid
        return r if nums[l] < nums[r] else l
```
面经：Quora。关键要知道切中点，如果是///向上，则顶点在右，如果/^\则找到顶点，否则顶点在左

### [74. Search a 2D Matrix (Medium)](https://leetcode.com/problems/search-a-2d-matrix/description/)
```html
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
Example 1:

Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true
Example 2:

Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
```
二刷：
```python
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return False
        rows, cols = len(matrix) - 1, len(matrix[0]) - 1
        startR, endR = 0, rows
        while startR + 1 < endR:
            midR = startR + (endR - startR) // 2
            if matrix[midR][0] < target:
                startR = midR
            elif matrix[midR][0] > target:
                endR = midR
            else:
                return True
        if startR < endR:
            if matrix[startR][cols] < target:
                startR = endR
        startC, endC = 0, cols
        while startC + 1 < endC:
            midC = startC + (endC - startC) // 2
            if matrix[startR][midC] < target:
                startC = midC
            elif matrix[startR][midC] > target:
                endC = midC
            else:
                return True
        return False if matrix[startR][startC] != target and matrix[startR][endC] != target else True
```
高频：
```python
class Solution:
    def searchMatrix(self, matrix, target):
        """
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        """
        m = len(matrix)
        if m == 0:
            return False
        n = len(matrix[0])
        if n == 0:
            return False
        rs, re = 0, m - 1
        while rs + 1 < re:
            rm = rs + (re - rs) // 2
            if matrix[rm][0] < target:
                rs = rm
            elif matrix[rm][0] > target:
                re = rm - 1
            else:
                return True
        if matrix[rs][n - 1] < target:
            rs = re
        return True if target in matrix[rs] else False
```
1总结：注意检查空输入
2总结：有两种空情况需要判断 [] 和 [[]]，击败 100% python3 选手。。。
高频：记住二分查找的模板：...s + 1 < e...。注意判断...if **matrix[rs][n - 1] <** target:...

### [153. Find Minimum in Rotated Sorted Array (Medium)](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/)
```html
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

You may assume no duplicate exists in the array.

Example 1:
Input: [3,4,5,1,2]
Output: 1

Example 2:
Input: [4,5,6,7,0,1,2]
Output: 0
```
思路：找 pivot，pivot > 0 时返回 nums[pivot + 1]。找 pivot 时,如果 mid < start, 扔 end， 如果 mid > start 扔 start
```python
class Solution:
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if (nums[0] < nums[len(nums) - 1]):
            return nums[0]
        start, end = 0, len(nums) - 1
        while (start + 1 < end):
            mid = start + (end - start) // 2
            if (nums[mid] < nums[start]):
                end = mid
            else:
                start = mid
        return nums[end]
```
总结：应改为 Easy 难度的题。
Follow up: 如果有重复的数? 无法保证在 Log(N) 的时间复杂度内解决 例子:[1,1,1,1,1....,1] 里藏着一个 0.最坏情况下需要把每个位置上的1都看一遍，才能找到最后一个有0 的位置. 考点:能想到这个最坏情况的例子

### [33. Search in Rotated Sorted Array (Medium)](https://leetcode.com/problems/search-in-rotated-sorted-array/description/)
```html
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm's runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
```
思路：第一感觉是得知道 pivot 在哪，有 pivot 一侧不能随便扔，但是更优的方法是查单调的侧是否可以扔
```python
class Solution:
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if len(nums) == 0:
            return -1
        start, end = 0, len(nums) - 1
        while (start + 1 < end):
            mid = start + (end - start) // 2
            if nums[start] < nums[mid]:
                if nums[start] <= target <= nums[mid]:
                    end = mid
                else:
                    start = mid
            else:
                if nums[mid] <= target <= nums[end]:
                    start = mid
                else:
                    end = mid
        if nums[start] == target:
            return start
        if nums[end] == target:
            return end
        return -1    
```
总结： 注意 [1, 3, 5] target 为 1 这种边界条件， 判断 target 在单调这边需要加等号

二刷：
```python
class Solution:
    def search(self, nums: 'List[int]', target: 'int') -> 'int':
        if len(nums) == 0:
            return -1
        if len(nums) == 1:
            return 0 if nums[0] == target else -1
        start, end = 0, len(nums) - 1
        while start + 1 < end:
            mid = start + (end - start) // 2
            if nums[mid] == target:
                return mid
                # pivot 在左
            elif nums[mid] < nums[start]:
                if nums[mid] < target <= nums[end] :
                    start = mid + 1
                else:
                    end = mid - 1
                # piviot 在右
            else:
                if nums[mid] > target >= nums[start]:
                    end = mid - 1
                else:
                    start = mid + 1
        if nums[start] == target:
            return start
        if nums[end] == target:
            return end
        return -1
```
总结：判断是否保留单调一边不能只看 nums[mid], 扔一侧的时候可以多扔一个 mid + 1 或 mid - 1
高频：...while **l + 1** < r...if nums[mid] **<** nums[l]: if **nums[mid] < target <= nums[r]**: ...

### [81. Search in Rotated Sorted Array II (Medium)](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)
```html
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).

You are given a target value to search. If found in the array return true, otherwise return false.

Example 1:

Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:

Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
Follow up:

This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.
Would this affect the run-time complexity? How and why?
```
```python
class Solution:
    def search(self, nums: List[int], target: int) -> bool:
        if len(nums) == 0:
            return False
        l, r = 0, len(nums) - 1
        while l + 1 < r:
            mid = l + (r - l) // 2
            if nums[mid] == target:
                return True
            if nums[l] < nums[mid]:
                if nums[l] <= target < nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
            elif nums[l] > nums[mid]:
                if nums[mid] < target <= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
            else:
                l += 1
        if nums[l] == target or nums[r] == target:
            return True
        return False
```
高频：注意r = len(nums) - 1，判断nums[mid] == nums[l] 的情况下l += 1

### [69. Sqrt(x) (Easy)](https://leetcode.com/problems/sqrtx/)
```html
Implement int sqrt(int x).

Compute and return the square root of x, where x is guaranteed to be a non-negative integer.

Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.

Example 1:

Input: 4
Output: 2
Example 2:

Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since
             the decimal part is truncated, 2 is returned.
```
```python
class Solution:
    def mySqrt(self, x: int) -> int:
        l, r = 0, x
        while l + 1 < r:
            mid = l + (r - l) // 2
            if mid * mid <= x < (mid + 1) * (mid + 1):
                return mid
            elif mid * mid < x:
                l = mid + 1
            else:
                r = mid - 1
        return l if l * l <= x < (l + 1) * (l + 1) else r
```
高频：统一模板...l + 1 < r...if mid * mid **<=** x **<**(mid + 1) * (mid + 1)...return l if l * l <= x <...

### [35. Search Insert Position (Easy)](https://leetcode.com/problems/search-insert-position/)
```html
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example 1:

Input: [1,3,5,6], 5
Output: 2
Example 2:

Input: [1,3,5,6], 2
Output: 1
Example 3:

Input: [1,3,5,6], 7
Output: 4
Example 4:

Input: [1,3,5,6], 0
Output: 0
```
```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l, r = 0, len(nums) - 1
        while l + 1 < r:
            mid = l + (r - l) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                l = mid
            else:
                r = mid
        if target <= nums[l]:
            return l
        if target <= nums[r]:
            return r
        return len(nums)
```
高频：...l = mid...if target <= nums[l]: return l...return len(nums)

### [658. Find K Closest Elements (Medium)](https://leetcode.com/problems/find-k-closest-elements/description/)
[LinC 460. Find K Closest Elements (Medium)](https://www.lintcode.com/problem/find-k-closest-elements/description)
```html
Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.

Example 1:
Input: [1,2,3,4,5], k=4, x=3
Output: [1,2,3,4]
Example 2:
Input: [1,2,3,4,5], k=4, x=-1
Output: [1,2,3,4]
Note:
The value k is positive and will always be smaller than the length of the sorted array.
Length of the given array is positive and will not exceed 104
Absolute value of elements in the array and x will not exceed 104
UPDATE (2017/9/19):
The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.
```
三刷
```python
class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -> List[int]:
        n = len(arr)
        l, r = 0, n - 1
        while l + 1 < r:
            mid = l + (r - l) // 2
            if arr[mid] < x:
                l = mid
            else:
                r = mid
        cnt = 0
        res = []
        while l >= 0 and r <= n - 1 and cnt < k:
            if abs(arr[l] - x) <= abs(arr[r] - x):
                res.append(arr[l])
                l -= 1
            else:
                res.append(arr[r])
                r += 1
            cnt += 1
        while l >= 0 and cnt < k:
            res.append(arr[l])
            l -= 1
            cnt += 1
        while r <= n - 1 and cnt < k:
            res.append(arr[r])
            r += 1
            cnt += 1
        return sorted(res)
```
三刷：整理一，二刷代码。算法：1.二分法查找 target，将 l, r 指针放到正确的位置；2.左右按 diff 走 k；3.往左走到底，往右走到底...if nums[mid] **<** x: l = **mid** else: r = **mid**...
网上还有一种很妖的O(logN)算法，破坏了模板，核心原理是l, r = 0, len(arr) - k...if abs(arr[mid] - x) > abs(arr[mid + k] - x): l = mid + 1 else: r = mid; return arr[l: l + k]


# Two pointers

### [LinC 373. Partition Array by Odd and Even (Easy)](http://www.lintcode.com/problem/partition-array-by-odd-and-even/)
```html
Partition an integers array into odd number first and even number second.

Example
Given [1, 2, 3, 4], return [1, 3, 2, 4]
```
思路：双指针一头一尾，碰到不符合的就换。
```python
class Solution:
    """
    @param: nums: an array of integers
    @return: nothing
    """
    def partitionArray(self, nums):
        # write your code here
        if len(nums) < 2:
            return
        l, r = 0, len(nums) - 1
        while l < r:
            while l < r and nums[l] % 2 != 0:
                l += 1
            while l < r and nums[r] % 2 == 0:
                r -= 1
            if nums[l] % 2 == 0 or nums[r] % 2 != 0:
                nums[l], nums[r] = nums[r], nums[l]
        if nums[l] % 2 == 0 or nums[r] % 2 != 0:
            nums[l], nums[r] = nums[r], nums[l]
```
总结：送两个测试数据进去就能写对。 最后两个 if 可以简化。

### [26. Remove Duplicates from Sorted Array (Easy)](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/)
```html
Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn't matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```
思路：简单题， 慢指针只有在快指针碰到不同的值才走。
```python
class Solution:
    def removeDuplicates(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 0:
            return 0
        slow, fast = 0, 1
        while fast < len(nums):
            if nums[fast] == nums[slow]:
                fast += 1
            else:
                slow += 1
                nums[slow] = nums[fast]
                fast += 1
        return slow + 1
```
总结：纯热身，秒解

二刷
```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if len(nums) <= 1:
            return len(nums)
        slow, fast = 0, 1
        while fast < len(nums):
            if nums[slow] == nums[fast]:
                fast += 1
            else:
                slow += 1
                nums[slow], nums[fast] = nums[fast], nums[slow]
                fast += 1
        return slow + 1
```
总结：虽然是容易热身题，却要思考两个问题，第一，数组需要 in place sort, 需要利用已经排好序这个条件来在 slow 往前一个以后交换 slow 和 fast 的数； 第二，返回 slow + 1 可以省一个 ans 变量
高频: ...else: slow += 1; nums[slow], nums[fast] = nums[fast], nums[slow]; fast += 1...

### [80. Remove Duplicates from Sorted Array II (Medium)](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)
```html
Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn't matter what values are set beyond the returned length.
```
```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        if not nums:
            return 0
        w = 0
        for i, n in enumerate(nums):
            if i < 2 or n != nums[w - 2]:
                nums[w] = n
                w += 1
        return w
```
高频：反正两周前的代码也看不懂了，抄个简单一点的...if i < 2 or n != nums[w **- 2**]

### [28. Implement strStr() (Easy)](https://leetcode.com/problems/implement-strstr/description/)
```html
Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = "hello", needle = "ll"
Output: 2
Example 2:

Input: haystack = "aaaaa", needle = "bba"
Output: -1
Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().
```
思路：快慢指针
```python
class Solution(object):
    def strStr(self, haystack, needle):
        """
        :type haystack: str
        :type needle: str
        :rtype: int
        """
        if len(needle) == 0:
            return 0
        if len(haystack) == 0:
            return -1
        for i in range(len(haystack)):
            if haystack[i] == needle[0]:
                if i + len(needle) - 1 < len(haystack):
                    if needle == haystack[i: i + len(needle)]:
                        return i
                else:
                    return -1
        return -1
```
总结: 思路是双指针没问题，实际用 python 的时候可以用 python 的性质直接取子串

二刷：
```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if len(needle) == 0:
            return 0
        if len(haystack) == 0:
            return -1
        end = len(haystack) - len(needle) + 1
        if end < 0:
            return -1
        for i in range(0, end):
            if haystack[i:i + len(needle)] == needle:
                return i
        return -1
```
总结：注意空串的时候要返回 int 而不是 bool, needle 为空时，直接返回 0, 优化 end = len(haystack) - len(needle) + 1; if end < 0: return -1; for i in range(0, end)
高频：考点 end = lh - ln + 1; ... if haystack[i:i + ln] == needle: return i。代码能优化一点点，但是大同小异。

### [283. Move Zeroes (Easy)](https://leetcode.com/problems/move-zeroes/description/)
Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Example:
Input: [0,1,0,3,12]
Output: [1,3,12,0,0]

Note:
You must do this in-place without making a copy of the array.
Minimize the total number of operations.
```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        n = len(nums)
        l, r = 0, 0
        while r < n:
            while nums[r] == 0 and r < n - 1:
                r += 1
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r += 1
```
总结：三刷出了更简洁的写法，跑测试用例的时候仍然要考虑 0 在左中右三种情况                        
高频：两个月没刷这题，导致思路僵化在一刷的l, r均从0，0开始需要考虑很多种情况的算法。三刷或者l, r从0，1开始代码就简洁很多（本质是一样的）。删掉一刷代码的复杂情况判断。 非要l，r从0，0开始，就不考虑各种情况，l，r永远前进
五刷：写出了也能过的代码，但是不如高频代码简洁

### [125. Valid Palindrome (Easy)](https://leetcode.com/problems/valid-palindrome/description/)
```html
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

Note: For the purpose of this problem, we define empty string as valid palindrome.

Example 1:

Input: "A man, a plan, a canal: Panama"
Output: true
Example 2:

Input: "race a car"
Output: false
```
思路：头尾双指针， 碰头了返回 True，相同继续走，不同返回 False
```python
class Solution(object):
    def isPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if len(s) == 0 or len(s) == 1:
            return True
        head, tail = 0, len(s) - 1
        while head < tail:
            while not s[head].isalnum() and head < tail:
                head += 1
            while not s[tail].isalnum() and head < tail:
                tail -= 1
            if s[head].lower() != s[tail].lower():
                return False
            else:
                head += 1
                tail -= 1
        return True
```
总结：思路简单， 但是要想到的 case 很多。考虑带标点符号，连续两个位置都是标点符号，整个字符串都是标点符合这三个情况才能写对

二刷：
```python
class Solution:
    def isPalindrome(self, s: str) -> bool:
        if len(s) <= 1:
            return True
        head, tail = 0, len(s) - 1
        while head < tail:
            while not s[head].isalnum() and head < tail:
                head += 1
            while not s[tail].isalnum() and head < tail:
                tail -= 1
            if s[head].lower() == s[tail].lower():
                head += 1
                tail -= 1
            else:
                return False
        return True
```
总结：关键是知道 .isalnum() 这个 function
高频

### [680. Valid Palindrome II (Easy)](https://leetcode.com/problems/valid-palindrome-ii/description/)
```html
Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.

Example 1:
Input: "aba"
Output: True
Example 2:
Input: "abca"
Output: True
Explanation: You could delete the character 'c'.
Note:
The string will only contain lowercase characters a-z. The maximum length of the string is 50000.
```
思路：目前网上看到大部分答案都以贪心算法为主，等看贪心了再刷这题。再看一眼感觉就是统计有没有 > 2 单数的题，撸之
```python
class Solution(object):
    def validPalindrome(self, s):
        """
        :type s: str
        :rtype: bool
        """
        if len(s) <= 2:
            return True
        l, r = 0, len(s) - 1
        while l < r:
            if s[l] != s[r]:
                break
            l += 1
            r -= 1
        if l >= r:
            return True
        # 要么删左边，要么删右边
        return self.isPalindrome(s[:l] + s[l + 1:]) or self.isPalindrome(s[:r] + s[r + 1:])
    def isPalindrome(self, s):
        return s == s[::-1]  
```
总结：没那么简单，还要考虑这些情况 1.如果有 2 个 single 均不在 mid 位置；2. 去掉 single 点后的 string 仍然不是 palindrome; 3. 1 个 single，多个位置可以删除； 然后就抓狂了。 看了答案， 真他妈的妖。双指针算法。从两头走到中间，发现第一对不一样的字符之后，要么删左边的，要么删右边的。

二刷：
```python
class Solution:
    def validPalindrome(self, s: str) -> bool:
        if len(s) <= 2:
            return True
        l, r = 0, len(s) - 1
        while l < r:
            if s[l] != s[r]:
                break
            l += 1
            r -= 1
        if not l < r:
            return True
        return self.isPalindrome(s[:l] + s[l + 1:]) or self.isPalindrome(s[:r] + s[r + 1:])
    def isPalindrome(self, s):
        return s == s[::-1]
```
总结：如一刷所说，是一道比较妖的题，背熟吧

### [1. Two Sum (Easy)](https://leetcode.com/problems/two-sum/description/)
```html

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:

Given nums = [2, 7, 11, 15], target = 9,

Because nums[0] + nums[1] = 2 + 7 = 9,
return [0, 1].
```
思路：固定一个找另一个
```python
class Solution:
    def twoSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        for index1 in xrange(len(nums)):
            for index2 in xrange(index1 + 1, len(nums)):
                if nums[index1] + nums[index2] == target:
                    return [index1, index2]
```
总结： 第二层循环的起始数字注意条件 you may not use the same element twice

二刷：
```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        lookup = {}
        for idx, val in enumerate(nums):
            if val not in lookup:
                remain = target - val
                lookup[remain] = idx
            else:
                return [lookup[val], idx]
```
总结：除了双指针还有dict的解法，需要熟练掌握，信手拈来。注意遍历list用 for idx, val in enumerate(arr)
高频：用dict/hashmap的方法稍微有点绕，而且对后面的xsum没有帮助，掌握两层循环面试应该就够了

### [167. Two Sum II - Input array is sorted (Easy)](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/)
```html
Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

Note:

Your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution and you may not use the same element twice.
Example:

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
```
思路：增加了 sorted 这个条件， 第一感觉是可以折半查找了。固定 index1，index2 用折半查找获得
```python
class Solution:
    def twoSum(self, numbers, target):
        """
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        """
        for index1 in range(len(numbers)):
            start, end = index1 + 1, len(numbers) - 1
            while start + 1 < end:
                mid = start + (end - start) // 2
                if numbers[index1] + numbers[mid] == target:
                    return [index1 + 1, mid + 1]
                elif numbers[index1] + numbers[mid] < target:
                    start = mid + 1
                else:
                    end = mid - 1
            if numbers[index1] + numbers[start] == target:
                return [index1 + 1, start + 1]
            elif numbers[index1] + numbers[end] == target:
                return [index1 + 1, end + 1]
```
总结：要细心。1.题中 answers are not zero-based 2.要测两个情况 [2, 7, 19], 9 和 [5, 25, 75] 可以测出代码的问题

二刷：
```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r = 0, len(numbers) - 1
        while l < r:
            tsum = numbers[l] + numbers[r]
            if tsum == target:
                return [l + 1, r + 1]
            if tsum < target:
                l += 1
            else:
                r -= 1
```
总结：二分法跑分不如直接双指针，可能是测试数据导致。双指针代码也简单很多

### [LinC 607. Two Sum III - Data structure design (Easy)](https://www.lintcode.com/problem/two-sum-iii-data-structure-design/description)
```html
Design and implement a TwoSum class. It should support the following operations: add and find.

add - Add the number to an internal data structure.
find - Find if there exists any pair of numbers which sum is equal to the value.

Example
add(1); add(3); add(5);
find(4) // return true
find(7) // return false
```
思路：add 的时候把 sum 都存 dict 里面， 查的时候直接返回 dict 里面有没有 sum. 会超时。
```python
class TwoSum:
    keys = {}
    """
    @param: number: An integer
    @return: nothing
    """
    def add(self, number):
        # write your code here
        if number not in self.keys:
            self.keys[number] = 1
        else:
            self.keys[number] = 2
    """
    @param: value: An integer
    @return: Find if there exists any pair of numbers which sum is equal to the value.
    """
    def find(self, value):
        # write your code here
        for key in self.keys:
            if value - key in self.keys:
                if value - key == key:
                    if self.keys[key] == 2:
                        return True
                else:
                    return True
        return False
```
总结：虽然是一道容易题， 第一反应的思路会超时。 需要在 find 的时候判断能凑出答案的另一个 key 是不是已经在 keys 里了。而不是先存好 sum。 还要判断两个数相同的时候有没有存过两个数。

### [15. 3Sum (Medium)](https://leetcode.com/problems/3sum/description/)
```html
Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

Note:

The solution set must not contain duplicate triplets.

Example:

Given array nums = [-1, 0, 1, 2, -1, -4],

A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
```
思路：可以吧 a + b + c = 0 变为 a + b = - c 的问题，问题则变为， 对于任意数 a，dict 里是否存在 -c - a 这么个数， a 和 c 是两层循环
二刷：可以把天真的第一想法扔掉了：）。 就是以当前遍历的点 i 为基础的双指针。二刷比一刷有一点改进空间。python 的 list 就带一定的去重机制，可以少写几行去重代码。3 年前写的还是很牛逼的。。。靠，三年前的写法会 TLE。。。真是难度越来越高了。。。尼玛。。。注意：当 sum == 0 的时候需要在 ans.appen(); l += 1; r -= 1; 的基础上加 while l < r and **nums[l] == nums[l - 1]:** l += 1 和 while l < r and nums[r] == nums[r + 1]: r -= 1 这样的跳过语句才能 AC。。。
```python
class Solution:
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        results = []
        nums.sort()
        for index1 in range(len(nums) - 2):
            if index1 and nums[index1] == nums[index1 - 1]:
                continue
            head = index1 + 1
            tail = len(nums) - 1
            while head < tail:
                if nums[index1] + nums[head] > -nums[tail]:
                    tail -= 1
                elif nums[index1] + nums[head] < -nums[tail]:
                    head += 1
                else:
                    results.append([nums[index1], nums[head], nums[tail]])
                    head += 1
                    tail -= 1
                    while head < tail and nums[head] == nums[head - 1]:
                        head += 1
                    while head < tail and nums[tail] == nums[tail + 1]:
                        tail -= 1
        return results
```
总结：三层循环是暴力方法，去重会受阻，这个时候需要想到给输入数组先排个序，因为结果里，没有要求元素的顺序，这是个重要的提示。排序以后每次固定一个数 index1，然后找的过程是：head = index1 + 1, tail = len(nums) - 1; while head < tail:  if nums[index1] + nums[head] > - nums[tail]: tail -= 1, elif nums[index1] + nums[head] < -nums[tail]: head += 1, else: results.append()
代码还需要考虑的几个情况：1.对于已经用过的元素需要跳过， 这里要用到 if index1 and nums[index1] == nums[index1 - 1]; 2.如果碰到了一个 result，要跳过所有重复的元素，需要用到 while head < tail and nums[head] == nums[head - 1]: 和相应的 ...nums[tail + 1]

二刷：
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = []
        nums = sorted(nums)
        for idx, val in enumerate(nums):
            if idx > 0 and val == nums[idx - 1]:
                continue
            target = 0 - val
            l, r = idx + 1, len(nums) - 1
            while l < r:
                tsum = nums[l] + nums[r]
                if tsum == target:
                    ans.append([val, nums[l], nums[r]])
                    while l < r and nums[l] == nums[l + 1]:
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1
                if tsum < target:
                    l += 1
                else:
                    r -= 1
        return ans
```
总结：注意在第一次遍历数组，找到目标这两个位置要去重

三刷：
```python
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        ans = []
        nums.sort()
        for i in range(len(nums) - 2):
            if nums[i] > 0:
                break
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            l = i + 1
            r = len(nums) - 1
            while l < r:
                total = nums[i] + nums[l] + nums[r]
                if total < 0:
                    l += 1
                elif total > 0:
                    r -= 1
                else:
                    ans.append([nums[i], nums[l], nums[r]])
                    while l < r and nums[l] == nums[l + 1]:
                        l += 1
                    while l < r and nums[r] == nums[r - 1]:
                        r -= 1
                    l += 1
                    r -= 1
        return ans
```
总结：稍微优化了一下，更好懂，执行效率更高一点

### [LinC 382. Triangle Count (Medium)](https://www.lintcode.com/problem/triangle-count/description)
```html
Given an array of integers, how many three numbers can be found in the array, so that we can build an triangle whose three edges length is the three numbers that we find?

Example
Given array S = [3,4,6,7], return 3. They are:

[3,4,6]
[3,6,7]
[4,6,7]
Given array S = [4,4,4,4], return 4. They are:

[4(1),4(2),4(3)]
[4(1),4(2),4(4)]
[4(1),4(3),4(4)]
[4(2),4(3),4(4)]
```
思路： 判断能不能做三角形以后全排列
```python
class Solution:
    """
    @param S: A list of integers
    @return: An integer
    """
    def triangleCount(self, S):
        # write your code here
        S.sort(reverse=True)
        sum = 0
        for index1, longest in enumerate(S):
            head, tail = index1 + 1, index1 + 2
            while tail < len(S) and S[head] + S[tail] > longest:
                tail += 1
            tail -= 1
            while head < tail:
                sum += tail - head
                head += 1
                while head < tail and S[head] + S[tail] <= longest:
                    tail -= 1
        return sum
```
总结：看清题目，问的是有多少个这样的三角形， 返回数就行。 全排列效率比较低。 更优解是每次定下最长边， 寻找符合条件的另外两个边的数量。 双指针的解法是将 tail 推到最小不能组成三角形的位置， 退一步， 然后从 tail 到 head 的位置的都可以组， 因为他们相加只会比最长边更长。 然后将 head 进一步（缩短），tail 边加长到大于最长边的位置，新 tail 到 head 的位置又都可以组。

### [16. 3Sum Closest (Medium)](https://leetcode.com/problems/3sum-closest/description/)
```html
Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

Example:

Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
```
```python
class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        ans = None
        nums.sort()
        for i in range(len(nums) - 2):
            l, r = i + 1, len(nums) - 1
            while l < r:
                t = nums[i] + nums[l] + nums[r]
                if t == target:
                    return t
                elif t < target:
                    l += 1
                else:
                    r -= 1
                if ans == None or abs(t - target) < abs(ans - target):
                    ans = t
        return ans
```
高频：将1，2刷的代码思路总结都删了，都差不多。注意这里没有mid，不是二分查找。

### [LinC 31. Partition Array (Medium)](https://www.lintcode.com/problem/partition-array/description)
```html
Description
Given an array nums of integers and an int k, partition the array (i.e move the elements in "nums") such that:

All elements < k are moved to the left
All elements >= k are moved to the right
Return the partitioning index, i.e the first index i nums[i] >= k.

You should do really partition in array nums instead of just counting the numbers of integers smaller than k.

If all elements in nums are smaller than k, then return nums.length
Example
If nums = [3,2,2,1] and k=2, a valid answer is 1.

Challenge
Can you partition the array in-place and in O(n)?
```
思路：和 partition list 很像， 数组的话就只能用双指针了. l 是最后一个 < k, r 是最后一个 >= k
```python
class Solution:
    """
    @param nums: The integer array you should partition
    @param k: An integer
    @return: The index after partition
    """
    def partitionArray(self, nums, k):
        # write your code here
        if len(nums) == 0:
            return 0
        l, r = 0, len(nums) - 1
        while l <= r:
            while l < len(nums) and nums[l] < k:
                l += 1
            while r >= 0 and nums[r] >= k:
                r -= 1
            if l > r:
                break
            nums[l], nums[r] = nums[r], nums[l]
        return l    
```
总结：因为数组比链表好操作的多， 比 partition list 解法简单， 需要注意：1。while 的条件是 l <= r 2。l 往右走，r 往左走不要越界，r 往左需要 r >= 0 3.l > r 的时候需要 break

### [215. Kth Largest Element in an Array (Medium)](https://leetcode.com/problems/kth-largest-element-in-an-array/description/)
```html
Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Example 1:
Input: [3,2,1,5,6,4] and k = 2
Output: 5

Example 2:
Input: [3,2,3,1,2,4,5,5,6] and k = 4
Output: 4
Note:
You may assume k is always valid, 1 ≤ k ≤ array's length.
```
思路：现场想是基本没戏。quickselect算法，基于quicksort
```python
class Solution:
    def findKthLargest(self, nums, k: int) -> int:
        k -= 1
        def quickSelect(l, r):
            hi = l
            from random import randint
            ri = randint(l, r)
            nums[ri], nums[r] = nums[r], nums[ri]
            for i, v in enumerate(nums[l:r], l):
                if v > nums[r]:
                    nums[i], nums[hi] = nums[hi], nums[i]
                    hi += 1
            nums[hi], nums[r] = nums[r], nums[hi]
            if hi < k:
                return quickSelect(hi + 1, r)                
            elif hi > k:
                return quickSelect(l, hi - 1)
            else:
                return nums[hi]
        return quickSelect(0, len(nums) - 1)
```
总结：注意：递归调用的时候记得函数名前要加 return 否则不会返回任何值。由于完全抛弃另一侧，时间复杂度平均由 quick sort 的 O(nlogn) 降为 O(n) 因为输入变小了， quicksort 的输入一直是 n, 最差情况 O(n^2)
二刷：改动较大，删掉一刷帮助不大的代码。注意：递归调用的时候记得函数名前要加 return 否则不会返回任何值。...hi = l...for i, v in enumerate(nums[l:r], l):...

### [75. Sort Colors (Medium)](https://leetcode.com/problems/sort-colors/description/)
Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note: You are not suppose to use the library's sort function for this problem.

Example:
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]
Follow up:

A rather straight forward solution is a two-pass algorithm using counting sort.
First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.
Could you come up with a one-pass algorithm using only constant space?

二刷：
```python
class Solution:
    def sortColors(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if len(nums) <= 1:
            return
        l, r, i = 0, len(nums) - 1, 0
        while i <= r:
            if nums[i] == 0 and i > l:
                nums[l], nums[i] = nums[i], nums[l]
                l += 1
            elif nums[i] == 2 and i < r:
                nums[i], nums[r] = nums[r], nums[i]
                r -= 1
            else:
                i += 1
```
总结：in place 不数元素的话得用 l, r 和 i, 要过的话需要熟记交换的第二条件分别为 i > l 和 i < r, 其他情况 i 均前进
高频：去掉了一刷繁琐的方法。counting sort只需要count 0和1。1 pass：...while i <= r:...and i > l:...and i < r:...
面经：Celo。3个数要保持两个边界l和r，和一个worker i，交换条件要加...i > l...和...i < r，否则会过度交换导致结果有bug

### [18. 4Sum (Medium)](https://leetcode.com/problems/4sum/description/)
```html
Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

The solution set must not contain duplicate quadruplets.

Example:

Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
```
思路：看了下三年前的答案，不是特别直观。看了九章的答案，貌似好理解一点：去重，枚举一个数，然后用 3Sum 的做法，O(N^3)
```python
class Solution:
    def fourSum(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        nums.sort()
        ans = []
        for i in range(0, len(nums) - 3):
            if i and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, len(nums) - 2):
                if j != i + 1 and nums[j] == nums[j - 1]:
                    continue
                l, r = j + 1, len(nums) - 1
                while l < r:
                    sum = nums[i] + nums[j] + nums[l] + nums[r]
                    if sum == target:
                        ans.append([nums[i], nums[j], nums[l], nums[r]])
                        l += 1
                        r -= 1
                        while l < r and nums[l] == nums[l - 1]:
                            l += 1
                        while l < r and nums[r] == nums[r + 1]:
                            r -= 1
                    elif sum < target:
                        l += 1
                    else:
                        r -= 1
        return ans
```
总结：有一个自己肯定想不出的条件就是第二层循环怎么跳过：**if j != i + 1 and nums[j] == nums[j - 1]: continue**; 非常勉强能过 AC. 看了网上和三年前的，都是用 dict 先存 2sum，然后再 loop 两遍，用 if pair[0] > j 来去重（第三个元素的 index 要大于前面两个）。
```python
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        ans = []
        def nsum(l, r, N, target, path):
            if r - l + 1 < N or N < 2 or N > len(nums) or N * nums[l] > target or N * nums[r] < target:
                return        
            if N == 2:                    
                while l < r:
                    t = nums[l] + nums[r]
                    if t == target:
                        ans.append(path + [nums[l], nums[r]])
                        while l < r and nums[l] == nums[l + 1]:
                            l += 1
                        while l < r and nums[r] == nums[r - 1]:
                            r -= 1
                        l += 1
                        r -= 1
                    elif t < target:
                        l += 1
                    else:
                        r -= 1
            else:
                for i in range(l, r + 1):
                    if i == l or (i > l and nums[i] != nums[i - 1]):
                        nsum(i + 1, r, N - 1, target - nums[i], path + [nums[i]])
        nums.sort()
        nsum(0, len(nums) - 1, 4, target, [])
        return ans
```
二刷：看 leetcode ac 的流行答案， 返回递归 nsum， 递归内终结条件为解决 2sum，，注意两处去重，1.找到 target 以后，在 l < r 条件下跳过所有后面与 l 相同的；2.进入 nsum 前，if i == 0 or (i > 0 and nums[i - 1] != nums[i])
总结：很多坑，N == 2 时要注意 while l < r 做二分法；N > 2 时 for i in range(l, r + 1); nsum(i + 1, ...); 如是高频题需要练熟
高频：...def nsum(l, r, N, target, path): if r - l + 1 < N or N < 2 or...if N == 2: while l < r:...  while l < r and nums[l] == nums[l + 1]:...while...l += 1; r -= 1...  for i in range(l, r + 1): if (i == l) or...: nsum(i + 1, r...)...

### [27. Remove Element](https://leetcode.com/problems/remove-element/)
```html
Given an array nums and a value val, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

Example 1:

Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn't matter what you leave beyond the returned length.
Example 2:

Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn't matter what values are set beyond the returned length.
```
高频
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        ans = len(nums)
        i = 0
        j = ans - 1
        while i <= j:
            while i <= j and nums[i] != val:
                i += 1
            while i <= j and nums[j] == val:
                j -= 1
                ans -= 1
            if i < j:
                nums[i], nums[j] = nums[j], nums[i]
        return ans
```
总结：背while i **<=** j: while i <= j and ... while i <= j and ...if i < j: ...

### [19. Remove Nth Node From End of List (Medium)](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
```html
Given a linked list, remove the n-th node from the end of list and return its head.

Example:

Given linked list: 1->2->3->4->5, and n = 2.

After removing the second node from the end, the linked list becomes 1->2->3->5.
Note:

Given n will always be valid.

Follow up:

Could you do this in one pass?
```
```python
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head
        fast = slow = dummy
        while n:
            n -= 1
            fast = fast.next
        while fast and fast.next:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next
```
高频：dummy = ListNode(0)...fast = slow = dummy...slow.next = slow.next.next...

### [11. Container With Most Water (Medium)](https://leetcode.com/problems/container-with-most-water/)
```html
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.

Note: You may not slant the container and n is at least 2.

The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.

Example:

Input: [1,8,6,2,5,4,8,3,7]
Output: 49
```
```python
class Solution:
    def maxArea(self, height: List[int]) -> int:
        ans, l, r = 0, 0, len(height) - 1
        while l < r:
            ans = max(ans, (r - l) * min(height[l], height[r]))
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return ans
```
高频：除了...while l < r: ans = max(...min(...))...并学不到什么东西

### [345. Reverse Vowels of a String (Easy)](https://leetcode.com/problems/reverse-vowels-of-a-string/)
Write a function that takes a string as input and reverse only the vowels of a string.

Example 1:
Input: "hello"
Output: "holle"

Example 2:
Input: "leetcode"
Output: "leotcede"
Note:
```python
class Solution:
    def reverseVowels(self, s: str) -> str:
        stack = []
        for c in s:
            if c in "aeiouAEIOU":
                stack.append(c)
        for i, c in enumerate(s):
            if c in "aeiouAEIOU":
                s = s[:i] + stack.pop() + s[i + 1:]
        return s
```
inplace:
```python
class Solution:
    def reverseVowels(self, s: str) -> str:
        l, r = 0, len(s) - 1
        arr = list(s)
        while l < r:
            while arr[l] not in "aeiouAEIOU" and l < len(s) - 1:
                l += 1
            while arr[r] not in "aeiouAEIOU" and r > 0:
                r -= 1
            if l < r:
                arr[l], arr[r] = arr[r], arr[l]
                l += 1
                r -= 1
        return "".join(arr)
```
面经：DJI。


# BFS 广度优先搜索
图的遍历 Traversal in Graph
* 层级遍历 Level Order Traversal
* 由点及面 Connected Component
* 拓扑排序 Topological Sorting

最短路径 Shortest Path in Simple Graph
* 仅限简单图求最短路径。即，图中每条边长度都是1，或者边长都相等

### [695. Max Area of Island (Medium)](https://leetcode.com/problems/max-area-of-island/description/)
```html
Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)

Example 1:
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.
Example 2:
[[0,0,0,0,0,0,0,0]]
Given the above grid, return 0.
Note: The length of each dimension in the given grid does not exceed 50.
```
思路：没啥太多好说的，BFS 暴力
```python
class Solution:
    def maxAreaOfIsland(self, grid):
        """
        :type grid: List[List[int]]
        :rtype: int
        """
        if len(grid) == 0:
            return 0
        ans = 0
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == 1:
                    ans = max(self.bfs(grid, row, col), ans)
        return ans
    def bfs(self, grid, row, col):
        import collections
        q = collections.deque()
        q.append((row, col))
        grid[row][col] = 0
        size = 0
        while q:
            row, col = q.popleft()
            size += 1
            if self.isValid(grid, row - 1, col) and grid[row - 1][col] == 1:
                q.append((row - 1, col))
                grid[row - 1][col] = 0
            if self.isValid(grid, row + 1, col) and grid[row + 1][col] == 1:
                q.append((row + 1, col))
                grid[row + 1][col] = 0
            if self.isValid(grid, row, col - 1) and grid[row][col - 1] == 1:
                q.append((row, col - 1))
                grid[row][col - 1] = 0
            if self.isValid(grid, row, col + 1) and grid[row][col + 1] == 1:
                q.append((row, col + 1))
                grid[row][col + 1] = 0
        return size
    def isValid(self, grid, row, col):
        return row >= 0 and row < len(grid) and col >= 0 and col < len(grid[0])
```
总结：在上下左右走的时候注意入 q 以后立刻将该点标为 0， 以防同一个点入两次。
二刷：
```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        if len(grid) == 0 or len(grid[0]) == 0:
            return 0
        ans = 0
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == 1:
                    s = 0
                    q = collections.deque()
                    q.append((r, c))
                    grid[r][c] = 0
                    while len(q) > 0:
                        (rq, cq) = q.popleft()
                        s += 1
                        if rq > 0 and grid[rq - 1][cq] == 1:
                            q.append((rq - 1, cq))
                            grid[rq - 1][cq] = 0
                        if rq < len(grid) - 1 and grid[rq + 1][cq] == 1:
                            q.append((rq + 1, cq))
                            grid[rq + 1][cq] = 0
                        if cq > 0 and grid[rq][cq - 1] == 1:
                            q.append((rq, cq - 1))
                            grid[rq][cq - 1] = 0
                        if cq < len(grid[0]) - 1 and grid[rq][cq + 1] == 1:
                            q.append((rq, cq + 1))
                            grid[rq][cq + 1] = 0
                    if s > ans:
                        ans = s
        return ans
```
总结：一次写完， 没有像一刷那样拆成三个函数。 各有优劣吧。注意清零的位置要在放 queue 之后立刻清零，以防同一个点如两次， lol 二刷踩同样的坑 :'(

### [102. Binary Tree Level Order Traversal (Medium)](https://leetcode.com/problems/binary-tree-level-order-traversal/description/)
```html
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
```
二刷：
```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        ans = []
        if root == None:
            return ans
        q = collections.deque()
        q.append(root)
        while q:
            level = []
            nq = []
            for n in q:
                level += [n.val]
                if n.left:
                    nq.append(n.left)
                if n.right:
                    nq.append(n.right)
            q = nq
            ans.append(level)
        return ans
```
二刷：[107. Binary Tree Level Order Traversal II (Easy)](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/) 没毛病，注意：list.reverse() 是 in place, 不返回 list 可以 ans.reverse() return ans, 或者啰嗦点的 list(reversed(ans)) 返回 list。用 deque 其实是多余的，因为每个 level 的 q 都直接扔掉（拼出来的下一层的 newQ 取代），可以用 list，for 循环一遍就可以了。
总结：注意外层用 while， 内层用 for 来遍历之前放进去的每一层节点
高频：deque高效q，...if not root: return ans...level = [], nq = collections.deque()

### [107. Binary Tree Level Order Traversal II (Easy)](https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/)
```html
Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
```
```python
class Solution:
    def levelOrderBottom(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []
        ans = []
        def bfs(root, level):
            if not root:
                return
            if level > len(ans) - 1:
                ans.append([])
            ans[level].append(root.val)
            bfs(root.left, level + 1)
            bfs(root.right, level + 1)
        bfs(root, 0)
        return ans[::-1]
```
高频：用q跟上题代码一样，加个递归的解法，...def bfs(root, level):...

### [103. Binary Tree Zigzag Level Order Traversal (Medium)](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/)
[LinC 71. Binary Tree Zigzag Order Traversal](http://www.lintcode.com/en/problem/binary-tree-zigzag-level-order-traversal/)
```html
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
```
思路：reverse 初始为 0，每层 1 - reverse, reverse == 1 就 reverse
```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def zigzagLevelOrder(self, root):
        """
        :type root: TreeNode
        :rtype: List[List[int]]
        """
        if not root:
            return []
        q = [root]
        ans = []
        reverse = 0
        while q:        
            temp = []
            newQ = []
            for node in q:
                temp.append(node.val)
                if node.left:
                    newQ.append(node.left)
                if node.right:
                    newQ.append(node.right)
            if reverse:
                temp.reverse()
            reverse = 1 - reverse
            ans.append(temp)
            q = newQ
        return ans
```
总结：一次过，可做可不做吧
高频：同一次过，优化空间为可以用deque()的popleft()和pop()来省一个reverse()的时间

### [133. Clone Graph (Medium)](https://leetcode.com/problems/clone-graph/description/)
```html
Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.

Example:
<img src="https://assets.leetcode.com/uploads/2019/02/19/113_sample.png"
     alt="graph example"/>
Input:
{"$id":"1","neighbors":[{"$id":"2","neighbors":[{"$ref":"1"},{"$id":"3","neighbors":[{"$ref":"2"},{"$id":"4","neighbors":[{"$ref":"3"},{"$ref":"1"}],"val":4}],"val":3}],"val":2},{"$ref":"4"}],"val":1}

Explanation:
Node 1's value is 1, and it has two neighbors: Node 2 and 4.
Node 2's value is 2, and it has two neighbors: Node 1 and 3.
Node 3's value is 3, and it has two neighbors: Node 2 and 4.
Node 4's value is 4, and it has two neighbors: Node 1 and 3.

Note:
The number of nodes will be between 1 and 100.
The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.
Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.
You must return the copy of the given node as a reference to the cloned graph.
```
思路：BFS, 用一个 dict 存当前节点的邻居，如果没见过就加 dict 存 queue，queue 出来建 node，放 neighbor；概念上比较好懂，写码可能有坑
```python
# Definition for a undirected graph node
# class UndirectedGraphNode:
#     def __init__(self, x):
#         self.label = x
#         self.neighbors = []

class Solution:
    # @param node, a undirected graph node
    # @return a undirected graph node
    def cloneGraph(self, node):
        if node == None:
            return None
        dict = {}
        _cloneNode = UndirectedGraphNode(node.label)
        dict[node] = _cloneNode
        q = [node]
        while q:
            new_q = []
            for _node in q:
                for neighbor in _node.neighbors:
                    if neighbor not in dict:
                        _cloneNode = UndirectedGraphNode(neighbor.label)
                        dict[neighbor] = _cloneNode
                        new_q.append(neighbor)
                    dict[_node].neighbors.append(dict[neighbor])    
            q = new_q
        return dict[node]
```
总结：思路用 dict 来存当前节点的邻居是错的，需要用 dict 存当前节点和克隆节点的映射关系。因为反正映射关系在，加邻居可以后加. 邻居是不能直接 copy 或者 = 的， 因为邻居的类型也是节点， 需要创造以后加进去。测一下，然后 debug 细一点， 要测出
```python
dict[_node].neighbors.append(dict[neighbor])
```

二刷：
```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val, neighbors):
        self.val = val
        self.neighbors = neighbors
"""
class Solution:
    def cloneGraph(self, node: 'Node') -> 'Node':
        d = {}
        n = Node(node.val, [])
        if node.neighbors == None or len(node.neighbors) == 0:
            return n
        d[node] = n
        q = collections.deque()
        q.append(node)
        while q:
            nq = q.popleft()
            if nq not in d:
                n = Node(nq.val, [])
                d[nq] = n
            for nn in nq.neighbors:
                if nn not in d:
                    q.append(nn)
                    n = Node(nn.val, [])
                    d[nn] = n    
                d[nq].neighbors.append(d[nn])
        return d[node]
```
总结：二刷第一遍没有想到 nn 在不在 d 里面，都要加入到克隆出来的节点的 neighbors 中去。此次击败了 100% 的内存使用，如需提高速度，可以增加一个 visited = set() 如果已经访问过就 return，可以用空间换时间

### [127. Word Ladder (Medium)](https://leetcode.com/problems/word-ladder/description/)
```html
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:

Only one letter can be changed at a time.
Each transformed word must exist in the word list. Note that beginWord is not a transformed word.
Note:

Return 0 if there is no such transformation sequence.
All words have the same length.
All words contain only lowercase alphabetic characters.
You may assume no duplicates in the word list.
You may assume beginWord and endWord are non-empty and are not the same.
Example 1:

Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output: 5

Explanation: As one shortest transformation is "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5.
Example 2:

Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: 0

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
```
思路：确实是寻找路径的问题，从 beginWord 到 endWord 是否存在最短路径让他俩相连，最短路径取决于词库里有哪些词（路径）。怎么实现很不清晰
```python
import string
class Solution(object):
    def ladderLength(self, beginWord, endWord, wordList):
        """
        :type beginWord: str
        :type endWord: str
        :type wordList: List[str]
        :rtype: int
        """
        if beginWord == endWord:
            return 0
        wordSet = set(wordList)
        q = collections.deque([[beginWord, 1]])
        while q:
            word, level = q.popleft()
            for index in range(len(word)):
                for char in 'abcdefghijklmnopqrstuvwxyz':
                    newWord = word[:index] + char + word[index + 1:]
                    if newWord in wordSet:
                        if newWord == endWord:
                            return level + 1
                        wordSet.remove(newWord)
                        q.append([newWord, level + 1])
        return 0

```
总结：看了下答案，网上答案解释的比较好理解的是，起始词是树的根节点，每一层是从第一个字母到最后一个字母，每次一个字母，从 a - z 替换过一遍，同时又在 wordList 里的词。从上往下 BFS，找到 endWord 即返回当前 level。啧啧啧，强大的应用题。逻辑对还得不 TLE 需要1.将 wordList 转成 set；2.使用 collections.deque；3.碰到 wordSet 中的词，先该词在 wordSet 中删除，再入 deque

二刷：
```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        wordSet = set(wordList)
        q = collections.deque()
        q.append((beginWord, 1))
        while q:
            word, level = q.popleft()
            for i in range(len(beginWord)):
                for letter in "abcdefghijklmnopqrstuvwxyz":
                    newWord = word[:i] + letter + word[i + 1:]
                    if newWord in wordSet:
                        if newWord == endWord:
                            return level + 1
                        q.append((newWord, level + 1))
                        wordSet.remove(newWord)
        return 0
```
总结：几个要点，1.明白deque的作用是将wordList中的词通过每次改一个字母的方式挪到一个堆栈中，然后逐步的以(word, level)的形式pop出来，直到堆栈为空或者找到目标词 2.明白每一层遍历每一个位置上的字母所有可能性，由于每次找到一个词都会将其在wordList中去除，因此不用担心重复 3. deque.popleft() 而非 popLeft() 需要注意 4.裁剪字符串的时候要注意[：终点] [起点:] 终点是不包括的，起点是包括的，因此，裁掉位置在i的字符需要用 word[:i] + letter + word[i + 1:] 5.判断结果是否找到的语句要放在判断词是否在wordSet里之内

高频
```python
class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if len(beginWord) != len(endWord) or len(wordList) == 0:
            return 0
        graph = collections.defaultdict(list)
        for word in wordList:
            for i in range(len(beginWord)):
                tmp = word[:i] + "*" + word[i + 1:]
                graph[tmp].append(word)
        visited = set(beginWord)
        q = collections.deque([(beginWord, 1)])
        while q:
            tmp, level = q.popleft()
            for i in range(len(beginWord)):
                pattern = tmp[:i] + "*" + tmp[i + 1:]
                for word in graph[pattern]:
                    if word == endWord:
                        return level + 1
                    if word not in visited:
                        visited.add(word)
                        q.append((word, level + 1))
        return 0
```
总结：新算法，先建一个defaultdict的词库，然后bfs，效率高一些，空间换时间。背：graph[temp].append(word); ... visited = set(beginWord); q = collections.deque([(beginWord, 1)]); ... pattern = tmp[:i] + tmp[i + 1:]; for word in graph[pattern]: ... if word not in visited:...

### [200. Number of Islands (Medium)](https://leetcode.com/problems/number-of-islands/description/)
```html
Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:
Input:
11110
11010
11000
00000
Output: 1

Example 2:
Input:
11000
11000
00100
00011
Output: 3
```
思路：遍历矩阵，碰到 1 就上下左右 BFS，碰到 0 跳过。BFS 访问过的标 0
```python
class Solution(object):
    def numIslands(self, grid):
        """
        :type grid: List[List[str]]
        :rtype: int
        """
        if len(grid) == 0:
            return 0
        ans = 0
        for rowI in range(len(grid)):
            for colI in range(len(grid[0])):
                if grid[rowI][colI] == "1":
                    ans += 1
                    q = collections.deque([[rowI, colI]])
                    grid[rowI][colI] = "0"
                    while q:
                        row, col = q.popleft()
                        # up
                        if (row > 0) and grid[row - 1][col] == "1":
                                q.append([row - 1, col])
                                grid[row - 1][col] = '0'
                        # down
                        if (row < len(grid) - 1) and grid[row + 1][col] == "1":
                                q.append([row + 1, col])
                                grid[row + 1][col] = '0'
                        # left
                        if (col > 0) and grid[row][col - 1] == "1":
                                q.append([row, col - 1])
                                grid[row][col - 1] = '0'
                        # right
                        if (col < len(grid[0]) - 1) and grid[row][col + 1] == "1":
                                q.append([row, col + 1])
                                grid[row][col + 1] = '0'
        return ans
```
总结：对于 leetcode ac 比较重要的细节是，gird[][] = '0' 这句话要在 while 的每个 if 里面，否则逻辑 OK 但是会 TLE

二刷：
```python
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if len(grid) == 0 or len(grid[0]) == 0:
            return 0
        q = collections.deque()
        ans = 0
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == "1":
                    ans += 1
                    grid[r][c] = "0"
                    q.append((r, c))
                    while q:
                        nr, nc = q.popleft()
                        if nr - 1 >= 0 and grid[nr - 1][nc] == "1":
                            grid[nr - 1][nc] = "0"
                            q.append((nr -1, nc))
                        if nr + 1 < len(grid) and grid[nr + 1][nc] == "1":
                            grid[nr + 1][nc] = "0"
                            q.append((nr + 1, nc))
                        if nc - 1 >= 0 and grid[nr][nc - 1] == "1":
                            grid[nr][nc - 1] = "0"
                            q.append((nr, nc - 1))
                        if nc + 1 < len(grid[0]) and grid[nr][nc + 1] == "1":
                            grid[nr][nc + 1] = "0"
                            q.append((nr, nc + 1))
        return ans
```
总结：比较直观，注意island是用字符串“1”而非数字1代表的

### [LinC 611. Knight Shortest Path (Medium)](https://www.lintcode.com/problem/knight-shortest-path/description)
```html
Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.
Return -1 if knight can not reached.

source and destination must be empty.
Knight can not enter the barrier.

Clarification
If the knight is at (x, y), he can get to the following positions in one step:

(x + 1, y + 2)
(x + 1, y - 2)
(x - 1, y + 2)
(x - 1, y - 2)
(x + 2, y + 1)
(x + 2, y - 1)
(x - 2, y + 1)
(x - 2, y - 1)
Example
[[0,0,0],
 [0,0,0],
 [0,0,0]]
source = [2, 0] destination = [2, 2] return 2

[[0,1,0],
 [0,0,0],
 [0,0,0]]
source = [2, 0] destination = [2, 2] return 6

[[0,1,0],
 [0,0,1],
 [0,0,0]]
source = [2, 0] destination = [2, 2] return -1
```
思路：没什么思路， 看了下答案，就是 BFS 硬来，需要检查走了某个方向以后是不是还是在棋盘内
```python
"""
Definition for a point.
class Point:
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b
"""

class Solution:
    """
    @param grid: a chessboard included 0 (false) and 1 (true)
    @param source: a point
    @param destination: a point
    @return: the shortest path
    """
    def shortestPath(self, grid, source, destination):
        # write your code here
        if len(grid) == 0 or (len(grid[0]) == 1 and grid[0][0] == 1):
            return -1
        ans = 0
        dx = [1, 1, -1, -1, 2, 2, -2, -2]
        dy = [2, -2, 2, -2, 1, -1, 1, -1]
        q = collections.deque([source])
        grid[source.x][source.y] = 1
        while q:
            qlen = len(q)
            next_q = collections.deque()
            for i in range(qlen):
                pt = q.popleft()
                if pt.x == destination.x and pt.y == destination.y:
                    return ans
                for move in range(len(dx)):
                    nextPt = Point(pt.x + dx[move], pt.y + dy[move])
                    if (self.isInbound(grid, nextPt) and grid[nextPt.x][nextPt.y] == 0):
                        next_q.append(nextPt)
                        grid[nextPt.x][nextPt.y] = 1
            ans += 1
            q = next_q
        return -1
    def isInbound(self, grid, pt):
        return pt.x >= 0 and pt.x < len(grid) and pt.y >= 0 and pt.y < len(grid[0])
```
总结：注意 isInbound 要查的是 >=0 和 < len()， 其他的问题可以通过跑一个测试数据发现

### [785. Is Graph Bipartite? (Medium)](https://leetcode.com/problems/is-graph-bipartite/description/)
```html
Given an undirected graph, return true if and only if it is bipartite.

Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.

The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice.

Example 1:
Input: [[1,3], [0,2], [1,3], [0,2]]
Output: true
Explanation:
The graph looks like this:
0----1
|    |
|    |
3----2
We can divide the vertices into two groups: {0, 2} and {1, 3}.
Example 2:
Input: [[1,2,3], [0,2], [0,1,3], [0,2]]
Output: false
Explanation:
The graph looks like this:
0----1
| \  |
|  \ |
3----2
We cannot find a way to divide the set of nodes into two independent subsets.


Note:

graph will have length in range [1, 100].
graph[i] will contain integers in range [0, graph.length - 1].
graph[i] will not contain i or duplicate values.
The graph is undirected: if any element j is in graph[i], then i will be in graph[j].
```
思路：用染色的方法，可以用 DFS, BFS 给所有 node 染上两种色中的一种。1.未上色，既上色，给相邻节点上相反色 2.已上色，查是否和目前要上的色相同
DFS:
```python
class Solution:
    def isBipartite(self, graph):
        """
        :type graph: List[List[int]]
        :rtype: bool
        """
        seen = {}
        def dfs(n, color):
            if n in seen:
                return color == seen[n]
            seen[n] = color
            for v in graph[n]:
                if not dfs(v, -color):
                    return False
            return True
        for i in range(len(graph)):
            if i not in seen and dfs(i, 1) == False:
                return False
        return True
```
BFS:
```python
class Solution:
    def isBipartite(self, graph):
        seen = {}
        for i in range(len(graph)):
            if i not in seen:
                s = [(i, 1)]
                seen[i] = 1
                while s:
                    n, color = s.pop()
                    for v in graph[n]:
                        if v in seen:
                            if color == seen[v]:
                                return False
                        else:
                            seen[v] = -color
                            s.append((v, -color))
        return True
```
二刷：DFS: ...return color == seen[n]...if not dfs(v, -color): return False...return True... BFS: ...seen[i] = 1; while...

### [LinC 178. Graph Valid Tree (Medium)](http://www.lintcode.com/problem/graph-valid-tree/)
Leetcode 261. Graph Valid Tree 加锁
```html
Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.

Example
Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.

Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.
```
思路：树的两个条件是不能有环，不能有孤儿节点。怎么实现想不太出来。看了答案，用 defaultdict(list) 放节点之间的关系， 有没有环其实不用管，因为只要确保边的数量 == n - 1, 并且 **BFS** 走过一遍之后访问过了所有的点，就确定没有环了。
```python
class Solution:
    """
    @param n: An integer
    @param edges: a list of undirected edges
    @return: true if it's a valid tree, or false
    """
    def validTree(self, n, edges):
        # write your code here
        if len(edges) == 0 and n == 1:
            return True        
        if len(edges) != n - 1:
            return False
        mapping = collections.defaultdict(list)
        for edge in edges:
            mapping[edge[0]].append(edge[1])
            mapping[edge[1]].append(edge[0])
        visited = set()
        q = [0]
        while q:
            node = q.pop()
            visited.add(node)
            for neighbor in mapping[node]:
                if neighbor not in visited:
                    q.append(neighbor)
                    visited.add(neighbor)
        return len(visited) == n
```
总结：相当值得做的一道 BFS 题。注意 已经访问过的节点不要入 q，不然无向图的边会导致死循环

### [130. Surrounded Regions (Medium)](https://leetcode.com/problems/surrounded-regions/)
```html
Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.

A region is captured by flipping all 'O's into 'X's in that surrounded region.

Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
Explanation:

Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
```
```python
class Solution:
    def solve(self, board: List[List[str]]) -> None:
        """
        Do not return anything, modify board in-place instead.
        """
        if not board:
            return
        m, n = len(board), len(board[0])
        rule = lambda ij: 0 <= ij[0] < m and 0 <= ij[1] < n and board[ij[0]][ij[1]] == 'O'
        q = list(filter(rule, [ij for k in range(max(m, n)) for ij in [(0, k), (k, 0), (m - 1, k), (k, n - 1)]]))
        while q:
            (i, j) = q.pop()
            board[i][j] = 'S'
            q += list(filter(rule, [(i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j)]))
        for i in range(m):
            for j in range(n):
                if board[i][j] == 'S':
                    board[i][j] = 'O'
                else:
                    board[i][j] = 'X'
```
高频：需要改为q.pop(0)才是BFS，否则是DFS，但是代码风格放在BFS比较合适

### [675. Cut Off Trees for Golf Event (Hard)](https://leetcode.com/problems/cut-off-trees-for-golf-event/)
You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:
0 represents the obstacle can't be reached.
1 represents the ground can be walked through.
The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree's height.

You are asked to cut off all the trees in this forest in the order of tree's height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).
You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can't cut off all the trees, output -1 in that situation.
You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.

Example 1:
Input:
[
 [1,2,3],
 [0,0,4],
 [7,6,5]
]
Output: 6

Example 2:
Input:
[
 [1,2,3],
 [0,0,0],
 [7,6,5]
]
Output: -1

Example 3:
Input:
[
 [2,3,4],
 [0,0,5],
 [8,7,6]
]
Output: 6
Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.
```python
class Solution:
    def cutOffTree(self, forest):
        m, n = len(forest), len(forest[0])
        trees = [[forest[r][c], r, c] for r in range(m) for c in range(n) if forest[r][c] > 1]
        trees.sort(key = lambda x: x[0])
        ans = 0
        nextR, nextC = 0, 0
        for h, r, c in trees:
            step = self.bfs(forest, nextR, nextC, r, c, m, n)
            if step == -1:
                return -1
            else:
                forest[r][c] = 1
                nextR, nextC = r, c
                ans += step
        return ans
    def bfs(self, forest, startR, startC, endR, endC, m, n):
        step = 0
        q = [(startR, startC)]
        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        visited = set()
        while q:
            nq = []
            for _ in range(len(q)):
                r, c = q.pop()
                if r == endR and c == endC:
                    return step
                visited.add((r, c))
                for dr, dc in dirs:
                    if 0 <= r + dr <= m - 1 and 0 <= c + dc <= n - 1 and forest[r + dr][c + dc] != 0 and (r + dr, c + dc) not in visited:
                        nq.append((r + dr, c + dc))
            step += 1
            q = nq
        return -1
```
面经：Amazon。比较不偏门的算法，可惜会TLE


## Topological sorting 拓扑排序
### [LinC 127. Topological Sorting (Medium)](https://www.lintcode.com/problem/topological-sorting/description)
Given an directed graph, a topological order of the graph nodes is defined as follow:

For each directed edge A -> B in graph, A must before B in the order list.
The first node in the order can be any node in the graph with no nodes direct to it.
Find any topological order for the given graph.
You can assume that there is at least one topological order in the graph.
Clarification
[Learn more about representation of graphs](http://www.lintcode.com/help/graph)

Example:
For graph as follow:
![graph example](/images/lintcode_127_topo_1.jpeg)
The topological order can be:
[0, 1, 2, 3, 4, 5]
[0, 2, 3, 1, 5, 4]
思路：拓扑排序，算法貌似是：1.统计每个点的入度；2.将入度为 0 的点入 queue；3.从队列中 pop 点，去掉所有指向别的点的边: 相应点入度 -1；4.新入度为 0 的点入 queue
```python
"""
Definition for a Directed graph node
class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
"""
class Solution:
    """
    @param: graph: A list of Directed graph node
    @return: Any topological order for the given graph.
    """
    def topSort(self, graph):
        # write your code here
        if len(graph) == 0:
            return []
        ans = []
        inBound = {}
        for node in graph:
            if node not in inBound:
                inBound[node] = 0
            for neighbor in node.neighbors:
                if neighbor not in inBound:
                    inBound[neighbor] = 0
                inBound[neighbor] += 1
        q = collections.deque()
        for node in inBound:
            if inBound[node] == 0:
                q.append(node)
        while q:
            zNode = q.popleft()
            ans.append(zNode)
            for node in zNode.neighbors:
                inBound[node] -= 1
                if inBound[node] == 0:
                    q.append(node)
        return ans
```
总结：顺利。但是题目没有说清楚 return 的是一个拓扑排序好的 node 的 list

### [207. Course Schedule (Medium)](https://leetcode.com/problems/course-schedule/description/)
There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?

Example 1:
Input: 2, [[1,0]]
Output: true
Explanation: There are a total of 2 courses to take.
             To take course 1 you should have finished course 0. So it is possible.

Example 2:
Input: 2, [[1,0],[0,1]]
Output: false
Explanation: There are a total of 2 courses to take.
             To take course 1 you should have finished course 0, and to take course 0 you should
             also have finished course 1. So it is impossible.

Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
You may assume that there are no duplicate edges in the input prerequisites.

二刷：
```python
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        inDegree = [0] * numCourses
        graph = collections.defaultdict(list)
        for e in prerequisites:
            graph[e[1]].append(e[0])
            inDegree[e[0]] += 1
        q = []
        for i, d in enumerate(inDegree):
            if d == 0:
                q.append(i)
        while q:            
            v1 = q.pop(0)
            for v2 in graph[v1]:
                inDegree[v2] -= 1
                if inDegree[v2] == 0:
                    q.append(v2)
        for d in inDegree:
            if d != 0:
                return False
        return True
```
总结：较值得二刷的题，发现了for i, v in enumerate(list)和for k, v in dict.items()这两种用法混淆的薄弱环节。 还有对入度和建的graph概念没有完全理解
面经：Cruise。...collecitons.default **dict**()...统计入度需要...inDegree[**e[0]**] += 1...被指向的vertex入度加一

### [210. Course Schedule II (Medium)](https://leetcode.com/problems/course-schedule-ii/description/)
There are a total of n courses you have to take, labeled from 0 to n-1.
Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]
Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.
There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.

Example 1:
Input: 2, [[1,0]]
Output: [0,1]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   
             course 0. So the correct course order is [0,1] .

Example 2:
Input: 4, [[1,0],[2,0],[3,1],[3,2]]
Output: [0,1,2,3] or [0,2,1,3]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     
             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .
Note:
The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.
You may assume that there are no duplicate edges in the input prerequisites.

```python
class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:
        graph = collections.defaultdict(list)
        indegree = [0] * numCourses
        for e in prerequisites:
            graph[e[1]].append(e[0])
            indegree[e[0]] += 1
        q = []
        ans = []
        for i, v in enumerate(indegree):
            if v == 0:
                q.append(i)
                ans.append(i)
        while q:
            v1 = q.pop(0)
            for v2 in graph[v1]:
                indegree[v2] -= 1
                if indegree[v2] == 0:
                    q.append(v2)
                    ans.append(v2)
        return ans if len(ans) == numCourses else []
```
面经：Cruise。


# DFS 深度优先搜索

## Binary Tree DFS 二叉树与树上的深度优先搜索
### [257. Binary Tree Paths (Easy)](https://leetcode.com/problems/binary-tree-paths/description/)
```html
Given a binary tree, return all root-to-leaf paths.

Note: A leaf is a node with no children.

Example:

Input:

   1
 /   \
2     3
 \
  5

Output: ["1->2->5", "1->3"]

Explanation: All root-to-leaf paths are: 1->2->5, 1->3
```
思路：既然是 DFS 环节，看着就是 DFS 的解法。实现应该有坑
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def binaryTreePaths(self, root):
        """
        :type root: TreeNode
        :rtype: List[str]
        """
        ans = []
        if root == None:
            return ans
        self.helper(root, '', ans)
        return ans
    def helper(self, root, path, ans):
        if root.left == None and root.right == None:
            ans.append(path + str(root.val))
            return
        if root.left != None:
            self.helper(root.left, path + str(root.val) + '->', ans)
        if root.right != None:
            self.helper(root.right, path + str(root.val) + '->', ans)  
```
总结：递归的模板需要记，需要 path， 总答案 ans，每次进入递归函数时：1.如果已经到底，将 path append 上 root.val 并加入到 ans；2.如有左边递归左边，如有右边递归右边。注意 python + string 要先把 int 变成 str

二刷：
```python
class Solution:
    def binaryTreePaths(self, root: TreeNode) -> List[str]:
        ans = []
        if not root:
            return ans
        self.dfs(root, "", ans)
        return ans
    def dfs(self, root, path, ans):
        if path == "":
            path = str(root.val)
        else:
            path = path + "->" + str(root.val)
        if not root.left and not root.right:
            ans.append(path)
        if root.left:
            self.dfs(root.left, path, ans)
        if root.right:
            self.dfs(root.right, path, ans)
```
总结：一刷的处理整棵树是[1]这种情况和"->"放置问题更巧妙，二刷更直观，更适合面试。

### [236. Lowest Common Ancestor of a Binary Tree (Medium)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.
According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”
Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]
```
        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
```
Example 1:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of of nodes 5 and 1 is 3.

Example 2:
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself
             according to the LCA definition.

Note:
All of the nodes' values will be unique.
p and q are different and both values will exist in the binary tree.

二刷：
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if not root or p == root or q == root:
            return root
        l = self.lowestCommonAncestor(root.left, p, q)
        r = self.lowestCommonAncestor(root.right, p, q)
        if l and r:
            return root
        return l if l else r
```
总结：答案的算法是 DFS，从叶子节点向上，如果子树中有目标节点或已到底，返回目标节点或None。如果左右子树都有目标节点，则找到 LCA。...return l if l else r...
在[讨论区问了，直觉上更好理解的 l == p or l == q 为什么过不了](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/162142/Can't-tell-the-difference-between-two-versions-of-my-code-one-ac-one-fail)
二刷：左右都找到就返回root，不然有左返回左，无左返回右

非递归：
```python
class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        stack = [root]
        parent = {root: None}
        while p not in parent or q not in parent:
            n = stack.pop(-1)
            if n.left:
                stack.append(n.left)
                parent[n.left] = n
            if n.right:
                stack.append(n.right)
                parent[n.right] = n
        ancestors = set()
        while p:
            ancestors.add(p)
            p = parent[p]
        while q not in ancestors:
            q = parent[q]
        return q
```
三刷：...parent = {root: None}...


### [235. Lowest Common Ancestor of a Binary Search Tree (Easy)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)
思路：多一个 BST 树的条件， 将题变成了一个二分查找的题
```python
class Solution(object):
    def lowestCommonAncestor(self, root, p, q):
        """
        :type root: TreeNode
        :type p: TreeNode
        :type q: TreeNode
        :rtype: TreeNode
        """
        if root == None or root == p or root == q:
            return root
        if root.val > p.val and root.val > q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        elif root.val < p.val and root.val < q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        else:
            return root
```
二刷：记得进入递归的条件，和最后不进入递归的else返回就行

### [144. Binary Tree Preorder Traversal (Medium)](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)
```html
Given a binary tree, return the preorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
Follow up: Recursive solution is trivial, could you do it iteratively?
```
思路：递归写熟了确实是简单。
二刷：看了下 traverse 背后的逻辑，“拿着一个记事本, 顺着二叉树走, 走过一个, 在本子上面记下来”
![preorder-traverse-logic-image](/images/leetode_144_bina_1.jpeg)

递归 Traverse:
```python
class Solution:
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        ans = []
        if root == None:
            return ans
        self.helper(root, ans)
        return ans
    def helper(self, root, ans):
        if root == None:
            return
        ans.append(root.val)
        self.helper(root.left, ans)
        self.helper(root.right, ans)
```
非递归:
```python
class Solution:
    def preorderTraversal(self, root):   
        """
        :type root: TreeNode
        :rtype: List[int]
        """             
        ans = []
        if not root:
            return ans
        stack = []
        stack.append(root)
        while stack:
            n = stack.pop()
            ans.append(n.val)
            if n.right:
                stack.append(n.right)
            if n.left:
                stack.append(n.left)
        return ans
```
Divide and Conquer 分治:
```python
class Solution:
    def preorderTraversal(self, root):   
        """
        :type root: TreeNode
        :rtype: List[int]
        """    
        ans = []
        if not root:
            return ans
        left = self.preorderTraversal(root.left)
        right = self.preorderTraversal(root.right)
        ans.append(root.val)
        ans.extend(left)
        ans.extend(right)
        return ans        
```
总结：非递归要记住 pop，push right， push left 这个算法。就可以写对.
二刷：因为栈是先进后出，所以先 push right。分治的代码里要用 extend 来把 list 填充到另一个 list 里。
三刷：代码已经没有什么优化空间了。无他手熟尔

### [94. Binary Tree Inorder Traversal (Medium)](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)
```html
Given a binary tree, return the inorder traversal of its nodes' values.

Example:

Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
Follow up: Recursive solution is trivial, could you do it iteratively?
```
思路：递归和用栈各写一遍
二刷：递归如果不想用 instance variable，就将 ans 传到 helper 里去。
递归:
```python
class Solution:
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        ans = []
        self.dfs(root, ans)
        return ans
    def dfs(self, root, ans):
        if not root:
            return
        self.dfs(root.left, ans)
        ans.append(root.val)
        self.dfs(root.right, ans)
```
二刷：不用 class 变量就把 ans 传入 helper / dfs 函数, 把一刷的递归去掉了，看题的时候方便点。
三刷：递归方法注意主函数调用一次dfs函数，dfs递归调用自己，dfs函数中注意判断...if not root: return...
```python
class Solution:
    def inorderTraversal(self, root):
        ans = []
        stack = []
        while root or stack:
            if root:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop(-1)
                ans.append(root.val)
                root = root.right
        return ans
```
高频：递归自己就加 def __init__(): self.ans = []...if not root: return []..., 否则用 dfs(self, root, ans):...
四刷：简化删除代码，改pushAlltoLeft()为...while root or stack:...非递归/stack，需要记住代码套路

### [LinC 11.Search Range in Binary Search Tree (Medium)](http://www.lintcode.com/problem/search-range-in-binary-search-tree/)
```html
Given a binary search tree and a range [k1, k2], return all elements in the given range.

Example
If k1 = 10 and k2 = 22, then your function should return [12, 20, 22].

    20
   /  \
  8   22
 / \
4   12
```
思路：inorder traversal 的话出来的是从小到大，把符合 k1, k2 条件的返回就行了
```python
class Solution:
    def searchRange(self, root, k1, k2):
        # write your code here
        if not root:
            return []
        ans = []
        self.dfs(root, k1, k2, ans)
        return ans
    def dfs(self, root, k1, k2, ans):
        if not root:
            return
        self.dfs(root.left, k1, k2, ans)
        if root.val <= k2 and root.val >= k1:
            ans.append(root.val)
        self.dfs(root.right, k1, k2, ans)
```
二刷，非递归：
```python
class Solution:
    def searchRange(self, root, k1, k2):
        # write your code here
        ans = []
        stack = []
        while root or stack:
            if root:
                stack.append(root)
                root = root.left
            else:
                n = stack.pop(-1)
                if k1 <= n.val <= k2:
                    ans.append(n.val)
                root = n.right
        return ans
```
总结：inorder非递归模板大法：...while root or stack:...

### [LinC 448. Inorder Successor in BST (Medium)](http://www.lintcode.com/problem/inorder-successor-in-binary-search-tree/)
Leetcode 285. Inorder Successor in BST 带锁
```html
Given a binary search tree and a node in it, find the in-order successor of that node in the BST.

If the given node has no in-order successor in the tree, return null.

It's guaranteed p is one node in the given tree. (You can directly compare the memory address to find p)

Example
Given tree = [2,1] and node = 1:

  2
 /
1
return node 2.

Given tree = [2,1,3] and node = 2:

  2
 / \
1   3
return node 3.

Challenge
O(h), where h is the height of the BST.
```
思路：DFS 找这个 node， 返回这个 node inorder 的下一个 node
```python
class Solution:
    """
    @param: root: The root of the BST.
    @param: p: You need find the successor node of p.
    @return: Successor of p.
    """
    def inorderSuccessor(self, root, p):
        # write your code here
        stack = []
        found = False
        while root or stack:
            if root:
                stack.append(root)
                root = root.left
            else:
                n = stack.pop(-1)
                if found:
                    return n
                if p == n:
                    found = True
                root = n.right
```
递归:
```python
class Solution:
    def inorderSuccessor(self, root, p):
        # write your code here
        self.pre = None
        self.suc = None
        self.inOrder(root, p)
        return self.suc
    def inOrder(self, root, p):
        if not root:
            return
        self.inOrder(root.left, p)
        if self.pre == p:
            self.suc = root
        self.pre = root
        self.inOrder(root.right, p)
```
总结：递归怎么都写不对， 先抄一个非递归能理解的
二刷：递归， 需要self.pre和self.suc两个变量来返回self.suc。简化非递归，用了inorder模板...while root or stack:...

### [98. Validate Binary Search Tree (Medium)](https://leetcode.com/problems/validate-binary-search-tree/description/)
```html
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:

The left subtree of a node contains only nodes with keys less than the node's key.
The right subtree of a node contains only nodes with keys greater than the node's key.
Both the left and right subtrees must also be binary search trees.
Example 1:

Input:
    2
   / \
  1   3
Output: true
Example 2:

    5
   / \
  1   4
     / \
    3   6
Output: false
Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value
             is 5 but its right child's value is 4.
```
二刷，利用BST本身左<根<右的性质：
```python
class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        """
        :type root: TreeNode
        :rtype: bool
        """
        return self.dfs(root, -sys.maxsize, sys.maxsize)
    def dfs(self, root, minVal, maxVal):
        if not root:
            return True
        if root.val <= minVal or root.val >= maxVal:
            return False
        return self.dfs(root.left, minVal, min(root.val, maxVal)) and self.dfs(root.right, max(minVal, root.val), maxVal)
```
inorder 中序遍历额外数组：
```python
class Solution:
    def isValidBST(self, root):
        res = []
        self.inOrder(root, res)
        for i in range(1, len(res)):
            if res[i] <= res[i - 1]:
                return False
        return True
    def inOrder(self, root, res):
        if not root:
            return
        self.inOrder(root.left, res)
        res.append(root.val)
        self.inOrder(root.right, res)
```
inorder 中序遍历不适用额外数组：
```python
class Solution:
    def isValidBST(self, root):
        self.pre = -sys.maxsize
        self.valid = True
        self.inOrder(root)
        return self.valid
    def inOrder(self, n):
        if not n or not self.valid:
            return
        self.inOrder(n.left)
        if n.val <= self.pre:
            self.valid = False
            return
        self.pre = n.val
        self.inOrder(n.right)
```
inorder 中序遍历非递归：
```python
class Solution:
    def isValidBST(self, root):
        stack = []
        pre = None
        while root or stack:
            if root:
                stack.append(root)
                root = root.left
            else:
                n = stack.pop(-1)
                if pre and n.val <= pre.val:
                    return False
                pre = n
                root = n.right
        return True
```
总结：注意：1.分治最后一句 minVal 和 maxVal 的传法是 return f(root.left, minVal, min(root.val, maxVal)) and f(root.right, max(root.val, minVal), maxVal)
总结：背sys.maxsize，递归终止条件 if not root: return True; if root.val <= minVal...: return False...
高频：背maxsize, if root.val <**=** minV or root.val >**=** maxV; def dfs(...)或def inOrder(...)
三刷：...if root.val <**=** minV or root.val >= maxV:...
四刷：总结四种解法：利用BST本身左<根<右的性质的递归，中序遍历额外数组递归，中序遍历无额外数组递归，中序遍历非递归(有/无额外数组). 中序遍历非递归无额外数组:...if pre and n.val <= pre.val: return False; pre = n...

### [230. Kth Smallest Element in a BST (Medium)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/)
```html
Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note:
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

Example 1:
Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1

Example 2:
Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
Follow up:
What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?
```
思路：第一感觉是一直往下，找到最小，然后利用 BST 左边比 root 小，root 不大于右边的特性找到 K。 具体怎么实现得看答案。
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

# 第一次写能 ac 的土递归办法
class Solution(object):
    cnt = 0
    ans = 0
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        self.helper(root, k)
        return self.ans
    def helper(self, root, k):
        if root == None:
            return
        self.helper(root.left, k)
        self.cnt += 1
        if self.cnt == k:
            self.ans = root.val
            return
        self.helper(root.right, k)

# 非递归 / 栈
class Solution(object):
    def kthSmallest(self, root, k):
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
        stack = []
        while root:
            stack.append(root)
            root = root.left
        cnt = 0
        while stack:
            node = stack.pop()
            cnt += 1
            if cnt == k:
                return node.val
            if node.right:
                node = node.right
                while node:
                    stack.append(node)
                    node = node.left
```
总结：答案基本就是中序遍历，统计当前遍历的步数，到 k 返回。递归算法还是需要全局变量:(。非递归 / 栈算法用上题的套路加一个 counter 就很容易写对。 Follow up: 二叉树经常被修改 如何优化 kthSmallest 这个操作? 在 TreeNode 中增加一个 counter，代表整个树的节点个数，也可以用一个 HashMap<TreeNode, Integer> 来存储某个节点为代表的子树的节点个数。在增删查改的过程中记录不断更新受影响节点的 counter， 在 kthSmallest 的实现中用类似 Quick Select 的算法去找到 kth smallest element 时间复杂度为 O(h)，h 为树的高度。

二刷：
```python
class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -> int:
        stack = []
        while root or len(stack) > 0:
            if root:
                stack.append(root)
                root = root.left
            else:
                mid = stack.pop()
                if k != 1:
                    k -= 1
                else:
                    return mid.val
                if mid.right:
                    root = mid.right
```
总结：递归已无太多优化空间，非递归有简化版本，需背, while root or len(stack) > 0: if root... else: mid = ...pop(); ... if **mid**.right: root = mid.right

### [173. Binary Search Tree Iterator (Medium)](https://leetcode.com/problems/binary-search-tree-iterator/description/)
```html
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
```
思路：看了代码 “Your BSTIterator will be called like this” 后感觉这个 iterator 需要存一个中序遍历的队列, next() 就 popleft，hasNext() 就返回该队列是否为空。use O(h) 内存暂时不知道怎么实现
```python
# Definition for a  binary tree node
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class BSTIterator(object):
    q = collections.deque()
    def __init__(self, root):
        """
        :type root: TreeNode
        """
        if root == None:
            return
        stack = []
        while root:
            stack.append(root)
            root = root.left
        while stack:
            node = stack.pop()
            self.q.append(node.val)
            if node.right:
                node = node.right
                while node:
                    stack.append(node)
                    node = node.left

    def hasNext(self):
        """
        :rtype: bool
        """
        return len(self.q) > 0

    def next(self):
        """
        :rtype: int
        """
        return self.q.popleft()

# Your BSTIterator will be called like this:
# i, v = BSTIterator(root), []
# while i.hasNext(): v.append(i.next())
```
总结：注意全局变量（和 class method）前面加 self.，别的没什么，想好了比较好写的题

二刷：
```python
class BSTIterator:
    q = collections.deque()
    def __init__(self, root: TreeNode):
        stack = []
        while root or len(stack) > 0:
            if root:
                stack.append(root)
                root = root.left
            else:
                mid = stack.pop()
                self.q.append(mid.val)
                if mid.right:
                    root = mid.right

    def next(self) -> int:
        """
        @return the next smallest number
        """
        if self.hasNext():
            return self.q.popleft()

    def hasNext(self) -> bool:
        """
        @return whether we have a next smallest number
        """
        return len(self.q) > 0
```
总结：上一题的非递归要背 while root or len(stack) > 0: if **root**: stack.append...; root = root.left...

### [LinC 900. Closest Binary Search Tree Value (Easy)](https://www.lintcode.com/problem/closest-binary-search-tree-value/description)
Leetcode 270. Closest Binary Search Tree Value 带锁
```html
Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.

Given target value is a floating point.
You are guaranteed to have only one unique value in the BST that is closest to the target.
Example
Given root = {1}, target = 4.428571, return 1.
```
```python
"""
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
"""
class Solution:
    """
    @param root: the given BST
    @param target: the given target
    @return: the value in the BST that is closest to the target
    """
    # 最直观
    def closestValue(self, root, target):
        # write your code here
        ans = root.val
        while root:
            if abs(root.val - target) < abs(ans - target):
                ans = root.val
            if root.val < target:
                root = root.right
            else:
                root = root.left
        return ans

    # 递归回溯
    def closestValue(self, root, target):
        # write your code here
        tempA = root.val
        if tempA < target:
            root = root.right
        else:
            root = root.left
        if root == None:
            return tempA
        tempB = self.closestValue(root, target)
        return tempA if abs(tempA - target) < abs(tempB - target) else tempB
```
总结：最直观的是根据 BST 性质二分查找；除此之外还有递归（回溯）和迭代 / stack / 中序遍历（维护一个最小值）两种写法。直观写法需要注意：1.ans 赋值的条件；2.root 往哪边走的条件。 递归（回溯）写法要注意：1.返回的条件放的位置（在决定往哪边走之后）；递归完之后还要判断最后返回哪个值

### [113. Path Sum II (Medium)](https://leetcode.com/problems/path-sum-ii/)
```html
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]
```
```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> List[List[int]]:
        ans = []
        self.dfs(root, sum, [], ans)
        return ans
    def dfs(self, root, target, path, ans):
        if not root:
            return
        if target == root.val and not root.left and not root.right:
            ans.append(path[:] + [root.val])
            return
        path.append(root.val)
        self.dfs(root.left, target - root.val, path, ans)
        self.dfs(root.right, target - root.val, path, ans)
        del path[-1]
```
高频：...if...s == root.val:...dfs(...path + [root.val],...)
面经：Quora, 大疆。
todo 再刷可以用非递归while stack: (n, s, path) = q.pop()

### [129. Sum Root to Leaf Numbers (Medium)](https://leetcode.com/problems/sum-root-to-leaf-numbers/)
```html
Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path 1->2->3 which represents the number 123.

Find the total sum of all root-to-leaf numbers.

Note: A leaf is a node with no children.

Example:

Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1->2 represents the number 12.
The root-to-leaf path 1->3 represents the number 13.
Therefore, sum = 12 + 13 = 25.
Example 2:

Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4->9->5 represents the number 495.
The root-to-leaf path 4->9->1 represents the number 491.
The root-to-leaf path 4->0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
```
二刷：
```python
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        if not root:
            return 0
        s = [(root, 0)]
        ans = 0
        while s:
            n, v = s.pop(-1)
            if n:
                if not n.left and not n.right:
                    ans += v * 10 + n.val
                if n.left:
                    s.append((n.left, v * 10 + n.val))
                if n.right:
                    s.append((n.right, v * 10 + n.val))
        return ans
```
总结：非递归stack + dfs
高频
```python
class Solution:
    def sumNumbers(self, root: TreeNode) -> int:
        return self.helper(root, 0)
    def helper(self, root, val):
        if not root:
            return 0
        if not root.left and not root.right:
            return val * 10 + root.val
        return self.helper(root.left, val * 10 + root.val) + self.helper(root.right, val * 10 + root.val)
```
总结：递归...if not root: return 0...return helper(...val * 10 + root.val) + helper(...)

### [437. Path Sum III (Medium)](https://leetcode.com/problems/path-sum-iii/)
You are given a binary tree in which each node contains an integer value.
Find the number of paths that sum to a given value.
The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.

Example:
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:
1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11

Brute force：遍历一遍，每个节点开始走DFS
```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        self.ans = 0
        self.preorder(root, sum)
        return self.ans
    def preorder(self, root, target):
        if not root:
            return
        self.dfs(root, target)
        self.preorder(root.left, target)
        self.preorder(root.right, target)
    def dfs(self, root, target):
        if not root:
            return
        if target == root.val:
            self.ans += 1
        self.dfs(root.left, target - root.val)
        self.dfs(root.right, target - root.val)
```
DFS + Memo：
```python
class Solution:
    def pathSum(self, root: TreeNode, sum: int) -> int:
        self.ans = 0
        self.dfs(root, sum, 0, {0: 1})
        return self.ans
    def dfs(self, root, target, curPathSum, memo):
        if not root:
            return
        curPathSum += root.val
        oldPathSum = curPathSum - target
        self.ans += memo.get(oldPathSum, 0)
        memo[curPathSum] = memo.get(curPathSum, 0) + 1
        self.dfs(root.left, target, curPathSum, memo)
        self.dfs(root.right, target, curPathSum, memo)
        memo[curPathSum] -= 1
```
面经：Quora。...oldPathSum = **curPathSum - target**...

## Binary Tree Divide Conquer 二叉树与分治

### [100. Same Tree (Easy)](https://leetcode.com/problems/same-tree/)
Given two binary trees, write a function to check if they are the same or not.
Two binary trees are considered the same if they are structurally identical and the nodes have the same value.
```
Example 1:
Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]
Output: true

Example 2:
Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]
Output: false

Example 3:
Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]
Output: false
```

递归：
```python
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        if not p and not q:
            return True
        elif (p and not q) or (q and not p) or p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```
非递归：
```python
class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -> bool:
        s1, s2 = [p], [q]
        while s1 and s2:
            n1, n2 = s1.pop(), s2.pop()
            if not n1 and not n2:
                continue
            if (n1 and not n2) or (n2 and not n1) or n1.val != n2.val:
                return False
            s1.append(n1.left)
            s1.append(n1.right)
            s2.append(n2.left)
            s2.append(n2.right)
        return not s1 and not s2
```
高频：非递归如果pop(0)为先续遍历preorder traversal
二刷：递归...elif (p and not q) or (...

### [101. Symmetric Tree (Easy)](https://leetcode.com/problems/symmetric-tree/)
Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).
```
For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following [1,2,2,null,3,null,3] is not:
    1
   / \
  2   2
   \   \
   3    3
```
Note:
Bonus points if you could solve it both recursively and iteratively.

递归
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        def helper(l, r):
            if not l and not r:
                return True
            if (l and not r) or (r and not l):
                return False
            return l.val == r.val and helper(l.left, r.right) and helper(l.right, r.left)
        return helper(root.left, root.right)
```
非递归
```python
class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        s = [root.left, root.right]
        while s:
            l, r = s.pop(), s.pop()
            if not l and not r:
                continue
            if (l and not r) or (r and not l) or l.val != r.val:
                return False
            s.append(l.left)
            s.append(r.right)
            s.append(l.right)
            s.append(r.left)
        return True
```
高频：递归：...helper(**l.left, r.right**) and helper(l.right, r.left)。非递归：...if not l and not r: **continue**...
二刷：递归：...helper(**l.left, r.right**) and...

### [104. Maximum Depth of Binary Tree (Easy)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)
Given a binary tree, find its maximum depth.
The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
Note: A leaf is a node with no children.
```
Example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.
```
三刷，递归：
```python
class Solution:
    def maxDepth(self, root):
        if not root:
            return 0
        return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1
```
非递归：
```python
class Solution:
    def maxDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        ans = 0
        q = [root]
        while q:
            ans += 1
            nq = []
            for n in q:
                if n.left:
                    nq.append(n.left)
                if n.right:
                    nq.append(n.right)
            q = nq
        return ans
```
总结：不常练就容易简单递归也写不出
高频：删掉1，2刷的代码和总结，基本都是递归二分法的套路。非递归：注意[None]和[]不等
四刷：高频的q不错

### [110. Balanced Binary Tree (Easy)](https://leetcode.com/problems/balanced-binary-tree/description/)
Given a binary tree, determine if it is height-balanced.
For this problem, a height-balanced binary tree is defined as:
a binary tree in which the depth of the two subtrees of every node never differ by more than 1.
```
Example 1:
Given the following tree [3,9,20,null,null,15,7]:
    3
   / \
  9  20
    /  \
   15   7
Return true.

Example 2:
Given the following tree [1,2,2,3,3,null,null,4,4]:
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
Return false.
```
二刷：
```python
class Solution:
    def isBalanced(self, root):
        self.balanced = True
        self.maxDepth(root)
        return self.balanced
    def maxDepth(self, root):
        if not root:
            return 0
        l = self.maxDepth(root.left)
        r = self.maxDepth(root.right)
        if abs(l - r) > 1:
            self.balanced = False
        return max(l, r) + 1
```
总结：简化代码，self.balanced必须是全局变量，否则会出错
高频：self.balanced = True; def max_depth(root):...return **max(l, r) + 1**...
三刷：递归有用到104题二叉树的最大深度
四刷：有个[youtube视频解释的特别清楚](https://www.youtube.com/watch?v=LU4fGD-fgJQ)

### [114. Flatten Binary Tree to Linked List (Medium)](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/)
Given a binary tree, flatten it to a linked list in-place.
```
For example, given the following tree:
    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```
高频：
```python
class Solution:
    def flatten(self, root: TreeNode) -> None:
        self.prev = None
        self.helper(root)
    def helper(self, root):
        if not root:
            return
        self.helper(root.right)
        self.helper(root.left)
        root.right = self.prev
        root.left = None
        self.prev = root
```
总结：简洁代码，套路要直观很多，先递归右，然后左子树，然后拼接root.right = self.prev; root.left = None; self.prev = root
三刷：既然要靠背，就背个代码量少的，讨论区叫reverse preorder。...递归right; 递归left; 接右；清左；设prev
四刷：reverse preorder...f(root.right)...f(root.left); root.right = ...root.left = None; prev = root

### [109. Convert Sorted List to Binary Search Tree (Medium)](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/)
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.
For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:
Given the sorted linked list: [-10,-3,0,5,9],
One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:
```
      0
     / \
   -3   9
   /   /
 -10  5
```
space: O(n):
```python
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        nums = []
        while head:
            nums.append(head.val)
            head = head.next
        return self.helper(nums, 0, len(nums) - 1)
    def helper(self, nums, l, r):
        if l < r:
            mid = l + (r - l) // 2
            root = TreeNode(nums[mid])
            root.left = self.helper(nums, l, mid - 1)
            root.right = self.helper(nums, mid + 1, r)
            return root
        elif l == r:
            return TreeNode(nums[l])
```
space: O(1):
```python
class Solution:
    def sortedListToBST(self, head: ListNode) -> TreeNode:
        return self.helper(head, None)
    def helper(self, l, r):
        if l == r:
            return None
        s, f = l, l
        while f != r and f.next != r:
            s = s.next
            f = f.next.next
        root = TreeNode(s.val)
        root.left = self.helper(l, s)
        root.right = self.helper(s.next, r)
        return root
```
高频：...if h == t: return None...while f != t and f.next != t...toBST(h, s)...toBST(s.next, t)...
二刷：space: O(1):...while f != r and f.next != r:...f(l, s)...f(s.next, r)...

### [112. Path Sum (Easy)](https://leetcode.com/problems/path-sum/)
```html
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
```
高频
```python
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        if root.val == sum and not root.left and not root.right:
            return True
        return self.hasPathSum(root.left, sum - root.val) or self.hasPathSum(root.right, sum - root.val)
```
面经： Quora。

### [108. Convert Sorted Array to Binary Search Tree (Easy)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/)
```html
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:

Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```
```python
class Solution:
  def sortedArrayToBST(self, nums: List[int]) -> TreeNode:
      if not nums:
          return
      mid = (len(nums) - 1) // 2
      root = TreeNode(nums[mid])
      root.left = self.sortedArrayToBST(nums[:mid])
      root.right = self.sortedArrayToBST(nums[mid + 1:])
      return root
```
高频：**if not nums: return**...mid =...root = ...root.left = ...root.right = ...return root
面经：Amazon ...mid = (len(nums) - 1) // 2...root.left =...return root

### [105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
```html
Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.

For example, given

preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7
```
```python
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if inorder:
            rI = inorder.index(preorder.pop(0))
            root = TreeNode(inorder[rI])
            root.left = self.buildTree(preorder, inorder[:rI])
            root.right = self.buildTree(preorder, inorder[rI + 1:])
            return root
```
高频：精髓是找到当层递归的root index，然后递归左右子树

### [106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)](https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
```python
class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        idx_map = {v:i for i, v in enumerate(inorder)}
        def helper(l, r):
            if l > r:
                return None
            val = postorder.pop()
            root = TreeNode(val)
            i = idx_map[val]
            root.right = helper(i + 1, r)
            root.left = helper(l, i - 1)
            return root
        return helper(0, len(inorder) - 1)
```
高频：上题的解法：...buildTree(...**postorder[:i]**)...buildTree(...postorder[i:])...更高效的新解法：...root.**right** = ... root.left = ...

### [116. Populating Next Right Pointers in Each Node (Medium)](https://leetcode.com/problems/populating-next-right-pointers-in-each-node/)
```html
You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.
```
```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        if root.left:
            root.left.next = root.right
            root.right.next = root.next.left if root.next else None
        self.connect(root.left)
        self.connect(root.right)
        return root
```
非递归
```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        q = []
        q.append(root)
        while q:
            nq = []
            for i, n in enumerate(q):
                if i < len(q) - 1:
                    n.next = q[i + 1]
                if n.left:
                    nq.append(n.left)
                    nq.append(n.right)
            q = nq
        return root
```
高频：递归分制比较好理解，刷了一个好理解的用q的非递归，更巧妙的pre，cur双指针相比之下不那么适合面试

### [117. Populating Next Right Pointers in Each Node II (Medium)](https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/)
```html
Given a binary tree

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Example:
Input: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":null,"right":null,"val":4},"next":null,"right":{"$id":"4","left":null,"next":null,"right":null,"val":5},"val":2},"next":null,"right":{"$id":"5","left":null,"next":null,"right":{"$id":"6","left":null,"next":null,"right":null,"val":7},"val":3},"val":1}

Output: {"$id":"1","left":{"$id":"2","left":{"$id":"3","left":null,"next":{"$id":"4","left":null,"next":{"$id":"5","left":null,"next":null,"right":null,"val":7},"right":null,"val":5},"right":null,"val":4},"next":{"$id":"6","left":null,"next":null,"right":{"$ref":"5"},"val":3},"right":{"$ref":"4"},"val":2},"next":null,"right":{"$ref":"6"},"val":1}

Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B.
Note:
You may only use constant extra space.
Recursive approach is fine, implicit stack space does not count as extra space for this problem.
```
```python
class Solution:
    def connect(self, root: 'Node') -> 'Node':
        if not root:
            return None
        leaf = root.next
        while leaf:
            if leaf.left:
                leaf = leaf.left
                break
            if leaf.right:
                leaf = leaf.right
                break
            leaf = leaf.next
        if root.left:
            root.left.next = root.right if root.right else leaf
        if root.right:
            root.right.next = leaf
        self.connect(root.right)
        self.connect(root.left)
        return root
```
高频：由于平层有可能子节点缺失，需要寻找到平层的最近子节点。递归时要右建立一些next关系再左，...while leaf:...leaf = leaf.next...root.right.next = leaf...数据结构导致debug很困难，需要记住答案。

### [111. Minimum Depth of Binary Tree (Easy)](https://leetcode.com/problems/minimum-depth-of-binary-tree/)
```html
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
return its minimum depth = 2.
```
递归
```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        l = self.minDepth(root.left)
        r = self.minDepth(root.right)
        return l + r + 1 if l == 0 or r == 0 else min(l, r) + 1
```
非递归
```python
class Solution:
    def minDepth(self, root: TreeNode) -> int:
        if not root:
            return 0
        q = [root]
        ans = 0
        while(q):
            ans += 1
            nq = []
            for n in q:
                if not n.left and not n.right:
                    return ans
                if n.left:
                    nq.append(n.left)
                if n.right:
                    nq.append(n.right)
            q = nq
```
高频：与上一题的不同是要考虑左子树和右子树长度为0的情况，因为长度定义为节点到叶子。...l = f(root.left); r = f(root.right); return l + r + 1 if l == 0 or...。非递归：if not n.left and not n.right: return res...

### [226. Invert Binary Tree (Easy)](https://leetcode.com/problems/invert-binary-tree/description/)
```html
Invert a binary tree.

Example:

Input:

     4
   /   \
  2     7
 / \   / \
1   3 6   9
Output:

     4
   /   \
  7     2
 / \   / \
9   6 3   1
Trivia:
This problem was inspired by this original tweet by Max Howell:
Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.
```
非递归：
```python
class Solution(object):
    def invertTree(self, root):
        """
        :type root: TreeNode
        :rtype: TreeNode
        """
        if root == None:
            return root
        processQ = []
        processQ.append(root)
        while processQ:
            nextLevel = []
            for node in processQ:
                if node.left:
                    nextLevel.append(node.left)
                if node.right:
                    nextLevel.append(node.right)
                node.left, node.right = node.right, node.left
            processQ = nextLevel
        return root
```
递归：
```python
class Solution:
    def invertTree(self, root: TreeNode) -> TreeNode:
        if not root:
            return None
        l = self.invertTree(root.left)
        r = self.invertTree(root.right)
        root.right = l
        root.left = r
        return root
```
高频：删掉了思路和1，2，3刷的总结，def dfs(...的非模板代码，没有什么价值。增加了递归代码

### [701. Insert into a Binary Search Tree (Medium)](https://leetcode.com/problems/insert-into-a-binary-search-tree/description/)
[LinC Insert Node in a Binary Search Tree](http://www.lintcode.com/problem/insert-node-in-a-binary-search-tree/)
Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.
Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.

For example,
Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
You can return this binary search tree:
         4
       /   \
      2     7
     / \   /
    1   3 5
This tree is also valid:
         5
       /   \
      2     7
     / \   
    1   3
         \
          4
非递归：
```python
class Solution:
    def insertIntoBST(self, root, val):
        """
        :type root: TreeNode
        :type val: int
        :rtype: TreeNode
        """
        node = TreeNode(val)
        cur = root
        while cur.val != node.val:
            if cur.val < node.val:
                if not cur.right:
                    cur.right = node
                cur = cur.right
            else:
                if not cur.left:
                    cur.left = node
                cur = cur.left
        return root
```
递归：
```python
class Solution:
    def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
        if not root:
            return TreeNode(val)
        if val > root.val:
            root.right = self.insertIntoBST(root.right, val)
        else:
            root.left = self.insertIntoBST(root.left, val)
        return root
```
二刷：...if val > root.val: root.right = f(...)...


## Combination based DFS - 基于组合的深度优先搜索
### [78. Subsets (Medium)](https://leetcode.com/problems/subsets/description/)
```html
Given a set of distinct integers, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]
```
思路：不太擅长组合和排列的题。这道题确实更像排列题，子集全排。DFS 模板：1.遍历输入元素；2.将当前元素加入 path；3。遍历递归当前元素之后的元素 i + 1；4：剪枝，将最后一个元素从 path 中去掉
```python
class Solution(object):
    ans = []
    def subsets(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        self.ans = []
        self.dfs([], 0, nums)
        return self.ans
    def dfs(self, path, index, nums):
        self.ans.append(path[:])
        for innerIndex in range(index, len(nums)):
            path.append(nums[innerIndex])
            self.dfs(path, innerIndex + 1, nums)
            path.pop()        
```
总结：在 dfs 里，往 self.ans 添加答案的时候需要用 deep copy，不然的话会发生 self.ans 里面全是空的状况（感觉是因为最后剪枝的原因）。时间复杂度为 O(n*2^n) 指数级时间， 因为产生 2^n 个子 list，每个 list 的长度是 n 级的
二刷：这类 combination 的题要用 start，遍历递归时递归 i + 1 元素; 模板不直接遍历元素了， 下一题 permutation 三刷把代码改成模板，就没有 confusion 了。

三刷：
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        self.dfs([], 0, nums)
        return self.ans
    def dfs(self, path, start, nums):
        self.ans.append(path[:])
        for i in range(start, len(nums)):
            path.append(nums[i])
            self.dfs(path, i + 1, nums)
            path.pop()
```
总结：dfs内层循环中调用递归要用i + 1，如果用start会导致结果中重复使用相同位置的元素
高频：...dfs(path, start): ans.append(path[:])...注意此处无条件加入ans

### [39. Combination Sum (Medium)](https://leetcode.com/problems/combination-sum/description/)
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.

Example 1:
Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]

Example 2:
Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```python
class Solution:
    def combinationSum(self, candidates, target):
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
        ans = []
        candidates.sort()
        self.dfs(candidates, target, [], ans, 0)
        return ans
    def dfs(self, candidates, target, cur, ans, start):
        if sum(cur) == target:
            ans.append(cur[:])
            return
        for i in range(start, len(candidates)):
            if sum(cur) + candidates[i] > target:
                break
            cur += [candidates[i]]
            self.dfs(candidates, target, cur, ans, i)
            del cur[-1]
```
总结：if target < 0: return 改成 if target - candidates[i] < 0: break，效率提升
高频：...dfs(total, path, start):...for i in range(**start**, len(candidates)):...dfs(total - n, path, **i**)...最后这个i千万不能写成不动的start了，极难de此bug
面经：Amazon。...dfs(...**start**):...for i in range(start, len(...))...self.dfs(...**i**)...

### [40. Combination Sum II (Medium)](https://leetcode.com/problems/combination-sum-ii/description/)
```html
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

Each number in candidates may only be used once in the combination.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]
Example 2:

Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
```
```python
class Solution:
    def combinationSum2(self, candidates, target):
        candidates.sort()
        ans = []
        self.dfs(candidates, target, ans, [], 0)
        return ans
    def dfs(self, candidates, target, ans, cur, start):
        if sum(cur) == target:
            ans.append(cur[:])
            return
        for i in range(start, len(candidates)):
            if sum(cur) + candidates[i] > target:
                break
            if i > start and candidates[i] == candidates[i - 1]:
                continue
            cur += [candidates[i]]
            self.dfs(candidates, target, ans, cur, i + 1)
            del cur[-1]
```
高频：删去一二刷的代码和总结，因为用的模板都不够容易记，三刷虽然执行效率很高却破坏了模板，不适合面试。...def dfs(path, target, start):...for i in range(**start**, n): **if i > start** and ...
面经：Amazon。...**if i > start** and...

### [216. Combination Sum III (Medium)](https://leetcode.com/problems/combination-sum-iii/description/)
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.

Note:
All numbers will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: k = 3, n = 7
Output: [[1,2,4]]
Example 2:

Input: k = 3, n = 9
Output: [[1,2,6], [1,3,5], [2,3,4]]
```python
class Solution:
    def combinationSum3(self, k, n):
        """
        :type k: int
        :type n: int
        :rtype: List[List[int]]
        """
        ans = []
        self.dfs(k, n, ans, [], 1)
        return ans
    def dfs(self, k, target, ans, cur, start):
        if sum(cur) == target and len(cur) == k:
            ans.append(cur[:])
            return
        for i in range(start, 10):
            if sum(cur) + i > target:
                break
            cur += [i]
            self.dfs(k, target, ans, cur, i + 1)
            del cur[-1]
```
面经：删除了1，2刷的代码

### [77. Combinations (Medium)](https://leetcode.com/problems/combinations/)
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

Example:
Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```python
class Solution:
    def combine(self, n, k):
        ans = []
        self.dfs(n, k, ans, [], 1)
        return ans
    def dfs(self, n, k, ans, cur, start):
        if len(cur) == k:
            ans.append(cur[:])
        for i in range(start, n + 1):
            cur += [i]
            self.dfs(n, k, ans, cur, i + 1)
            del cur[-1]
```
面经：Amazon。

### [131. Palindrome Partitioning (Medium)](https://leetcode.com/problems/palindrome-partitioning/description/)
```html
Given a string s, partition s such that every substring of the partition is a palindrome.

Return all possible palindrome partitioning of s.

Example:

Input: "aab"
Output:
[
  ["aa","b"],
  ["a","a","b"]
]
```
思路：看了下答案， 唯一不太好懂的地方是 start >= len(s) 才入 self.ans， 写好以后用测试数据看看为什么
```python
class Solution(object):
    def partition(self, s):
        """
        :type s: str
        :rtype: List[List[str]]
        """
        self.ans = []
        if len(s) == 0:
            return self.ans
        self.dfs(s, [], 0)
        return self.ans
    def dfs(self, s, path, start):
        if start >= len(s):
            self.ans.append(path[:])
            return
        for index in range(start, len(s)):
            subS = s[start:index + 1]
            if self.isPalindrome(subS):
                path.append(subS)
                self.dfs(s, path, index + 1)
                path.pop()
    def isPalindrome(self, s):
        return s == s[::-1]
```
总结：注意：1.subStr[0:1] 返回第一个 char，[0:2] 返回 [0][1] 位置的 subStr；2.python 检查 palindrom 可以用 s == s[::-1]；3.self.ans.append(path[:]) 以后记得 return; 4.range(start, len(s)) 可以通过测试数据纠正。之所以用 start >= len(s) 是因为要把 s 拆完一遍才能入 self.ans

二刷：
```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        self.ans = []
        self.dfs(s, [], 0)
        return self.ans
    def dfs(self, s, path, start):
        if start == len(s):
            self.ans.append(path[:])
        for i in range(start, len(s)):
            subS = s[start : i + 1]
            if subS == subS[::-1]:
                path.append(subS)
                self.dfs(s, path, i + 1)
                path.pop()
```
总结：稍微精简了一下，要注意s[start : end], s[::-1]写法
高频：...dfs(path, start): if start == len(s):...subS = s[start **:** i + 1]...不是start == len(s) - 1

### [93. Restore IP Addresses (Medium)](https://leetcode.com/problems/restore-ip-addresses/description/)
```html
Given a string containing only digits, restore it by returning all possible valid IP address combinations.

Example:

Input: "25525511135"
Output: ["255.255.11.135", "255.255.111.35"]
```
思路：从上面的 131. Palindrome Partitioning (Medium) 和 LinC 680. Split String (Easy) 获得了灵感
```python
class Solution:
    def restoreIpAddresses(self, s):
        """
        :type s: str
        :rtype: List[str]
        """
        if len(s) > 12 or len(s) < 4:
            return []
        ans = []
        self.dfs(s, '', 0, ans)
        return ans
    def dfs(self, s, path, start, ans):
        if path.count('.') > 4:
            return
        if len(path) == len(s) + 4:
            ans.append(path[:-1])
            return
        for i in range(start, len(s)):
            if self.isValid(s[start:i + 1]):
                path += s[start:i + 1] + '.'
                self.dfs(s, path, i + 1, ans)
                path = path[:-(i + 2 - start)]
    def isValid(self, s):
        if len(s) > 3:
            return False
        if len(s) > 1 and s[0] == '0':
            return False
        return int(s) >= 0 and int(s) <= 255
```
总结：很多细节：1. start 跟着 i 走，没有前进；2. 遍历字符串取子串的时候要 range(, len + 1)， 不然会取不到最后一个字符
不算二刷，以上注意的第 2 点可以简化为取 s[start:i + 1]; 从上题 131. Palindrome Partitioning (Medium) 学的。

二刷：
```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        if len(s) < 4 or len(s) > 12:
            return []
        res = []
        def isValid(num):
            return 0 <= int(num) <= 255 and str(int(num)) == num
        def dfs(path, start):
            if len(path) > 4:
                return
            if len(path) == 4 and len(''.join(path)) == len(s):
                res.append(path[:])
                return
            for i in range(start, len(s)):
                subS = s[start: i + 1]
                if isValid(subS):
                    path.append(subS)
                    dfs(path, i + 1)
                    path.pop()
        dfs([], 0)
        return ['.'.join(i) for i in res]
```
高频：...subS = s[start: i + 1]...

### [LinC 680. Split String (Easy)](https://www.lintcode.com/problem/split-string/description)
```html
Give a string, you can choose to split the string after one character or two adjacent characters, and make the string to be composed of only one character or two characters. Output all possible results.

Example
Given the string "123"
return [["1","2","3"],["12","3"],["1","23"]]
```
思路：看了下答案，主要的文章就在递归退出的条件和 DFS 中 for 循环的起始条件。边写边想。
```python
class Solution:
    """
    @param: : a string to be split
    @return: all possible split string array
    """

    def splitString(self, s):
        # write your code here
        if len(s) == 0:
            return [[]]
        self.ans = []
        self.dfs(s, [], 0)
        return self.ans
    def dfs(self, s, path, start):
        if start >= len(s):
            self.ans.append(path[:])
            return
        for index in range(start, start + 2):
            if index < len(s):
                path.append(s[start:index + 1])
                self.dfs(s, path, index + 1)
                path.pop()
```
总结：空输入的输出有点 wacky，for 循环内注意查越界（可以通过测试一个数据实现）

### [90. Subsets II (Medium)](https://leetcode.com/problems/subsets-ii/description/)
```html
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
```
```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        ans = []
        def dfs(path, start):
            ans.append(path[:])
            for i in range(start, len(nums)):
                if i > start and nums[i] == nums[i - 1]:
                    continue
                path.append(nums[i])
                dfs(path, i + 1)
                path.pop()
        nums.sort()
        dfs([], 0)
        return ans
```
高频：将1，2刷的思路，代码和总结都删掉了，遵循模板的答案。...if i > **start** and ...

### [140. Word Break II (Hard)](https://leetcode.com/problems/word-break-ii/)
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.

Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
Output:
[
  "cats and dog",
  "cat sand dog"
]
Example 2:

Input:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
Output:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
Explanation: Note that you are allowed to reuse a dictionary word.
Example 3:

Input:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
Output:
[]

九章：DFS算法的掌握，主要在练习; 一个题第一遍不顺利，就要写第二遍，第三遍; 像 Word Break II 纯 DFS 版本 和 Regular Expression Matching 这样的问题，要练到 30 分钟内 AC。做不到就反复再练。
Strong Hire: DFS+DP优化
Hire / Weak Hire: DFS 能写完，且 Bug free or Bug 不多，不需要提示 or 需要少量提示
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:
        return self.dfs(s, wordDict, {})
    def dfs(self, s, wordDict, memo):
        if s in memo:
            return memo[s]
        res = []
        for w in wordDict:
            if not s.startswith(w):
                continue
            if len(w) == len(s):
                res.append(w)
            restOfWords = self.dfs(s[len(w):], wordDict, memo)
            for item in restOfWords:
                item = f"{w} {item}"
                res.append(item)
        memo[s] = res
        return res
```
面经：Amazon。...item = f"{w} {item}"; res.append(item)...


## Permutation based DFS - 基于排列的深度优先搜索
### [46. Permutations (Medium)](https://leetcode.com/problems/permutations/description/)
```html
Given a collection of distinct integers, return all possible permutations.

Example:

Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```
思路：答案说要记具体某个点是否已经被访问过。写写看有没有什么坑
```python
class Solution(object):
    def permute(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        if len(nums) == 0:
            return []
        ans = []
        self.visited = {}
        for i in range(len(nums)):
            self.visited[i] = False
        self.dfs(nums, [], ans)
        return ans
    def dfs(self, nums, path, ans):
        if len(path) == len(nums):
            ans.append(path[:])
            return
        for i in range(len(nums)):
            if self.visited[i]:
                continue
            path.append(nums[i])
            self.visited[i] = True
            self.dfs(nums, path, ans)
            path.pop()
            self.visited[i] = False
```
总结：思路 OK 的话貌似没有什么明显的坑
二刷：和 subset 和 combination sum 不同点在于排列进入 dfs 不需要 start 这个参数; 记得要有 self.visited, 存 path 的时候要 deep copy
三刷：遍历进递归的循环走 i, 和其他 DFS 模板保持一致。这题可以通过 if self.visited[i]: continue 来记需要一个 self.visited

四刷：
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        self.dfs(nums, [])
        return self.ans
    def dfs(self, nums, path):
        if len(path) == len(nums):
            self.ans.append(path[:])
            return
        for num in nums:
            if num in path:
                continue
            path.append(num)
            self.dfs(nums, path)
            path.pop()
```
总结：比较简化的方法，重点是去重的机制，if num in path: continue。无需start，模板类似
高频：背dfs(path):...if n in path: continue...

### [47. Permutations II (Medium)](https://leetcode.com/problems/permutations-ii/description/)
```html
Given a collection of numbers that might contain duplicates, return all possible unique permutations.

Example:

Input: [1,1,2]
Output:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```
思路：看了下答案，比上一题要多处理的两件事：1.要排序；2.对于相同的数在 for 循环里跳过；此处 for 循环要用 index 了因为有重复的数，要用 dict 统计该位置是否被用过
```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        if n < 2:
            return [nums]
        visited = {i: False for i in range(n)}
        ans = []        
        def dfs(path):
            if len(path) == n:
                ans.append(path[:])
                return
            for i in range(n):
                if visited[i]:
                    continue
                if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1]:
                    continue
                visited[i] = True
                path.append(nums[i])
                dfs(path)
                visited[i] = False
                path.pop()
        nums.sort()
        dfs([])
        return ans
```
总结：注意相同数的跳过方法，需要用 if i > 0 and nums[i] == nums[i - 1] and not visited[i - 1] i.e. 如果相等，需要前面的已经用过了才能用（相等且 i - 1 用过了就**不** continue，就是说这个重复的数是给前面的轮次在用）
二刷：和 combination sum II 的类似之处是 input 都可能有重复的元素。 和 permutation 类似之处是也需要 visited 记录已使用的元素。不同是 iterate 的时候要用 i, 还要 i == i - 1 and visited[i - 1] == False 来去重; dfs 里 iterate 的时候记得 if not self.visited；要细心，...and visited[i - 1] == false

三刷：
```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        self.ans = []
        nums.sort()
        self.dfs(nums, [])
        return self.ans
    def dfs(self, nums, path):
        if len(nums) == 0:
            self.ans.append(path[:])
            return
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            self.dfs(nums[:i] + nums[i + 1:], path + [nums[i]])
```
总结：更简洁的代码， 重点是递归终止的条件if len(nums) == 0:...;递归的方法self.dfs(nums[:i] + nums[i + 1:], path + [nums[i]])一步步将元素搬到path中
高频：三刷的方法更加巧妙， 直接传进去的时候就把nums里用过的当前元素给剪了。好懂一些的模板还是用一二刷的。需要背...if i > 0 and nums[i] == nums[i - 1] and **not visited[i - 1]**:...这个剪枝条件

### [LinC 862. Next Closest Time (Medium)](https://www.lintcode.com/problem/next-closest-time/description)
```html
Given a time represented in the format "HH:MM", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.

You may assume the given input string is always valid. For example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.

Example：
Given time = "19:34", return "19:39".
Explanation:
The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.

Given time = "23:59", return "22:22".
Explanation:
The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically.
```
思路：属于对我来说现场想很费时的题。直接看答案找思路
```python
class Solution:
    """
    @param time: the given time
    @return: the next closest time
    """
    def nextClosestTime(self, time):
        # write your code here
        s = set(time)
        if len(s) == 2:
            return time
        digits = time[0:2] + time[3:5]
        self.ans = ''
        self.minDiff = sys.maxsize
        self.target = int(time[0:2]) * 60 + int(time[3:5])
        self.dfs(digits, '', 0)
        return self.ans
    def dfs(self, digits, path, start):
        if start == 4:
            # path 产生了一个合法的时间，判断和 target 距离 diff 和 self.minDiff 的关系
            m = int(path[0:2]) * 60 + int(path[2:4])
            diff = m - self.target
            if diff == 0:
                return
            if diff < 0:
                diff = 24 * 60 + diff
            if diff < self.minDiff:
                self.minDiff = diff
                self.ans = path[0:2] + ':' + path[2:4]
            return
        for digit in digits:
            # 处理 path, 把不合适的时间都 continue 过去, 但是怎么判断现在处理的是哪个位置？看了下答案， 其实不需要 enumerate
            if start == 0 and int(digit) > 2:
                continue
            if start == 1 and int(path) * 10 + int(digit) > 23:
                continue
            if start == 2 and int(digit) > 5:
                continue
            if start == 3 and int(path[2:3]) * 10 + int(digit) > 59:
                continue
            self.dfs(digits, path + digit, start + 1)
```
总结：python3 把 sys.maxint 改成 sys.maxsize 了。要一次对的话，很多取数的细节需要留心。1.input time 要取 [0:2] [3:5] 来跳过 ':'; 2.diff 是负数的时候要用 24 * 60 + diff（而不是 -）；3.for 循环里面的 digit 记得包上 int()

### [22. Generate Parentheses (Medium)](https://leetcode.com/problems/generate-parentheses/description/)
```html
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

For example, given n = 3, a solution set is:

[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]
```
思路：既然是 backtracking / permutation based dfs 的题，先看看套路。有两个可能的路径， 第一种是：先 n 对括号的全排列，然后留 valid；第二种是：直接从 n 对括号里拼 valid 的排列，先试试第一种， 比较直观好理解。

```python
class Solution:
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """
        if n == 0:
            return []
        s = '(' * n + ')' * n
        self.visited = {}
        for i in range(n * 2):
            self.visited[i] = False
        self.ans = []
        self.dfs(s, '')
        return self.ans
    def dfs(self, s, path):
        if len(path) == len(s):
            if self.isValid(path):
                self.ans.append(path)
            return
        for i in range(len(s)):
            if i and s[i] == s[i - 1] and not self.visited[i - 1]:
                continue
            self.visited[i] = True
            path += s[i]
            self.dfs(s, path)
            path = path[:-1]
            self.visited[i] = False
    def isValid(self, path):
        if path[0] == ')':
            return False
        stack = []
        for paren in path:
            if paren == '(':
                stack.append(paren)
            if paren == ')':
                if stack:
                    stack.pop()
                else:
                    return False
        return len(stack) == 0       

# 二刷，稍微妖一点的 DFS 解法
class Solution:
    def generateParenthesis(self, n):
        """
        :type n: int
        :rtype: List[str]
        """       
        if n == 0:
            return []
        ans =[]
        self.dfs(n, n, '', ans)
        return ans
    def dfs(self, left, right, path, ans):
        if left == 0 and right == 0:
            ans.append(path)
            return
        if left > 0:
            self.dfs(left - 1, right, path + '(', ans)
        if right > 0 and left < right:
            self.dfs(left, right - 1, path + ')', ans)
```
总结：还挺佩服我自己的，调试下居然能过。。。虽然效率及其低下。。。立刻二刷吧。。。
二刷没什么好说的，left < right ( 比 ) 数量多就 paren 就 valid。

三刷：
```python
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        ans = []
        def dfs(left, right, path):
            if left == 0 and right == 0:
                ans.append(path)
                return
            if left > 0:
                dfs(left - 1, right, path + '(')
            if right > 0 and left < right:
                dfs(left, right - 1, path + ')')
        dfs(n, n, "")
        return ans
```
总结：简化代码。注意if right > 0 and left **<** right:...这个条件，因为 left 和 right 是减的
高频：看代码就要意识到这是dfs/backtrack的题，要记得def dfs(**left, right, path**):...dfs(n, n, "")...，还可以换一种写法if left == n and right == n:...if left < n:...if right < n and left > right:...dfs(0, 0, "")...

### [51. N-Queens (Hard)](https://leetcode.com/problems/n-queens/description/)
```html
The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle.
Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively.

Example:

Input: 4
Output: [
 [".Q..",  // Solution 1
  "...Q",
  "Q...",
  "..Q."],

 ["..Q.",  // Solution 2
  "Q...",
  "...Q",
  ".Q.."]
]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.
```
```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        def dfs(qs, xpys, ymxs):
            p = len(qs)
            if p == n:
                res.append(qs)
                return
            for q in range(n):
                if q not in qs and p + q not in xpys and q - p not in ymxs:
                    dfs(qs + [q], xpys + [p + q], ymxs + [q - p])
        dfs([], [], [])
        return [["." * i + "Q" + "." * (n - i - 1) for i in b] for b in res]
```
高频：不得不说讨论区python的答案查x+y和y-x是比较天才的。N-Queens II 注意子函数中变量操作背后带=（assignment）的都要用self.ans全局变量

## Graph based DFS 基于图的深度优先搜索
### [17. Letter Combinations of a Phone Number (Medium)](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)
```html
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.

A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
```
![keypad example](/images/leetcode_17_lett_1.png)
```html
Example:

Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
Note:

Although the above answer is in lexicographical order, your answer could be in any order you want.
```
思路：看着像 DFS，但是没有特别具体的思路，看答案。看了下三年前写的代码，还挺牛逼的。。。
```python
class Solution(object):
    def letterCombinations(self, digits):
        """
        :type digits: str
        :rtype: List[str]
        """
        self.ans = []
        if len(digits) == 0:
            return self.ans
        self.mapping = {
            '2': ['a', 'b', 'c'],
            '3': ['d', 'e', 'f'],
            '4': ['g', 'h', 'i'],
            '5': ['j', 'k', 'l'],
            '6': ['m', 'n', 'o'],
            '7': ['p', 'q', 'r', 's'],
            '8': ['t', 'u', 'v'],
            '9': ['w', 'x', 'y', 'z']
        }
        self.dfs(digits, '', 0)
        return self.ans
    def dfs(self, digits, path, start):
        if start == len(digits):
            self.ans.append(path)
            return
        for letter in self.mapping[digits[start]]:
            self.dfs(digits, path + letter, start + 1)    
```
总结：只能说三年前写的还挺牛逼的。。。
二刷：
```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        if not digits:
            return []
        mapping = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        ans = []
        def dfs(path, start):
            if len(path) == len(digits):
                ans.append(path)
                return
            for c in mapping[digits[start]]:
                path += c
                dfs(path, start + 1)
                path = path[:-1]
        dfs("", 0)
        return ans
```
高频：...for c in mapping[digits[start]]:...

### [79. Word Search (Medium)](https://leetcode.com/problems/word-search/description/)
```html
Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.
```
思路：知道是 DFS 以后超级明显的一道题，两年多前居然写过。。。
```python
class Solution(object):
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        for row in range(0, len(board)):
            for col in range(0, len(board[0])):
                if self.dfs(board, row, col, word, 0):
                    return True
        return False
    def dfs(self, board, row, col, word, start):
        if start == len(word):
            return True
        if row < 0 or row > len(board) - 1:
            return False
        if col < 0 or col > len(board[0]) - 1:
            return False
        if board[row][col] != word[start]:
            return False
        board[row][col] = '#'
        # up
        if self.dfs(board, row - 1, col, word, start + 1):
            return True
        # down
        if self.dfs(board, row + 1, col, word, start + 1):
            return True
        # left
        if self.dfs(board, row, col - 1, word, start + 1):
            return True
        # right
        if self.dfs(board, row, col + 1, word, start + 1):
            return True
        board[row][col] = word[start]
        return False
```
总结：已经决定了不喜欢 x, y 千万不要动摇，row, col 到底。注意越界判断的时候要用 len(board) - 1 和 len(board[0]) - 1 而非 word。这次用了新写法，比两年多前的版本少了大约 10 行左右代码。
高频
```python
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        def dfs(i, j, start):
            if word[start] == board[i][j]:
                if start == len(word) - 1:
                    return True
                board[i][j] = " "
                if i > 0 and dfs(i - 1, j, start + 1):
                    return True
                if i < len(board) - 1 and dfs(i + 1, j, start + 1):
                    return True
                if j > 0 and dfs(i, j - 1, start + 1):
                    return True
                if j < len(board[0]) - 1 and dfs(i, j + 1, start + 1):
                    return True
                board[i][j] = word[start]
                return False
            else:
                return False   
        for r in range(len(board)):
            for c in range(len(board[0])):
                if dfs(r, c, 0):
                    return True
        return False
```
总结：def dfs(i, j, start): if word[start] == board[i][j]: if start == len(word) - 1: return True...board[i][j] = word[start]; return False...

### [490. The Maze (Medium)](https://leetcode.com/problems/the-maze)
加锁题
There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction.

Given the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.

The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.

Example 1
Input 1: a maze represented by a 2D array
0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0
Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (4, 4)

Output: true
Explanation: One possible way is : left -> down -> left -> down -> right -> down -> right.
![the maze example 1](https://leetcode.com/static/images/problemset/maze_1_example_1.png)

Example 2
Input 1: a maze represented by a 2D array
0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0
Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (3, 2)

Output: false
Explanation: There is no way for the ball to stop at the destination.
![the maze example 2](https://leetcode.com/static/images/problemset/maze_1_example_2.png)

Note:
1.There is only one ball and one destination in the maze.
2.Both the ball and the destination exist on an empty space, and they will not be at the same position initially.
3.The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.
4.The maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.
```python
class Solution(object):
    def hasPath(self, maze, start, destination):
        """
        :type maze: List[List[int]]
        :type start: List[int]
        :type destination: List[int]
        :rtype: bool
        """
        visited = set()
        m, n = len(maze), len(maze[0])
        return self.dfs(maze, (start[0], start[1]), (destination[0], destination[1]), visited, m, n)
    def dfs(self, maze, cur, dest, visited, m, n):
        if cur == dest:
            return True
        if cur in visited:
            return False
        visited.add(cur)
        for rd, cd in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            r, c = cur
            while 0 <= r + rd <= m - 1 and 0 <= c + cd <= n - 1 and maze[r + rd][c + cd] != 1:
                r += rd
                c += cd
            if self.dfs(maze, (r, c), dest, visited, m, n):
                return True
        return False
```
面经：Amazon。注意...r, c = cur...必须在for下面，if self.dfs(...): return True...必须是这个结构。todo: BFS

### [417. Pacific Atlantic Water Flow (Medium)](https://leetcode.com/problems/pacific-atlantic-water-flow/)
Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the "Pacific ocean" touches the left and top edges of the matrix and the "Atlantic ocean" touches the right and bottom edges.
Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.
Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.

Note:
The order of returned grid coordinates does not matter.
Both m and n are less than 150.

Example:
Given the following 5x5 matrix:
  Pacific ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic
Return:
[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
```python
class Solution:
    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        if not matrix:
            return []
        m, n = len(matrix), len(matrix[0])
        reach_p = [[False] * n for _ in range(m)]
        reach_a = [[False] * n for _ in range(m)]
        self.dirs = [(-1, 0), (1, 0), (0, 1), (0, -1)]
        for r in range(m):
            self.dfs(matrix, r, 0, m, n, reach_p)
            self.dfs(matrix, r, n - 1, m, n, reach_a)
        for c in range(n):
            self.dfs(matrix, 0, c, m, n, reach_p)
            self.dfs(matrix, m - 1, c, m, n, reach_a)
        return [[r, c] for r in range(m) for c in range(n) if reach_p[r][c] == True and reach_a[r][c] == True]

    def dfs(self, matrix, r, c, m, n, reach):
        reach[r][c] = True
        for rd, cd in self.dirs:
            nr, nc = r + rd, c + cd
            if 0 <= nr <= m - 1 and 0 <= nc <= n - 1 and matrix[nr][nc] >= matrix[r][c] and not reach[nr][nc]:

                self.dfs(matrix, nr, nc, m, n, reach)
```
面经：Cruise Automation。dfs：从两个海开始往内陆灌，返回两个海都能灌到的地方 todo bfs


# Recursion 递归 / Backtracking / DFS

### [13. Roman to Integer (Easy)](https://leetcode.com/problems/roman-to-integer/)
```html
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: "III"
Output: 3
Example 2:

Input: "IV"
Output: 4
Example 3:

Input: "IX"
Output: 9
Example 4:

Input: "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 5:

Input: "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```
高频
```python
class Solution:
    def romanToInt(self, s: str) -> int:
        mapping = {
            'M': 1000,
            'D': 500,
            'C': 100,
            'L': 50,
            'X': 10,
            'V': 5,
            'I': 1,
        }
        if not s:
            return 0
        if len(s) == 1:
            return mapping[s]
        first, second, rest = s[0], s[1], s[2:]
        if mapping[first] < mapping[second]:
            return mapping[second] - mapping[first] + self.romanToInt(rest)
        else:
            return mapping[first] + self.romanToInt(second + rest)
```
总结：...else: return **mapping[first] + self.romanToInt(second + rest)**

### [50. Pow(x, n) (Medium)](https://leetcode.com/problems/powx-n/description/)
```html
Implement pow(x, n), which calculates x raised to the power n (xn).

Example 1:

Input: 2.00000, 10
Output: 1024.00000
Example 2:

Input: 2.10000, 3
Output: 9.26100
Example 3:

Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
Note:

-100.0 < x < 100.0
n is a 32-bit signed integer, within the range [−231, 231 − 1]
```
```python
class Solution:
    def myPow(self, x: float, n: int) -> float:
        return self.helper(x, n) if n > 0 else 1/self.helper(x, -n)
    def helper(self, x, n):
        if n == 0:
            return 1
        res = self.helper(x, n//2)
        return res * res if n % 2 == 0 else x * res * res
```
总结：有固定写法套路的题目， 不值得做。
高频：稍微精简了一点，为高频而刷

### [4. Median of Two Sorted Arrays (Hard)](https://leetcode.com/problems/median-of-two-sorted-arrays/)
```html
There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume nums1 and nums2 cannot be both empty.

Example 1:

nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:

nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
```
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if not nums1 and not nums2:
            return 0
        m, n = len(nums1), len(nums2)
        def findK(a, b, k):
            if not a:
                return b[k]
            if not b:
                return a[k]
            ai, bi = len(a) // 2, len(b) // 2
            am, bm = a[ai], b[bi]
            if k > ai + bi:
                if am < bm:
                    return findK(a[ai + 1:], b, k - ai - 1)
                else:
                    return findK(a, b[bi + 1:], k - bi - 1)
            else:
                if am > bm:
                    return findK(a[:ai], b, k)
                else:
                    return findK(a, b[:bi], k)
        if (m + n) % 2 == 0:
            return findK(nums1, nums2, (m + n) // 2) * 0.5 + findK(nums1, nums2, (m + n) //2 - 1) * 0.5
        else:
            return findK(nums1, nums2, (m + n) // 2)
```
高频：总长度是奇偶数分开做，...def findK(a, b, k):...if...:...return findK(a[ai + 1:], b, k - ai - 1)...

### [653. Two Sum IV - Input is a BST (Easy)](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/)
Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.

Example 1:
Input:
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9
Output: True

Example 2:
Input:
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28
Output: False
hash表/set方法：
```python
class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        if not root:
            return False
        seen = set()
        return self.helper(root, k, seen)
    def helper(self, root, k, seen):
        if not root:
            return False
        if k - root.val in seen:
            return True
        seen.add(root.val)
        return self.helper(root.left, k, seen) or self.helper(root.right, k, seen)
```
非递归BFS：
```python
class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        if not root:
            return False
        q, seen = [root], set()
        for n in q:
            if k - n.val in seen:
                return True
            seen.add(n.val)
            if n.left:
                q.append(n.left)
            if n.right:
                q.append(n.right)
        return False
```
in-order/中序遍历双指针：
```python
class Solution:
    def findTarget(self, root: TreeNode, k: int) -> bool:
        if not root:
            return False
        res = []
        self.inorder(root, res)
        i, j = 0, len(res) - 1
        while i < j:
            t = res[i] + res[j]
            if t == k:
                return True
            elif t < k:
                i += 1
            else:
                j -= 1
        return False
    def inorder(self, root, res):
        if not root:
            return
        self.inorder(root.left, res)
        res.append(root.val)
        self.inorder(root.right, res)
```
面经：Amazon。


# 数据结构

## Array 数组
### [LinC 6. Merge Two Sorted Arrays (Easy)](https://www.lintcode.com/problem/merge-two-sorted-arrays/description)
```html
Merge two given sorted integer array A and B into a new sorted integer array.

Example
A=[1,2,3,4]

B=[2,4,5,6]

return [1,2,2,3,4,4,5,6]

Challenge
How can you optimize your algorithm if one array is very large and the other is very small?
```
思路：热身题，直接做
```python
class Solution:
    """
    @param A: sorted integer array A
    @param B: sorted integer array B
    @return: A new sorted integer array
    """
    def mergeSortedArray(self, A, B):
        # write your code here
        ans = []
        indexA = 0
        indexB = 0
        indexC = 0
        while indexC < len(A) + len(B):
            if indexA == len(A) or indexB == len(B):
                if indexA == len(A):
                    ans.append(B[indexB])
                    indexB += 1
                else:
                    ans.append(A[indexA])
                    indexA += 1
            else:
                if A[indexA] < B[indexB]:
                    ans.append(A[indexA])
                    indexA += 1
                else:
                    ans.append(B[indexB])
                    indexB += 1
            indexC += 1
        return ans
```
总结：非常值得刷的一道热身题， 需要考虑两个 array 越界的问题。看了下答案用三个 while 循环也可以。

### [88. Merge Sorted Array (Easy)](https://leetcode.com/problems/merge-sorted-array/description/)
```html
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:

The number of elements initialized in nums1 and nums2 are m and n respectively.
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.
Example:

Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
```
思路：直觉上想不太出来怎么不创建新的存储空间把小数组 merge 到大数组里。看了答案，如果 nums1 后面空着这么些空，就从后面开始填。哎，曾经是能自主想的出的。。。正着困难的话就反着试试
```python
class Solution(object):
    def merge(self, nums1, m, nums2, n):
        """
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        """
        if len(nums2) == 0:
            return
        if len(nums1) == len(nums2):
            for i in range(len(nums2)):
                nums1[i] = nums2[i]
            return
        index1 = m - 1
        index2 = n - 1
        index3 = len(nums1) - 1
        while index3 >= 0 and index2 >= 0:
            if index1 < 0:
                nums1[index3] = nums2[index2]
                index2 -= 1
            else:
                if nums1[index1] < nums2[index2]:
                    nums1[index3] = nums2[index2]
                    index2 -= 1
                else:
                    nums1[index3] = nums1[index1]
                    index1 -= 1
            index3 -= 1    
```
总结：虽然是 easy 题，要考虑情况：1.nums1 和 nums2 一样大的话需要逐个考过去；2.index2 如果走到最前面就可以结束了。注意题目的输入包含了 m 和 n 要利用好

高频：
```python
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        if m == 0:
            nums1[:] = nums2[:]
        i1 = m - 1
        i2 = n - 1
        im = m + n - 1
        while i1 >= 0 and i2 >= 0:
            if nums1[i1] < nums2[i2]:
                nums1[im] = nums2[i2]
                i2 -= 1
            else:
                nums1[im] = nums1[i1]
                i1 -= 1
            im -= 1
        if i1 < 0:
            nums1[:i2 + 1] = nums2[:i2 + 1]
```
总结：代码简化，也更好理解一些，算法还是原来的，从nums1后往前填，注意最后如果nums1都填完了要把nums2剩余的都天过去nums1[:i2 **+ 1**] = nums2[:i2 **+ 1**]

### [73. Set Matrix Zeroes (Medium)](https://leetcode.com/problems/set-matrix-zeroes/)
```html
Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Example 1:

Input:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
Example 2:

Input:
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output:
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
Follow up:

A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?
```
高频
```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        r0 = set()
        c0 = set()

        for r in range(len(matrix)):
            for c in range(len(matrix[0])):
                if matrix[r][c] == 0:
                    r0.add(r)
                    c0.add(c)

        for r in r0:
            for c in range(len(matrix[0])):
                matrix[r][c] = 0

        for c in c0:
            for r in range(len(matrix)):
                matrix[r][c] = 0
```
总结：O(m+n)空间的解法
二刷：
```python
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
        is1stRZ, is1stCZ = True if 0 in matrix[0] else False, True if 0 in list(zip(*matrix))[0] else False
        for i, r in enumerate(matrix):
            for j, c in enumerate(r):
                if i and j and c == 0:
                    matrix[i][0] = 0
                    matrix[0][j] = 0
        m, n = len(matrix), len(matrix[0])
        for i in range(1, m):
            if matrix[i][0] == 0:
                matrix[i] = [0] * n
        for j in range(1, n):
            if matrix[0][j] == 0:
                for i in range(1, m):
                    matrix[i][j] = 0
        if is1stRZ:
            matrix[0] = [0] * n
        if is1stCZ:
            for i in range(m):
                matrix[i][0] = 0
```
总结：O(1)空间

### [56. Merge Intervals (Medium)](https://leetcode.com/problems/merge-intervals/)
```html
Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
```
高频
```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        if not intervals:
            return []
        intervals.sort(key = lambda x: x[0])
        ans = []
        cur = intervals[0]
        for i in range(1, len(intervals)):
            if intervals[i][0] <= cur[1]:
                cur[1] = max(intervals[i][1], cur[1])
            else:
                ans.append(cur[:])
                cur = intervals[i]
        ans.append(cur)
        return ans
```
面经：Cruise。...cur[1] = **max(intervals[i][1], cur[1])**...

### [LinC 839. Merge Two Sorted Interval Lists (Easy)](https://www.lintcode.com/problem/merge-two-sorted-interval-lists/description)
```html
Merge two sorted (ascending) lists of interval and return it as a new sorted list. The new sorted list should be made by splicing together the intervals of the two lists and sorted in ascending order.

The intervals in the given list do not overlap.
The intervals in different lists may overlap.
Example
Given list1 = [(1,2),(3,4)] and list2 = [(2,3),(5,6)], return [(1,4),(5,6)].
```
思路：思路跟上题 merge interval一样，可以不做
```python
"""
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
"""
class Solution:
    """
    @param list1: one of the given list
    @param list2: another list
    @return: the new sorted list of interval
    """
    def mergeTwoInterval(self, list1, list2):
        # write your code here
        if not list1:
            return list2
        if not list2:
            return list1
        list3 = list1 + list2
        list3.sort(key=lambda x: x.start)
        ans = [list3[0]]
        for i in range(1, len(list3)):
            if list3[i].start <= ans[-1].end:
                ans[-1].end = max(list3[i].end, ans[-1].end)
            else:
                ans.append(list3[i])
        return ans
```
二刷：删掉一刷代码，统一思路

### [228. Summary Ranges (Medium)](https://leetcode.com/problems/summary-ranges/description/)
```html
Given a sorted integer array without duplicates, return the summary of its ranges.

Example 1:

Input:  [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.
Example 2:

Input:  [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.
```
```python
# 先写 O(n) 的再优化
class Solution:
    def summaryRanges(self, nums):
        """
        :type nums: List[int]
        :rtype: List[str]
        """
        if not nums:
            return []
        ans, start = [], 0
        def addToRes(l, r):
            if l == r:
                ans.append(str(nums[l]))
            else:
                ans.append(f"{str(nums[l])}->{str(nums[r])}")
        for i in range(len(nums) - 1):
            if nums[i] != nums[i + 1] - 1:
                addToRes(start, i)
                start = i + 1
        addToRes(start, len(nums) - 1)
        return ans
```
二刷：删掉了一刷的思路，代码和总结。 ..start = 0...def addToRes(l, r):...start = i + 1...

### [67. Add Binary (Easy)](https://leetcode.com/problems/add-binary/)
```html
Given two binary strings, return their sum (also a binary string).

The input strings are both non-empty and contains only characters 1 or 0.

Example 1:

Input: a = "11", b = "1"
Output: "100"
Example 2:

Input: a = "1010", b = "1011"
Output: "10101"
```
高频
```python
class Solution:
    def addBinary(self, a: str, b: str) -> str:
        m = len(a)
        n = len(b)
        l = max(m, n)
        i = 1
        carry = 0
        ans = ""
        while i <= l:
            if i <= m and i <= n:
                val = int(a[-i]) + int(b[-i]) + carry
            elif i <= m:
                val = int(a[-i]) + carry
            elif i <= n:
                val = int(b[-i]) + carry
            if val > 1:
                carry = 1
            else:
                carry = 0
            ans = str(val % 2) + ans
            i += 1
        if carry == 1:
            ans = "1" + ans
        return ans
```
总结：...**i = 1**...while i **<=** l:...if val > 1: carry = 1; else: carry = 0; ans = str(val % 2) + ans; i += 1...

### [12. Integer to Roman (Medium)](https://leetcode.com/problems/integer-to-roman/)
```html
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one's added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: 3
Output: "III"
Example 2:

Input: 4
Output: "IV"
Example 3:

Input: 9
Output: "IX"
Example 4:

Input: 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
Example 5:

Input: 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
```
高频
```python
class Solution:
    def intToRoman(self, num: int) -> str:
        n = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        l = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
        ans = ""
        for i, v in enumerate(n):
            if num == 0:
                return ans
            t = num // v
            ans += l[i] * t
            num %= v
        return ans
```
总结：有了n和l俩数组就是easy了

### [43. Multiply Strings (Medium)](https://leetcode.com/problems/multiply-strings/)
```html
Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.

Example 1:

Input: num1 = "2", num2 = "3"
Output: "6"
Example 2:

Input: num1 = "123", num2 = "456"
Output: "56088"
Note:

The length of both num1 and num2 is < 110.
Both num1 and num2 contain only digits 0-9.
Both num1 and num2 do not contain any leading zero, except the number 0 itself.
You must not use any built-in BigInteger library or convert the inputs to integer directly.
```
```python
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        res = [0 for _ in range(len(num1) + len(num2))]
        num1 = num1[::-1]
        num2 = num2[::-1]
        for i in range(len(num1)):
            for j in range(len(num2)):
                res[i + j] += int(num1[i]) * int(num2[j])

        for i in range(len(res)):
            d = res[i] % 10
            c = res[i] // 10
            if i < len(res) - 1:
                res[i + 1] += c
            res[i] = d

        res.reverse()
        while res[0] == 0 and len(res) > 1:
            del res[0]
        return "".join(str(i) for i in res)
```
高频：...for i in range(len(res)):...res[i] = d...**while** res[0] == 0 and len(res) > 1:...

### [128. Longest Consecutive Sequence (Medium)](https://leetcode.com/problems/longest-consecutive-sequence/)
```html
Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

Example:

Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
```
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        nums = set(nums)
        ans = 0
        for n in nums:
            if n - 1 not in nums:
                m = n + 1
                while m in nums:
                    m += 1
                ans = max(ans, m - n)
        return ans
```
高频：不明白为什么要作为高频题，除了惊叹于答案之神乎其技， 几乎学不到任何东西

### [66. Plus One (Easy)](https://leetcode.com/problems/plus-one/)
```html
Given a non-empty array of digits representing a non-negative integer, plus one to the integer.

The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.

You may assume the integer does not contain any leading zero, except the number 0 itself.

Example 1:

Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Example 2:

Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
```
```python
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        digits.reverse()
        c = 0
        for i, d in enumerate(digits):
            if i == 0:
                d += 1
            else:
                d += c
            c = d // 10
            d = d % 10
            digits[i] = d
        if c > 0:
            digits.append(1)
        return digits[::-1]
```
高频

### [9. Palindrome Number (Easy)](https://leetcode.com/problems/palindrome-number/)
```html
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:

Input: 121
Output: true
Example 2:

Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
Follow up:

Coud you solve it without converting the integer to a string?
```
```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        ox = x
        nx = 0
        while x:
            t = x % 10
            nx = nx * 10 + t
            x //= 10
        return nx == ox
```
高频：...nx = nx * 10 + t...

### [59. Spiral Matrix II (Medium)](https://leetcode.com/problems/spiral-matrix-ii/)
```html
Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

Example:

Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
```
```python
class Solution:
    def generateMatrix(self, n: int) -> List[List[int]]:
        ans = [[0] * n for _ in range(n)]
        mode, r, c, circle = 0, 0, 0, 0
        for i in range(1, n * n + 1):
            ans[r][c] = i
            if mode == 0:
                c += 1
                if c == n - 1 - circle:
                    mode = 1
            elif mode == 1:
                r += 1
                if r == n - 1 - circle:
                    mode = 2
            elif mode == 2:
                c -= 1
                if c == circle:
                    mode = 3
            else:
                r -= 1
                if r == circle + 1:
                    mode = 0
                    circle += 1
        return ans
```
高频：...if c == n - 1 - circle:...if r == n - 1 - circle:...if c == circle:...if r = circle + 1:...

### [48. Rotate Image (Medium)](https://leetcode.com/problems/rotate-image/)
```html
You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
Note:
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:
Given input matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```
```python
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        n = len(matrix)
        matrix.reverse()
        for r in range(n):
            for c in range(r, n):
                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]
```
高频：需要懂得顺时针转就是上下翻转以后对角线翻转，逆时针转就是左右翻转以后对角线翻转。懂list(zip(\*list))的话就是一行代码

### [54. Spiral Matrix (Medium)](https://leetcode.com/problems/spiral-matrix/)
```html
Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example 1:

Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
Example 2:

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
```
```python
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        if len(matrix) == 0:
            return []
        mode, circle, r, c = 0, 0, 0, 0
        m, n = len(matrix), len(matrix[0])
        ans = []
        for _ in range(m * n):
            ans.append(matrix[r][c])
            if mode == 0:
                if c == n - 1 - circle:
                    mode = 1
                    r += 1
                else:
                    c += 1
            elif mode == 1:
                if r == m - 1 - circle:
                    mode = 2
                    c -= 1
                else:
                    r += 1
            elif mode == 2:
                if c == circle:
                    mode = 3
                    r -= 1
                else:
                    c -= 1
            elif mode == 3:
                if r == circle + 1:
                    mode = 0
                    circle += 1
                    c += 1
                else:
                    r -= 1
        return ans
```
高频：相比其他答案，更喜欢这个sprial matrix II用过的模板，不同之处是这里要先处理转向，用来应对[[1],[2]]这种输入

### [68. Text Justification (Hard)](https://leetcode.com/problems/text-justification/)
```html
Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

Note:

A word is defined as a character sequence consisting of non-space characters only.
Each word's length is guaranteed to be greater than 0 and not exceed maxWidth.
The input array words contains at least one word.
Example 1:

Input:
words = ["This", "is", "an", "example", "of", "text", "justification."]
maxWidth = 16
Output:
[
   "This    is    an",
   "example  of text",
   "justification.  "
]
Example 2:

Input:
words = ["What","must","be","acknowledgment","shall","be"]
maxWidth = 16
Output:
[
  "What   must   be",
  "acknowledgment  ",
  "shall be        "
]
Explanation: Note that the last line is "shall be    " instead of "shall     be",
             because the last line must be left-justified instead of fully-justified.
             Note that the second line is also left-justified becase it contains only one word.
Example 3:

Input:
words = ["Science","is","what","we","understand","well","enough","to","explain",
         "to","a","computer.","Art","is","everything","else","we","do"]
maxWidth = 20
Output:
[
  "Science  is  what we",
  "understand      well",
  "enough to explain to",
  "a  computer.  Art is",
  "everything  else  we",
  "do                  "
]
```
```python
class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
        ans, line, letter_count = [], [], 0
        for w in words:
            if letter_count + len(w) + len(line) > maxWidth:
                for i in range(maxWidth - letter_count):
                    line[i % (len(line) - 1 or 1)] += ' '
                ans.append(''.join(line))
                line = []
                letter_count = 0
            line += [w]
            letter_count += len(w)        
        ans.append(' '.join(line).ljust(maxWidth))
        return ans
```
高频：需要知道很巧妙的round robin填空格的方法：...line[i % (len(line) - 1 or 1)] += ' '...，str.ljust(width[, fillchar])默认填空格

### [36. Valid Sudoku (Medium)](https://leetcode.com/problems/valid-sudoku/)
```html
Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:

Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.

A partially filled sudoku which is valid.
The Sudoku board could be partially filled, where empty cells are filled with the character '.'.

Example 1:

Input:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: true
Example 2:

Input:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being
    modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.
Note:

A Sudoku board (partially filled) could be valid but is not necessarily solvable.
Only the filled cells need to be validated according to the mentioned rules.
The given board contain only digits 1-9 and the character '.'.
The given board size is always 9x9.
```
```python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        def row():
            for r in board:
                if not valid(r):
                    return False
            return True

        def col():
            for c in zip(*board):
                if not valid(c):
                    return False
            return True

        def sub():
            for i in [0, 3, 6]:
                for j in [0, 3, 6]:
                    flat = [board[r][c] for r in range(i, i + 3) for c in range(j, j + 3)]
                    if not valid(flat):
                        return False
            return True

        def valid(arr):
            t = [i for i in arr if i != "."]
            return len(t) == len(set(t))

        return row() and col() and sub()
```
高频：...for...zip(\*board)... t = [i for...if i...]... len(t) == len(set(t))...

### [38. Count and Say (Easy)](https://leetcode.com/problems/count-and-say/)
```html
The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 is read off as "one 1" or 11.
11 is read off as "two 1s" or 21.
21 is read off as "one 2, then one 1" or 1211.

Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.
Note: Each term of the sequence of integers will be represented as a string.

Example 1:

Input: 1
Output: "1"
Example 2:

Input: 4
Output: "1211"
```
用itertools.groupby():
```python
class Solution:
    def countAndSay(self, n: int) -> str:
        ans = "1"
        for i in range(n - 1):
            t = ""
            for d, g in itertools.groupby(ans):
                cnt = len(list(g))
                t += str(cnt) + str(d)
            ans = t
        return ans
```
不用groupby:
```python
class Solution:
    def countAndSay(self, n: int) -> str:
        ans = "1"
        for i in range(n - 1):
            res = ""
            t = ans + "#"
            cnt = 1
            for i in range(len(t) - 1):
                if t[i] == t[i + 1]:
                    cnt += 1
                else:
                    res += str(cnt) + t[i]
                    cnt = 1
            ans = res
        return ans
```
高频：题目描述不是很清楚，用groupby：...for d, g in itertools.groupby():...。不用groupby：...res = ""; t = ans + "#"...

### [14. Longest Common Prefix (Easy)](https://leetcode.com/problems/longest-common-prefix/)
```html
Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:

Input: ["flower","flow","flight"]
Output: "fl"
Example 2:

Input: ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
Note:

All given inputs are in lowercase letters a-z.
```
```python
class Solution:
    def longestCommonPrefix(self, strs: List[str]) -> str:
        if not strs:
            return ""
        ans = strs[0]
        for i in range(1, len(strs)):
            if not ans:
                return ""
            else:
                j = 0
                while j < len(ans) and j < len(strs[i]) and ans[j] == strs[i][j]:
                    j += 1
                ans = ans[:j]
        return ans
```
高频：
面经：Quora。删掉了高频的总结，换成我自己想出来的解法。

### [119. Pascal's Triangle II (Easy)](https://leetcode.com/problems/pascals-triangle-ii/)
```html
Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.
Note that the row index starts from 0.
In Pascal's triangle, each number is the sum of the two numbers directly above it.

Example:
Input: 3
Output: [1,3,3,1]

Follow up:
Could you optimize your algorithm to use only O(k) extra space?
```
```python
class Solution:
    def getRow(self, rowIndex: int) -> List[int]:
        ans = [1]
        for i in range(rowIndex):
            ans = [x + y for x, y in zip(ans + [0], [0] + ans)]
        return ans
```
高频：很巧妙的...[x + y for x, y in zip(ans + [0], [0] + ans)]...

### [6. ZigZag Conversion (Medium)](https://leetcode.com/problems/zigzag-conversion/)
```html
The string "PAYPALISHIRING" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: "PAHNAPLSIIGYIR"

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
Example 1:

Input: s = "PAYPALISHIRING", numRows = 3
Output: "PAHNAPLSIIGYIR"
Example 2:

Input: s = "PAYPALISHIRING", numRows = 4
Output: "PINALSIGYAHRPI"
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
```
```python
class Solution:
    def convert(self, s: str, numRows: int) -> str:
        if numRows == 1:
            return s
        res = [''] * numRows
        r, move = 0, 1
        for l in s:
            res[r] += l
            r += move
            if r == numRows - 1:
                move = -1
            elif r == 0:
                move = 1
        return ''.join(res)
```
高频：想太多反而写不出来，直接粗暴拼反而能拼出来，注意numRows为1时单独处理

### [8. String to Integer (atoi) (Medium)](https://leetcode.com/problems/string-to-integer-atoi/)
```html
Implement atoi which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

Note:

Only the space character ' ' is considered as whitespace character.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.
Example 1:

Input: "42"
Output: 42
Example 2:

Input: "   -42"
Output: -42
Explanation: The first non-whitespace character is '-', which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.
Example 3:

Input: "4193 with words"
Output: 4193
Explanation: Conversion stops at digit '3' as the next character is not a numerical digit.
Example 4:

Input: "words and 987"
Output: 0
Explanation: The first non-whitespace character is 'w', which is not a numerical
             digit or a +/- sign. Therefore no valid conversion could be performed.
Example 5:

Input: "-91283472332"
Output: -2147483648
Explanation: The number "-91283472332" is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.
```
```python
class Solution:
    def myAtoi(self, str: str) -> int:
        return self.helper(str)
    def helper(self, s):
        s = s.strip()
        if not s:
            return 0
        valid = [str(i) for i in range(10)]
        signs = '+-'
        if s[0] not in valid and s[0] not in signs:
            return 0
        sign = 1
        if s[0] == '-':
            sign = -1
        if s[0] in signs:
            s = s[1:]
        ans = ''
        for l in s:
            if l in valid:
                ans += l
                if sign == -1 and -int(ans) < -pow(2, 31):
                    return -pow(2, 31)
                if sign == 1 and int(ans) > pow(2, 31) - 1:
                    return pow(2, 31) - 1
            else:
                return sign * int(ans) if ans else 0
        return sign * int(ans) if ans else 0
```
高频：从例子之多就能看出来要考虑的case非常多。比的是细致

### [57. Insert Interval (Hard)](https://leetcode.com/problems/insert-interval/description/)
```html
Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:

Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
Example 2:

Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
```
```python
class Solution:
    def insert(self, intervals, newInterval):
        if not intervals:
            return [newInterval]
        ans = []
        i = 0
        while i < len(intervals):
            if intervals[i][1] < newInterval[0]:
                ans.append(intervals[i])
                i += 1
            else:
                break
        while i < len(intervals) and intervals[i][0] <= newInterval[1]:
            newInterval[0] = min(newInterval[0], intervals[i][0])
            newInterval[1] = max(newInterval[1], intervals[i][1])
            i += 1
        ans.append(newInterval)
        while i < len(intervals):
            ans.append(intervals[i])
            i += 1
        return ans
```
高频：重点是知道先把，结束小于新开始的...if intervals[i][1] < newInterval[0]:...加到ans里，然后过开始小于新结束的...if...and intervals[i][0] <= newInterval[1]: ...min...max...这个方法

### [937. Reorder Log Files (Easy)](https://leetcode.com/problems/reorder-log-files/)
```html
You have an array of logs.  Each log is a space delimited string of words.

For each log, the first word in each log is an alphanumeric identifier.  Then, either:

Each word after the identifier will consist only of lowercase letters, or;
Each word after the identifier will consist only of digits.
We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.

Return the final order of the logs.
Example 1:

Input: ["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
Output: ["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]

Note:

0 <= logs.length <= 100
3 <= logs[i].length <= 100
logs[i] is guaranteed to have an identifier, and a word after the identifier.
```
```python
class Solution:
    def reorderLogFiles(self, logs: List[str]) -> List[str]:
        nums, letters = [], []
        for log in logs:
            words = log.split(' ')
            if words[1].isdigit():
                nums.append(log)
            else:
                letters.append(log)
        letters.sort(key = lambda x: x.split(' ')[0])
        letters.sort(key = lambda x: x.split(' ')[1:])
        return letters + nums
```
面经：Amazon，用key function，sort是stable


## Linked List 链表
### [21. Merge Two Sorted Lists (Easy)](https://leetcode.com/problems/merge-two-sorted-lists/)
```html
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

Example:

Input: 1->2->4, 1->3->4
Output: 1->1->2->3->4->4
```
高频：
```python
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        head = dummy = ListNode(0)
        while l1 and l2:
            if l1.val <= l2.val:
                head.next = l1
                l1 = l1.next
            else:
                head.next = l2
                l2 = l2.next
            head = head.next
        if l1:
            head.next = l1
        if l2:
            head.next = l2
        return dummy.next
```
总结：while...: if l1.val < l2.val:...记得nm = nm.next
面经：Cruise。

### [86. Partition List (Medium)](https://leetcode.com/problems/partition-list/description/)
```html
Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.

You should preserve the original relative order of the nodes in each of the two partitions.

Example:

Input: head = 1->4->3->2->5->2, x = 3
Output: 1->2->2->4->3->5
```
思路：慢快指针，慢指针在最后一个 < x 的位置， 快指针在最后一个 >= x 的位置，快指针碰到一个 < x 的就和慢指针换
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def partition(self, head, x):
        """
        :type head: ListNode
        :type x: int
        :rtype: ListNode
        """
        if head == None or head.next == None:
            return head
        fakie = ListNode(-1)
        fakie.next = head
        slow, fast = fakie, None
        while slow != None:
            while slow != None and slow.next != None and slow.next.val < x:
                slow = slow.next
            if fast == None:
                fast = slow
            while fast != None and fast.next != None and fast.next.val >= x:
                fast = fast.next
            if fast.next == None or slow.next == None:
                break
            savedFastNext = fast.next
            fast.next = fast.next.next
            savedSlowNext = slow.next
            slow.next = savedFastNext
            savedFastNext.next = savedSlowNext
            slow = slow.next
        return fakie.next
```
总结：链表的问题需要先放一个假头，注意 1->1 x = 0, 1->1 x = 2, 2->1 x = 2 这三种情况和题中的例子情况 1->4->3->2->5->2 才能写对。

二刷：
```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
      if head is None:
          return head
      fake = ListNode(-1)
      fake.next = head
      l, rl, rr = fake, fake, fake
      while head is not None:
          if head.val < x:
              l.next = head
              l = l.next
          else:
              if rl == fake:
                  rl, rr = head, head
              else:
                  rr.next = head
                  rr = rr.next
          head = head.next
      if rl != fake:
          l.next = rl
          rr.next = None
      else:
          l.next = None
      return fake.next
```
总结：按一刷的经验放假头。二刷不同之处：1.前进 head；2.对于 >= x 的情况，增加了 rl 和 rr 两个新边界。 head 结束后，如 rl 存在， 则连接 l 与 r，r 断尾，否则 l 断尾。需检测 1->1 x = 2, 2->2 x = 1 和题中给出的正常测试数据共三种情况

三刷：
```python
class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        before = before_head = ListNode(0)
        after = after_head = ListNode(0)
        while head:
            if head.val < x:
                before.next = head
                before = before.next
            else:
                after.next = head
                after = after.next
            head = head.next
        after.next = None
        before.next = after_head.next
        return before_head.next
```
高频：更好理解的一个算法，before = before_head = ListNode(0)...before = before.next...return before_head.next...

### [160. Intersection of Two Linked Lists (Easy)](https://leetcode.com/problems/intersection-of-two-linked-lists/description/)
```html
Write a program to find the node at which the intersection of two singly linked lists begins.

For example, the following two linked lists:

A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
begin to intersect at node c1.

Notes:
If the two linked lists have no intersection at all, return null.
The linked lists must retain their original structure after the function returns.
You may assume there are no cycles anywhere in the entire linked structure.
Your code should preferably run in O(n) time and use only O(1) memory.
```
思路：统计两条链走到头的长度，lenA 和 lenB, 然后让长的那条先走两者的差值，然后一起走，返回相遇的那点

```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        """
        :type head1, head1: ListNode
        :rtype: ListNode
        """
        savedHeadA, savedHeadB = headA, headB
        if headA == None or headB == None:
            return None
        lenA, lenB = 1, 1
        while headA.next != None:
            headA = headA.next
            lenA += 1
        while headB.next != None:
            headB = headB.next
            lenB += 1
        if lenA > lenB:
            diff = lenA - lenB
            for x in xrange(diff):
                savedHeadA = savedHeadA.next
        else:
            diff = lenB - lenA
            for x in xrange(diff):
                savedHeadB = savedHeadB.next
        while savedHeadA != None:
            if savedHeadA == savedHeadB:
                return savedHeadA
            else:
                savedHeadA = savedHeadA.next
                savedHeadB = savedHeadB.next
        return None
```
总结：1.注意空输入（不能假设 headA 或 B 有 next）2.注意 headA headB 是一个节点 i.e. 合体的情况

### [141. Linked List Cycle (Easy)](https://leetcode.com/problems/linked-list-cycle/description/)
```html
Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?
```
思路：记得应该是慢的 +1 快的 +2 如果有 loop 会重逢。。。可能不那么值得做，热身吧
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        if head == None or head.next == None:
            return False
        slow, fast = head, head.next.next
        while fast != None and fast.next != None and fast.next.next != None:
            if slow == fast:
                return True
            slow = slow.next
            fast = fast.next.next
        return False
```
总结：有点意思，适合热身，代码写好后要测的情况比较多， 1 -> 2 无 loop，1 -> 2 -> 3 -> 4 loop 回 2 这些情况都要测一下。防止 next 和 next.next 不存在的情况

二刷：
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        """
        :type head: ListNode
        :rtype: bool
        """
        if head == None or head.next == None:
            return False
        slow, fast = head, head.next.next
        while slow and fast and fast.next:
            if slow == fast:
                return True
            slow = slow.next
            fast = fast.next.next
        return False
```
总结：一次写对确实不易，要考虑多种情况。

### [142. Linked List Cycle II (Medium)](https://leetcode.com/problems/linked-list-cycle-ii/description/)
```html
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

Note: Do not modify the linked list.

Follow up:
Can you solve it without using extra space?
```
思路：记得好像是找到有 loop 以后走多久能找到 cycle 的起点。
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None or head.next == None:
            return None
        slow, fast = head, head
        while fast.next != None and fast.next.next != None:
            slow = slow.next
            fast = fast.next.next            
            if slow == fast:
                while head != slow:
                    head = head.next
                    slow = slow.next
                return head
        return None
```        
总结：slow fast 同时在 head，先走再判断。不然容易出错。有数学关系，面试当场不一定能推导出来。就算推导出来也要注意前面的 slow，fast写法。
    a            b
A ------ B --------+
         |         |
       c |         |
         +-------- C

* A: 起始点
* B: Cycle Begins
* C: 1st 快慢指针相遇点

* A->B: a
* B->C: b
* C->B: c
* 环的长度 (b+c) 为 R

第一次相遇时，慢指针所走步数为 a + b 快指针走的步数为 *a + b + nR*
我们知道快指针是慢指针速度的2倍，因此 2(a + b) = a + b + nR 那么 a + b = nR
同时 b + c = R 所以 a = (n - 1)R + c;
也就是说，从A点和C点同时出发，以相同的速度前进，相遇的位置将是B。

二刷：
```python
# Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def detectCycle(self, head):
        """
        :type head: ListNode
        :rtype: ListNode
        """
        if head == None or head.next == None:
            return None
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                while head != slow:
                    head = head.next
                    slow = slow.next
                return head
        return None
```
总结：比较重要的是 slow 和 fast 都要从 head 开始，循环中先向前走， 否则有些测试数据会死循环

### [24. Swap Nodes in Pairs (Medium)](https://leetcode.com/problems/swap-nodes-in-pairs/)
```html
Given a linked list, swap every two adjacent nodes and return its head.

You may not modify the values in the list's nodes, only nodes itself may be changed.



Example:

Given 1->2->3->4, you should return the list as 2->1->4->3.
```
高频
```python
class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        dummy = pre = ListNode(0)
        dummy.next = head
        while pre.next and pre.next.next:
            curr = pre.next
            next = pre.next.next
            curr.next = next.next
            next.next = curr
            pre.next = next
            pre = curr    
        return dummy.next
```
总结：需要先把如何交换的顺序画出来，定位curr在pre.next, 定位next在pre.next.next，将cur.next指向next.next(因为翻转以后cur是尾巴了)，将next.next指向cur（实现翻转），将pre.next指向next（翻转后新的头），将pre挪到curr（新的尾巴）

### [2. Add Two Numbers (Medium)](https://leetcode.com/problems/add-two-numbers/)
```html
You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example:

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
```
高频
```python
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        return self.n2l(self.l2n(l1) + self.l2n(l2))

    def l2n(self, root):
        num = ""
        while root:
            num = str(root.val) + num
            root = root.next
        return int(num)

    def n2l(self, num):
        num = str(num)
        head = None
        for d in num:
            if not head:
                head = ListNode(int(d))
            else:
                old_head = head
                head = ListNode(int(d))
                head.next = old_head
        return head
```
总结：写l2n和n2l两个函数

### [83. Remove Duplicates from Sorted List (Easy)](83. Remove Duplicates from Sorted List)
```html
Given a sorted linked list, delete all duplicates such that each element appear only once.

Example 1:

Input: 1->1->2
Output: 1->2
Example 2:

Input: 1->1->2->3->3
Output: 1->2->3
```
高频
```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        temp = head
        while temp and temp.next:
            if temp.val == temp.next.val:
                temp.next = temp.next.next
            else:
                temp = temp.next
        return head
```
总结：...**temp = head**; while temp and temp.next: ...temp.next = temp.next.next; else: temp = temp.next...

### [82. Remove Duplicates from Sorted List II (Medium)](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)
```html
Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.

Example 1:

Input: 1->2->3->3->4->4->5
Output: 1->2->5
Example 2:

Input: 1->1->1->2->3
Output: 2->3
```
```python
class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head
        cur = dummy
        while cur:
            has_dupe = False
            while cur.next and cur.next.next and cur.next.val == cur.next.next.val:
                cur.next = cur.next.next
                has_dupe = True
            if has_dupe:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return dummy.next
```
高频：...cur = dummy...has_dupe = False...cur.next = cur.next.next...

### [61. Rotate List (Medium)](https://leetcode.com/problems/rotate-list/)
```html
Given a linked list, rotate the list to the right by k places, where k is non-negative.

Example 1:

Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL
Explanation:
rotate 1 steps to the right: 5->1->2->3->4->NULL
rotate 2 steps to the right: 4->5->1->2->3->NULL
Example 2:

Input: 0->1->2->NULL, k = 4
Output: 2->0->1->NULL
Explanation:
rotate 1 steps to the right: 2->0->1->NULL
rotate 2 steps to the right: 1->2->0->NULL
rotate 3 steps to the right: 0->1->2->NULL
rotate 4 steps to the right: 2->0->1->NULL
```
```python
class Solution:
    def rotateRight(self, head: ListNode, k: int) -> ListNode:
        q = collections.deque()
        def l2q(head):
            while head:
                q.append(head.val)
                head = head.next
        def q2l(q):
            dummy = ListNode(0)
            cur = dummy
            while q:
                v = q.popleft()
                n = ListNode(v)
                cur.next = n
                cur = n
            return dummy.next
        l2q(head)
        q.rotate(k)
        return q2l(q)
```
高频：正统的解法应该是统计链长n，k %= n, f走k步，s，f同时走到底，s.next 为新head，f.next接到head上，s.next = None

### [92. Reverse Linked List II (Medium)](https://leetcode.com/problems/reverse-linked-list-ii/)
```html
Reverse a linked list from position m to n. Do it in one-pass.

Note: 1 ≤ m ≤ n ≤ length of list.

Example:

Input: 1->2->3->4->5->NULL, m = 2, n = 4
Output: 1->4->3->2->5->NULL
```
```python
class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        dummy = ListNode(0)
        dummy.next = head
        pre = dummy
        for _ in range(m - 1):
            pre = pre.next
        cur = pre.next
        for _ in range(n - m):
            t = cur.next
            cur.next = t.next
            t.next = pre.next
            pre.next = t
        return dummy.next
```
高频：...t = **cur**.next; cur.next = t.next...

### [146. LRU Cache (Medium)](https://leetcode.com/problems/lru-cache/)
```html
Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.

get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.

The cache is initialized with a positive capacity.

Follow up:
Could you do both operations in O(1) time complexity?

Example:

LRUCache cache = new LRUCache( 2 /* capacity */ );

cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
```
```python
class Node:
    def __init__(self, k, v):
        self.key = k
        self.val = v
        self.prev = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.mapping = {}
        self.head, self.tail = Node(0, 0), Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -> int:
        if key not in self.mapping:
            return -1
        n = self.mapping[key]
        self._remove(n)
        self._add(n)
        return n.val

    def put(self, key: int, value: int) -> None:
        if key in self.mapping:
            self._remove(self.mapping[key])
        n = Node(key, value)
        self.mapping[key] = n
        if len(self.mapping) > self.capacity:
            t = self.head.next
            del self.mapping[t.key]
            self._remove(t)
        self._add(n)

    def _remove(self, node):
        node.next.prev = node.prev
        node.prev.next = node.next

    def _add(self, node):
        self.tail.prev.next = node
        node.prev = self.tail.prev
        node.next = self.tail
        self.tail.prev = node
```
高频：O(1)的get和put需要dict存key和双向链表的节点。或者OrderedDict这个数据结构。...**>** self.capacity: t = self.head.next; del ...self.\_remove(t)， 可以省一个pop函数。然后注意put的时候要先把旧的重复key对从双链表中删除。...put(...): if key in self.mapping: self.\_remove(self.mapping[key])...

### [206. Reverse Linked List (Easy)](https://leetcode.com/problems/reverse-linked-list/)
```html
Reverse a singly linked list.

Example:

Input: 1->2->3->4->5->NULL
Output: 5->4->3->2->1->NULL
Follow up:

A linked list can be reversed either iteratively or recursively. Could you implement both?
```
遍历：
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        newHead = None
        while head:
            t = head.next
            head.next = newHead
            newHead = head
            head = t
        return newHead
```
递归：
```python
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        def revert(head, newHead):
            if head == None:
                return newHead
            t = head.next
            head.next = newHead
            return revert(t, head)
        return revert(head, None)
```
高频：遍历的模板比较好记，递归的模板好理解但是难记...(head, newHead): if not head: return newHead; t = head.next; head.next = **newHead**...(t, head)
二刷：遍历：newHead = **None**...t = **head.next**...递归：...f(head, newHead):...return f(t, head)...

### [234. Palindrome Linked List (Easy)](https://leetcode.com/problems/palindrome-linked-list/)
```html
Given a singly linked list, determine if it is a palindrome.

Example 1:

Input: 1->2
Output: false
Example 2:

Input: 1->2->2->1
Output: true
Follow up:
Could you do it in O(n) time and O(1) space?
```
```python
class Solution:
    def isPalindrome(self, head: ListNode) -> bool:
        if not head or not head.next:
            return True
        s = f = head
        newHead = None
        while f and f.next:
            f = f.next.next
            t = s.next
            s.next = newHead
            newHead = s
            s = t
        if f:
            s = s.next
        while s:
            if newHead.val != s.val:
                return False
            else:
                s = s.next
                newHead = newHead.next
        return True
```
高频：利用上一题的翻转模板，注意当链表是奇数个时需要：...if f: s = s.next...跳过中间那个节点

## Stack 栈

### [20. Valid Parentheses (Easy)](https://leetcode.com/problems/valid-parentheses/description/)
```html
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: "()"
Output: true
Example 2:

Input: "()[]{}"
Output: true
Example 3:

Input: "(]"
Output: false
Example 4:

Input: "([)]"
Output: false
Example 5:

Input: "{[]}"
Output: true
```
```python
class Solution:
    def isValid(self, s: str) -> bool:
        l = '({['
        stack = []
        for c in s:
            if c in l:
                stack.append(c)
            else:
                if not stack:
                    return False
                t = stack.pop()
                if t == '(' and c != ')':
                    return False
                if t == '{' and c != '}':
                    return False
                if t == '[' and c != ']':
                    return False
        if stack:
            return False
        return True
```
高频：注意在出栈前检验栈是否为空，走完以后检查栈是否为空

### [71. Simplify Path (Medium)](https://leetcode.com/problems/simplify-path/)
```html
Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.

In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix

Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.

Example 1:

Input: "/home/"
Output: "/home"
Explanation: Note that there is no trailing slash after the last directory name.
Example 2:

Input: "/../"
Output: "/"
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.
Example 3:

Input: "/home//foo/"
Output: "/home/foo"
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.
Example 4:

Input: "/a/./b/../../c/"
Output: "/c"
Example 5:

Input: "/a/../../b/../c//.//"
Output: "/c"
Example 6:

Input: "/a//b////c/d//././/.."
Output: "/a/b/c"
```
```python
class Solution:
    def simplifyPath(self, path: str) -> str:
        t = path.split('/')
        s = []
        for p in t:
            if p and p != '.':
                if p == '..':
                    if s:
                        s.pop()
                else:
                    s.append(p)
        if not s:
            return '/'
        else:
            return '/' + '/'.join(s)
```
高频：注意split('/')是'/'的会变成数组里一个空的元素

### [150. Evaluate Reverse Polish Notation (Medium)](https://leetcode.com/problems/evaluate-reverse-polish-notation/)
```html
Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result and there won't be any divide by zero operation.
Example 1:

Input: ["2", "1", "+", "3", "*"]
Output: 9
Explanation: ((2 + 1) * 3) = 9
Example 2:

Input: ["4", "13", "5", "/", "+"]
Output: 6
Explanation: (4 + (13 / 5)) = 6
Example 3:

Input: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]
Output: 22
Explanation:
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```
```python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        operators = "+-*/"
        s = []
        for op in tokens:
            if op not in operators:
                s.append(int(op))
            else:
                b = s.pop()
                a = s.pop()
                if op == "+":
                    res = a + b
                elif op == "-":
                    res = a - b
                elif op == '*':
                    res = a * b
                elif op == "/":
                    if a * b < 0 and a % b != 0:
                        res = a // b + 1
                    else:
                        res = a // b
                s.append(res)
        return s[0]
```
高频：需要注意leetcode里-1//20为0，而python里为-1，-21//20python里为-2。需要单独处理一下

### [155. Min Stack (Easy)](https://leetcode.com/problems/min-stack/)
```html
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.


Example:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
```
```python
class MinStack:

    def __init__(self):
        """
        initialize your data structure here.
        """
        self.stack = []

    def push(self, x: int) -> None:
        curMin = self.getMin() if self.stack else sys.maxsize
        if x < curMin:
            curMin = x
        self.stack.append((x, curMin))

    def pop(self) -> None:
        self.stack.pop()

    def top(self) -> int:
        return self.stack[-1][0]

    def getMin(self) -> int:
        if self.stack:
            return self.stack[-1][1]
```
高频：一个stack就用tuple，两个stack就相当于第二个stack来维持curMin

### [224. Basic Calculator (Hard)](https://leetcode.com/problems/basic-calculator/)
Implement a basic calculator to evaluate a simple expression string.
The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .

Example 1:
Input: "1 + 1"
Output: 2
Example 2:

Input: " 2-1 + 2 "
Output: 3
Example 3:

Input: "(1+(4+5+2)-3)+(6+8)"
Output: 23
Note:
You may assume that the given expression is always valid.
Do not use the eval built-in library function.
```python
class Solution:
    def calculate(self, s: str) -> int:
        num, ans = 0, 0
        sign = 1
        stack = []
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c)
            elif c in "+-":
                ans += sign * num
                num = 0
                sign = 1 if c == "+" else -1
            elif c == "(":
                stack.append(ans)
                stack.append(sign)
                ans = 0
                sign = 1
            elif c == ")":
                ans += sign * num
                ans *= stack.pop()
                ans += stack.pop()
                num = 0
        return ans + sign * num
```
面经：Cruise ...num = 0...ans = 0; sign = 1...num = 0...

### [227. Basic Calculator II (Medium)](https://leetcode.com/problems/basic-calculator-ii/)
Implement a basic calculator to evaluate a simple expression string.
The expression string contains only non-negative integers, +, -, * , / operators and empty spaces . The integer division should truncate toward zero.

Example 1:
Input: "3+2*2"
Output: 7
Example 2:

Input: " 3/2 "
Output: 1
Example 3:

Input: " 3+5 / 2 "
Output: 5

Note:
You may assume that the given expression is always valid.
Do not use the eval built-in library function.
```python
class Solution:
    def calculate(self, s: str) -> int:
        if not s:
            return 0
        num = 0
        operator = "+"
        stack = []
        for i in range(len(s)):
            if s[i].isdigit():
                num = num * 10 + int(s[i])
            if (not s[i].isdigit() and s[i] != " ") or i == len(s) - 1:
                if operator == "+":
                    stack.append(num)
                elif operator == "-":
                    stack.append(-num)
                elif operator == "*":
                    stack.append(stack.pop() * num)
                elif operator == "/":
                    stack.append(int(stack.pop() / num))
                num = 0
                operator = s[i]
        return sum(stack)
```
面经：Cruise。符号或操作符均是在最后变化。因为要处理最后一个字符的问题，所以要么两个if，要么得在s后面跟一个“+”

## Queue 队列

### [LinC 642. Moving Average from Data Stream (Easy)](https://www.lintcode.com/problem/moving-average-from-data-stream/description)
```html
Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.

Example
MovingAverage m = new MovingAverage(3);
m.next(1) = 1 // return 1.00000
m.next(10) = (1 + 10) / 2 // return 5.50000
m.next(3) = (1 + 10 + 3) / 3 // return 4.66667
m.next(5) = (10 + 3 + 5) / 3 // return 6.00000
```
思路：建个 window size 的队列，返回队列的平均值
```python
class MovingAverage:
    q = collections.deque()
    sum = 0
    maxLen = 0
    """
    @param: size: An integer
    """
    def __init__(self, size):
        # do intialization if necessary
        self.maxLen = size
    """
    @param: val: An integer
    @return:  
    """
    def next(self, val):
        # write your code here
        self.q.append(val)
        self.sum += val
        if len(self.q) > self.maxLen:
            temp = self.q.popleft()
            self.sum -= temp
        avg = self.sum / len(self.q)
        return avg

# Your MovingAverage object will be instantiated and called as such:
# obj = MovingAverage(size)
# param = obj.next(val)
```
总结：注意 class 变量要加 self，另外 sum 不要每次都 loop 一遍算， 直接放到 class 变量里，每次只增 and / or 减一次。

## Hash 哈希表

### [290. Word Pattern (Easy)](https://leetcode.com/problems/word-pattern/description/)
```html
Given a pattern and a string str, find if str follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

Example 1:

Input: pattern = "abba", str = "dog cat cat dog"
Output: true
Example 2:

Input:pattern = "abba", str = "dog cat cat fish"
Output: false
Example 3:

Input: pattern = "aaaa", str = "dog cat cat dog"
Output: false
Example 4:

Input: pattern = "abba", str = "dog dog dog dog"
Output: false
Notes:
You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.
```
思路：关键在于懂得建立 pattern 里每个字母和 str 里每个 word 的映射。
```python
class Solution(object):
    def wordPattern(self, pattern, str):
        """
        :type pattern: str
        :type str: str
        :rtype: bool
        """
        words = str.split(' ')
        if len(words) != len(pattern):
            return False
        mapping = {}
        for i, char in enumerate(pattern):
            if char in mapping:
                if mapping[char] != words[i]:
                    return False
            else:
                if words[i] in mapping.values():
                    return False
                mapping[char] = words[i]
        return True
```
总结：注意需要用 enumerate， 因为要同时遍历 pattern 和 str. 很好的哈希表热身题。Word Pattern II 的 str 里没有空格了，不能直接 split，难度直接推到 Hard。目前刷题的水平先跳过吧 :(

### [387. First Unique Character in a String (Easy)](https://leetcode.com/problems/first-unique-character-in-a-string/description/)
```html
Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.

Examples:

s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
Note: You may assume the string contain only lowercase letters.
```
思路：过两遍，第一遍数出现多少次， 第二遍把第一个为 1 的 index 返回
```python
class Solution(object):
    def firstUniqChar(self, s):
        """
        :type s: str
        :rtype: int
        """
        if len(s) == 0:
            return -1
        if len(s) == 1:
            return 0
        dict = {}
        for char in s:
            if char not in dict:
                dict[char] = 1
            else:
                dict[char] += 1
        for index, char in enumerate(s):
            if dict[char] == 1:
                return index
        return -1  
```
总结：基本题，注意 dict entry 初始化为 1 的情况

### [409. Longest Palindrome (Easy)](https://leetcode.com/problems/longest-palindrome/description/)
Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.
This is case sensitive, for example "Aa" is not considered a palindrome here.

Note:
Assume the length of given string will not exceed 1,010.

Example:
Input:
"abccccdd"
Output:
7

Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.
```python
class Solution(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: int
        """
        ans = 0
        from collections import Counter
        counter = Counter(s)
        for c, v in counter.items():
            if v % 2 == 0 or ans % 2 == 0:
                ans += v
            else:
                ans += v - 1
        return ans
```
面经：Amazon。去掉了一刷二刷的hashmap和dp解法。就用简单好懂的解法吧

### [380. Insert Delete GetRandom O(1) (Medium)](https://leetcode.com/problems/insert-delete-getrandom-o1/description/)
```html
Design a data structure that supports all following operations in average O(1) time.

insert(val): Inserts an item val to the set if not already present.
remove(val): Removes an item val from the set if present.
getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
Example:

// Init an empty set.
RandomizedSet randomSet = new RandomizedSet();

// Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomSet.insert(1);

// Returns false as 2 does not exist in the set.
randomSet.remove(2);

// Inserts 2 to the set, returns true. Set now contains [1,2].
randomSet.insert(2);

// getRandom should return either 1 or 2 randomly.
randomSet.getRandom();

// Removes 1 from the set, returns true. Set now contains [2].
randomSet.remove(1);

// 2 was already in the set, so return false.
randomSet.insert(2);

// Since 2 is the only number in the set, getRandom always return 2.
randomSet.getRandom();
```
思路：看答案知道需要用 list 和 dictionary，因为要满足 O(1), 因为仅有 list 的 in 操作不能满足 O(1)
```python
class RandomizedSet(object):

    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.list = []
        self.dict = {}

    def insert(self, val):
        """
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        :type val: int
        :rtype: bool
        """
        if val in self.dict:
            return False
        else:
            self.list.append(val)
            self.dict[val] = len(self.list) - 1
            return True

    def remove(self, val):
        """
        Removes a value from the set. Returns true if the set contained the specified element.
        :type val: int
        :rtype: bool
        """
        if val in self.dict:
            index, lastVal = self.dict[val], self.list[len(self.list) - 1]
            self.list[index], self.dict[lastVal] = lastVal, index
            self.list.pop()
            self.dict.pop(val)
            return True
        else:
            return False

    def getRandom(self):
        """
        Get a random element from the set.
        :rtype: int
        """
        return self.list[random.randint(0, len(self.list) - 1)]


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
```
总结：可能是用 python 的原因，搞明白问什么了一次过

### [LinC 960. First Unique Number in a Stream II (Medium)](960. First Unique Number in a Stream II)
```html
Description
We need to implement a data structure named DataStream. There are two methods required to be implemented:

void add(number) // add a new number
int firstUnique() // return first unique number
You can assume that there must be at least one unique number in the stream when calling the firstUnique.

Example
add(1)
add(2)
firstUnique() => 1
add(1)
firstUnique() => 2
```
思路：维持一个 deque / queue，碰到相同的就 popleft 出去
```python
class DataStream:

    def __init__():
        # do intialization if necessary
        self.q = collections.deque()
        self.dict = {}
    """
    @param num: next number in stream
    @return: nothing
    """
    def add(self, num):
        # write your code here
        if num in self.dict:
            self.dict[num] += 1
        else:
            self.dict[num] = 1
            self.q.append(num)
    """
    @return: the first unique number in stream
    """
    def firstUnique(self):
        # write your code here
        while len(self.q) > 0 and self.dict[self.q[0]] > 1:
                self.q.popleft()
        return self.q[0]
```
总结：1.popleft 要在 firstUnique 里面，不然有些 testcase 过不了；2.注意 popleft 的条件要用 while， 用 for 会出错

### [49. Group Anagrams (Medium)](https://leetcode.com/problems/group-anagrams/)
```html
Given an array of strings, group anagrams together.

Example:

Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
Note:

All inputs will be in lowercase.
The order of your output does not matter.
```
高频
```python
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = collections.defaultdict(list)
        for s in strs:
            tmps = "".join(sorted(s))
            d[tmps].append(s)
        return list(d.values())
```
总结：sorted(s)返回一个char list，“”.join(list)将这个list拼回字符串。list(d.values())可返回defaultdict的值

## Heap (Priority Queue)
### [264. Ugly Number II (Medium)](https://leetcode.com/problems/ugly-number-ii/description/)
```html
Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example:

Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
Note:  

1 is typically treated as an ugly number.
n does not exceed 1690.
```
思路：九章的 python 答案可以 work，但是实在是不好理解。写个好理解一点的版本。heapq 和 hashMap, 从 heapq 中取 n - 1 次（第一个数为 1），每取一次将原始 ugly numbers 2, 3, 5 过一遍
```python
class Solution(object):
    def nthUglyNumber(self, n):
        """
        :type n: int
        :rtype: int
        """
        primes = [2, 3, 5]
        q = [2, 3, 5]
        hashMap = {}
        for i in range(3):
            hashMap[q[i]] = True
        import heapq
        heapq.heapify(q)
        ans = 1
        for i in range(n - 1):
            ans = heapq.heappop(q)
            for j in range(3):
                new_val = ans * primes[j]
                if new_val not in hashMap:
                    heapq.heappush(q, new_val)
                    hashMap[new_val] = True
        return ans
```
总结：可以 AC，也可以理解，good enough
二刷：其实是道dp题，用set和heapq也能过，但是时间上没有优势

### [973. K Closest Points to Origin (Medium)](https://leetcode.com/problems/k-closest-points-to-origin/)
[LinC 612. K Closest Points (Medium)](https://www.lintcode.com/problem/k-closest-points/description)
We have a list of points on the plane.  Find the K closest points to the origin (0, 0).
(Here, the distance between two points on a plane is the Euclidean distance.)
You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)

Example 1:
Input: points = [[1,3],[-2,2]], K = 1
Output: [[-2,2]]
Explanation:
The distance between (1, 3) and the origin is sqrt(10).
The distance between (-2, 2) and the origin is sqrt(8).
Since sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.
We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].

Example 2:
Input: points = [[3,3],[5,-1],[-2,4]], K = 2
Output: [[3,3],[-2,4]]
(The answer [[-2,4],[3,3]] would also be accepted.)

Note:
1 <= K <= points.length <= 10000
-10000 < points[i][0] < 10000
-10000 < points[i][1] < 10000
```python
class Solution:
    def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
        arr = [[p[0] ** 2 + p[1] ** 2, p] for p in points]
        arr.sort(key = lambda x: x[0])
        return [i[1] for i in arr[:K]]
```
面经：Amazon。删掉一刷的思路和总结。简化代码，非常欣慰

### [LinC 545. Top k Largest Numbers II (Medium)](https://www.lintcode.com/problem/top-k-largest-numbers-ii/description)
```html
Implement a data structure, provide two interfaces:
add(number). Add a new number in the data structure.
topk(). Return the top k largest numbers in this data structure. k is given when we create the data structure.

Example
s = new Solution(3);
>> create a new data structure.
s.add(3)
s.add(10)
s.topk()
>> return [10, 3]
s.add(1000)
s.add(-99)
s.topk()
>> return [1000, 10, 3]
s.add(4)
s.topk()
>> return [1000, 10, 4]
s.add(100)
s.topk()
>> return [1000, 100, 10]
```
思路：看着是非常直观的 min heap 问题。。。
```python
class Solution:
    """
    @param: k: An integer
    """
    def __init__(self, k):
        # do intialization if necessary
        self.k = k
        self.q = []
    """
    @param: num: Number to be added
    @return: nothing
    """
    def add(self, num):
        # write your code here
        import heapq
        heapq.heappush(self.q, num)
        if len(self.q) > self.k:
            heapq.heappop(self.q)
    """
    @return: Top k element
    """
    def topk(self):
        # write your code here
        return sorted(self.q, reverse = True)
```
总结：一句 sorted(self.q, reverse = True) 完爆。。。哎， python 的 buit-in function 返回一个 sorted new list...学习了。

### [LinC 486. Merge K Sorted Arrays (Medium)](https://www.lintcode.com/problem/merge-k-sorted-arrays/description)
```html
Given k sorted integer arrays, merge them into one sorted array.

Example
Given 3 sorted arrays:

[
  [1, 3, 5, 7],
  [2, 4, 6],
  [0, 8, 9, 10, 11]
]
return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].

Challenge
Do it in O(N log k).

N is the total number of integers.
k is the number of arrays.
```
思路：看答案，用 heap 屌爆了。加了链接到上面 heap 的部分
```python
class Solution:
    """
    @param arrays: k sorted integer arrays
    @return: a sorted array
    """
    def mergekSortedArrays(self, arrays):
        # write your code here
        import heapq
        q = []
        for level, array in enumerate(arrays):
            if len(array) == 0:
                continue
            heapq.heappush(q, (array[0], level, 0))
        ans = []
        while q:
            cur, level, index = heapq.heappop(q)
            ans.append(cur)
            if index + 1 < len(arrays[level]):
                heapq.heappush(q, (arrays[level][index + 1], level, index + 1))
        return ans
```
总结：只能说 python 的 heapq 屌爆了

### [23. Merge k Sorted Lists (Hard)](https://leetcode.com/problems/merge-k-sorted-lists/description/)
三种方法，都需要练习. 方法一:使用 PriorityQueue 方法二:类似归并排序的分治算法 方法三:自底向上的两两归并算法. 时间复杂度均为 O(NlogK) Strong Hire: 能够用至少2种方法进行实现，代码无大 BUG
```html
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.

Example:

Input:
[
  1->4->5,
  1->3->4,
  2->6
]
Output: 1->1->2->3->4->4->5->6
```
PriorityQueue:
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        dummy = cur = ListNode(0)
        h = []
        import heapq
        for i, n in enumerate(lists):
            if n:
                heapq.heappush(h, (n.val, i, n))
        while h:
            v, i, n = heapq.heappop(h)
            cur.next = n
            cur = cur.next
            if n.next:
                heapq.heappush(h, (n.next.val, i, n.next))
        return dummy.next
```
分治：
```python
class Solution:
    def mergeKLists(self, lists: List[ListNode]) -> ListNode:
        if not lists:
            return None
        n = len(lists)
        if n == 1:
            return lists[0]
        mid = n // 2
        l = self.mergeKLists(lists[:mid])
        r = self.mergeKLists(lists[mid:])
        def merge(l, r):
            dummy = cur = ListNode(0)
            while l and r:
                if l.val < r.val:
                    cur.next = l
                    l = l.next
                else:
                    cur.next = r
                    r = r.next
                cur = cur.next
            cur.next = l if not r else r
            return dummy.next
        return merge(l, r)
```
高频：如果不能加__lt__()，就用(n.val, i, n)tuple防v.val重复的。

### [295. Find Median from Data Stream (Hard)](https://leetcode.com/problems/find-median-from-data-stream/)
```html
Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.

For example,
[2,3,4], the median is 3

[2,3], the median is (2 + 3) / 2 = 2.5

Design a data structure that supports the following two operations:

void addNum(int num) - Add a integer number from the data stream to the data structure.
double findMedian() - Return the median of all elements so far.


Example:

addNum(1)
addNum(2)
findMedian() -> 1.5
addNum(3)
findMedian() -> 2


Follow up:

If all integer numbers from the stream are between 0 and 100, how would you optimize it?
If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?
```
```python
class MedianFinder:
    import heapq
    def __init__(self):
        """
        initialize your data structure here.
        """
        self.upper = []
        self.lower = []

    def addNum(self, num: int) -> None:
        if len(self.upper) == len(self.lower):
            heapq.heappush(self.upper, -heapq.heappushpop(self.lower, -num))
        else:
            heapq.heappush(self.lower, -heapq.heappushpop(self.upper, num))

    def findMedian(self) -> float:
        if len(self.upper) == len(self.lower):
            return self.upper[0] * 0.5 - self.lower[0] * 0.5
        else:
            return float(self.upper[0])
```
面经：Amazon，maxheap + minheap，lower要用负数来模拟maxheap, 数据范围小可以用hashmap

### [743. Network Delay Time (Medium)](https://leetcode.com/problems/network-delay-time/)
There are N network nodes, labelled 1 to N.
Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.
Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.
![network example](https://i.imgur.com/e6P0mDW.png)
Example 1:
Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2
Output: 2
Note:
N will be in the range [1, 100].
K will be in the range [1, N].
The length of times will be in the range [1, 6000].
All edges times[i] = (u, v, w) will have 1 <= u, v <= N and 0 <= w <= 100.
```python
class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:
        graph = collections.defaultdict(dict)
        for u, v, w in times:
            graph[u - 1][v - 1] = w
        distances = [sys.maxsize] * N
        distances[K - 1] = 0
        pq = [(0, K - 1)]
        seen = set()
        while pq:
            dist, v1 = heapq.heappop(pq)
            if v1 not in seen:
                seen.add(v1)
                for v2 in graph[v1]:
                    if v2 not in seen:
                        prev = distances[v2]
                        cur = dist + graph[v1][v2]
                        if cur < prev:
                            distances[v2] = cur
                            heapq.heappush(pq, (cur, v2))
        ans = max(distances)
        return -1 if ans == sys.maxsize else ans
```
面经：练习某家小公司的OA，Dijkstra Graph 最短路径，Dijkstra有很多变种问题，不同写法。

### [787. Cheapest Flights Within K Stops (Medium)](https://leetcode.com/problems/cheapest-flights-within-k-stops/)
```html
There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.

Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.

Example 1:
Input:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
Output: 200
Explanation:
The graph looks like this:

The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.
Example 2:
Input:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
Output: 500
Explanation:
The graph looks like this:

The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.
Note:

The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.
The size of flights will be in range [0, n * (n - 1) / 2].
The format of each flight will be (src, dst, price).
The price of each flight will be in the range [1, 10000].
k is in the range of [0, n - 1].
There will not be any duplicated flights or self cycles.
```
```python
class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
        graph = collections.defaultdict(dict)
        for u, v, w in flights:
            graph[u][v] = w
        costs = [sys.maxsize] * n
        costs[src] = 0
        pq = [(0,  src, 0)]
        while pq:
            import heapq
            cost, v1, stop = heapq.heappop(pq)
            if stop - 1 <= K:
                if v1 == dst:
                    return cost
                for v2 in graph[v1]:
                    pre = costs[v2]
                    cur = cost + graph[v1][v2]
                    if cur < pre:
                        heapq.heappush(pq, (cur, v2, stop + 1))
        return -1
```
面经：与上题不同之处是这里问的不是全局最优，而是符合条件的最优，同一个点可能需要重复访问才能找到符合条件的最优，因此无需seen这个set

### [855. Exam Room (Medium)](https://leetcode.com/problems/exam-room/)
In an exam room, there are N seats in a single row, numbered 0, 1, 2, ..., N-1.
When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)
Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.

Example 1:
Input: ["ExamRoom","seat","seat","seat","seat","leave","seat"], [[10],[],[],[],[],[4],[]]
Output: [null,0,9,4,2,null,5]
Explanation:
ExamRoom(10) -> null
seat() -> 0, no one is in the room, then the student sits at seat number 0.
seat() -> 9, the student sits at the last seat number 9.
seat() -> 4, the student sits at the last seat number 4.
seat() -> 2, the student sits at the last seat number 2.
leave(4) -> null
seat() -> 5, the student sits at the last seat number 5.
​​​​​​​
Note:
1 <= N <= 10^9
ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases.
Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.
```python
class ExamRoom:
    import heapq
    def __init__(self, N: int):
        self.N = N
        self.L = []

    def seat(self) -> int:
        if not self.L:
            res = 0
        else:
            d, res = self.L[0], 0
            for x, y in zip(self.L, self.L[1:]):
                if (y - x) // 2 > d:
                    d = (y - x) // 2
                    res = x + (y - x) // 2
            if self.N - 1 - self.L[-1] > d:
                res = self.N - 1
        bisect.insort(self.L, res)
        return res

    def leave(self, p: int) -> None:
        self.L.remove(p)
```
面经： Cruise。正常思路是得用PriorityQueue。但是corner case写不出来，讨论区答案里java用个特殊的数据结构搭配pq，加上一个trick，不适合模板解题。...if **y - x // 2** > d:...if **self.N - 1 - self.L[-1]** > d: res = self.N - 1...bisect.**insort**(...)...


## Trie
### [208. Implement Trie (Prefix Tree) (Medium)](https://leetcode.com/problems/implement-trie-prefix-tree/description/)
```html
Implement a trie with insert, search, and startsWith methods.

Example:

Trie trie = new Trie();

trie.insert("apple");
trie.search("apple");   // returns true
trie.search("app");     // returns false
trie.startsWith("app"); // returns true
trie.insert("app");   
trie.search("app");     // returns true
Note:

You may assume that all inputs are consist of lowercase letters a-z.
All inputs are guaranteed to be non-empty strings.
```
思路：没啥思路，看答案
```python
class TrieNode:
    # Initialize your data structure here.
    def __init__(self):
        self.word=False
        self.children={}

class Trie:

    def __init__(self):
        self.root = TrieNode()

    # @param {string} word
    # @return {void}
    # Inserts a word into the trie.
    def insert(self, word):
        node=self.root
        for i in word:
            if i not in node.children:
                node.children[i]=TrieNode()
            node=node.children[i]
        node.word=True

    # @param {string} word
    # @return {boolean}
    # Returns if the word is in the trie.
    def search(self, word):
        node=self.root
        for i in word:
            if i not in node.children:
                return False
            node=node.children[i]
        return node.word

    # @param {string} prefix
    # @return {boolean}
    # Returns if there is any word in the trie
    # that starts with the given prefix.
    def startsWith(self, prefix):
        node=self.root
        for i in prefix:
            if i not in node.children:
                return False
            node=node.children[i]
        return True

    # Your Trie object will be instantiated and called as such:
    # obj = Trie()
    # obj.insert(word)
    # param_2 = obj.search(word)
    # param_3 = obj.startsWith(prefix)
```
总结：1.需要加 TrieNode 2. Leetcode 的 python3 找不到 class 是个 bug

### [211. Add and Search Word - Data structure design (Medium)](https://leetcode.com/problems/add-and-search-word-data-structure-design/)
Design a data structure that supports the following two operations:

void addWord(word)
bool search(word)
search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.

Example:

addWord("bad")
addWord("dad")
addWord("mad")
search("pad") -> false
search("bad") -> true
search(".ad") -> true
search("b..") -> true
Note:
You may assume that all words are consist of lowercase letters a-z.
```python
class TrieNode:
    def __init__(self):
        self.end = False
        self.children = {}

class WordDictionary:
    def __init__(self):
        """
        Initialize your data structure here.
        """
        self.root = TrieNode()

    def addWord(self, word: str) -> None:
        """
        Adds a word into the data structure.
        """
        root = self.root
        for c in word:
            if c not in root.children:
                root.children[c] = TrieNode()
            root = root.children[c]
        root.end = True

    def search(self, word: str) -> bool:
        """
        Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter.
        """
        self.ans = False
        self.helper(self.root, word)
        return self.ans
    def helper(self, root, word):
        if not word:
            if root.end:
                self.ans = True
            return
        if word[0] == ".":
            for v in root.children.values():
                self.helper(v, word[1:])
        else:
            if word[0] not in root.children:
                return
            self.helper(root.children[word[0]], word[1:])
```
面经：Celo。insert:...root.end = True...

## Union Find / MST
### [LinC 629. Minimum Spanning Tree (Hard)](https://www.lintcode.com/problem/minimum-spanning-tree/description)
Given a list of Connections, which is the Connection class (the city name at both ends of the edge and a cost between them), find edges that can connect all the cities and spend the least amount.
Return the connects if can connect all the cities, otherwise return empty list.

Example
Example 1:

Input:
["Acity","Bcity",1]
["Acity","Ccity",2]
["Bcity","Ccity",3]
Output:
["Acity","Bcity",1]
["Acity","Ccity",2]
Example 2:

Input:
["Acity","Bcity",2]
["Bcity","Dcity",5]
["Acity","Dcity",4]
["Ccity","Ecity",1]
Output:
[]

Explanation:
No way
Notice
Return the connections sorted by the cost, or sorted city1 name if their cost is same, or sorted city2 if their city1 name is also same.
```python
'''
Definition for a Connection
class Connection:

    def __init__(self, city1, city2, cost):
        self.city1, self.city2, self.cost = city1, city2, cost
'''
class Union:
    def __init__(self, n):
        self.size = n
        self.graph = {}
        for i in range(n):
            self.graph[i] = i

    def query(self, v1, v2):
        return self.find(v1) == self.find(v2)

    def find(self, v):
        if self.graph[v] == v:
            return v
        self.graph[v] = self.find(self.graph[v])
        return self.graph[v]

    def connect(self, v1, v2):
        root_a = self.find(v1)
        root_b = self.find(v2)
        if root_a != root_b:
            self.size -= 1
            self.graph[root_a] = self.graph[root_b]

    def all_connected(self):
        return self.size == 1

class Solution:
    # @param {Connection[]} connections given a list of connections
    # include two cities and cost
    # @return {Connection[]} a list of connections from results
    def lowestCost(self, connections):
        # Write your code here
        connections.sort(key = lambda x: x.city2)
        connections.sort(key = lambda x: x.city1)
        connections.sort(key = lambda x: x.cost)
        citymap = {}
        cnt = 0
        ans = []
        for c in connections:
            if c.city1 not in citymap:
                citymap[c.city1] = cnt
                cnt += 1
            if c.city2 not in citymap:
                citymap[c.city2] = cnt
                cnt += 1
        union = Union(cnt)
        for c in connections:
            c1 = citymap[c.city1]
            c2 = citymap[c.city2]

            if not union.query(c1, c2):
                union.connect(c1, c2)
                ans.append(c)
        return ans if union.all_connected() else []
```
面经：Amazon。todo：刷些 union find 的题看看



# DP Dynamic Programming 动态规划
题型多为： 1. 求最大值或者最小值 2. 判断方案是否可行 3. 统计方案的个数
DP 四要素：1. 状态 state，也就是f[i]或者f[i][j]的物理意义是什么 2. 方程 function，也就是f[i]和f[i - 1]的关系 3. 初始化 initialization，这个方程涉及2个相邻state所以对于state 0肯定是需要初始化的 4. 答案 最大的状态是什么？规划的重点是什么？

### [70. Climbing Stairs (Easy)](https://leetcode.com/problems/climbing-stairs/description/)
```html
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

Example 1:

Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
Example 2:

Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
```
思路：f[n] 是为 n 时的方案数，f[1] 是为 1 时的方案数 = 1。**那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的**，所以递推公式非常容易的就得出了：f[n] = f[n - 1] + f[n - 2]
```python
class Solution:
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n <= 2:
            return n
        f = [0] * (n + 1)
        f[1] = 1
        f[2] = 2
        for i in range(3, n + 1):
            f[i] = f[i - 1] + f[i - 2]
        return f[n]
```
总结：和三年前比没有变化，呵呵呵
高频：没有太多优化空间，背：爬到第n层的方法要么是从第n-1层1步上来的，要不就是从n-2层2步上来的

### [120. Triangle (Medium)](https://leetcode.com/problems/triangle/description/)
```html
Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:

Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
```
思路：看了 top down 的 DP， 还是比较好理解的。f 代表到达 row 和 col 位置的最小 sum，f[i][j] 和 f[i - 1][j - 1] 的关系是：f[i][j] = mins(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]. 规划的目标是最后一行中的最小值。；DP 以外还有三种解法，DFS：Traverse， DFS：Divide and Conquer， DFS：Divide and Conquer 加 memorization
```python
class Solution:
    def minimumTotal(self, triangle):
        """
        :type triangle: List[List[int]]
        :rtype: int
        """
        if len(triangle) == 0:
            return 0
        if len(triangle) == 1:
            return triangle[0][0]
        f = []
        f.append([triangle[0][0]])
        n = len(triangle)
        for i in range(1, n):
            f.append([0] * (i + 1))
        for i in range(1, n):
            f[i][0] = f[i - 1][0] + triangle[i][0]
            f[i][i] = f[i - 1][i - 1] + triangle[i][i]
        for row in range(2, n):
            for col in range(1, row):
                f[row][col] = min(f[row - 1][col - 1], f[row - 1][col]) + triangle[row][col]
        ans = f[n - 1][0]
        for i in range(1, n):
            ans = min(ans, f[n - 1][i])
        return ans
```
高频：
```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        f = [[0] * (i + 1) for i in range(n)]
        f[0][0] = triangle[0][0]
        for i in range(1, n):
            for j in range(i + 1):
                if j == 0:
                    f[i][0] = f[i - 1][0] + triangle[i][j]
                elif j == i:
                    f[i][j] = f[i - 1][j - 1] + triangle[i][j]
                else:
                    f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]
        return min(f[n - 1])
```
bottom up:
```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        if n == 1:
            return triangle[0][0]
        f = [[0] * (i + 1) for i in range(n)]
        f[n - 1] = triangle[-1][:]
        for r in range(n - 2, -1, -1):
            for c in range(r + 1):
                f[r][c] = min(f[r + 1][c], f[r + 1][c + 1]) + triangle[r][c]
        return f[0][0]
```
总结：填充 f 每行第一个和最后一个的时候别忘了 + triangle[i][0] 和 triangle[i][i]
高频：注意topdown：下一层f[i][j]的时候要根据j的情况来分类判断f的值如何获得， 一刷的时候提前把三角的两条边先初始化了，循环的时候不循环那些元素。也是个好办法。代码稍微长一点。bottomup：代码简单很多。还可以进一步将空间降为O(n)，因为之前算出来的f[r + 1][]都没用

### [121. Best Time to Buy and Sell Stock (Easy)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/)
```html
Say you have an array for which the ith element is the price of a given stock on day i.

If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.

Note that you cannot sell a stock before you buy one.

Example 1:
Input: [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.

Example 2:
Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```
DP：
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        lowest = prices[0]
        n = len(prices)
        f = [0] * n
        for i in range(1, n):
            lowest = min(prices[i], lowest)
            f[i] = f[i - 1] if prices[i] <= prices[i - 1] else max(f[i - 1], prices[i] - lowest)
        return f[n - 1]
```
greedy:
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0
        low = prices[0]
        p = 0
        for i in range(1, len(prices)):
            p = max(p, prices[i] - low)
            low = min(low, prices[i])
        return p
```
高频：删了1，2刷的思路答案总结，DP: 要么...f[i] = f[i - 1] if...else max(...)...要么不要max，return max(f)。greedy:

### [122. Best Time to Buy and Sell Stock II (Easy)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
```html
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).

Example 1:

Input: [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.
             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.
Example 2:

Input: [1,2,3,4,5]
Output: 4
Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.
             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are
             engaging multiple transactions at the same time. You must sell before buying again.
Example 3:

Input: [7,6,4,3,1]
Output: 0
Explanation: In this case, no transaction is done, i.e. max profit = 0.
```
```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        ans = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                ans += prices[i] - prices[i - 1]
        return ans
```
高频：可以无限买卖=可以抓住所有价格上升的机会

### [91. Decode Ways (Medium)](https://leetcode.com/problems/decode-ways/)
```html
A message containing letters from A-Z is being encoded to numbers using the following mapping:

'A' -> 1
'B' -> 2
...
'Z' -> 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: "12"
Output: 2
Explanation: It could be decoded as "AB" (1 2) or "L" (12).
Example 2:

Input: "226"
Output: 3
Explanation: It could be decoded as "BZ" (2 26), "VF" (22 6), or "BBF" (2 2 6).
```
高频
```python
class Solution:
    def numDecodings(self, s: str) -> int:
        if s[0] == "0":
            return 0
        n = len(s)
        f = [0] * (n + 1)
        f[0] = f[1] = 1
        for i in range(2, n + 1):
            one = int(s[i - 1: i])
            two = int(s[i - 2: i])
            if one > 0:
                f[i] += f[i - 1]
            if 10 <= two <= 26:
                f[i] += f[i - 2]
        return f[n]
```
总结：f[n]为第n个数的方案数，0个字1个方案，1个字1个方案，...if 10 <= two <= 26:...防止误判“05”， “06”等情况

### [62. Unique Paths (Medium)](https://leetcode.com/problems/unique-paths/)
```html
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).

How many possible unique paths are there?

Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -> Right -> Down
2. Right -> Down -> Right
3. Down -> Right -> Right
Example 2:

Input: m = 7, n = 3
Output: 28
```
```python
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        if m == 1 or n == 1:
            return 1
        f = [[1 for _ in range(m + 1)] for _ in range(n + 1)]
        for r in range(2, n + 1):
            for c in range(2, m + 1):
                f[r][c] = f[r - 1][c] + f[r][c - 1]
        return f[n][m]
```
高频

### [53. Maximum Subarray (Easy)](https://leetcode.com/problems/maximum-subarray/description/)
```html
Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
```
```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return nums[0]
        f = [0 for _ in range(len(nums))]
        f[0] = nums[0]
        ans = f[0]
        for i in range(1, len(nums)):
            if f[i - 1] < 0:
                f[i] = nums[i]    
            else:
                f[i] = f[i - 1] + nums[i]
            if f[i] > ans:
                ans = f[i]
        return ans
```
高频：...if f[i - 1] < 0:...

### [63. Unique Paths II (Medium)](https://leetcode.com/problems/unique-paths-ii/)
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as 1 and 0 respectively in the grid.
Note: m and n will be at most 100.

Example 1:
Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right

space O(mxn):
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
      m, n = len(obstacleGrid), len(obstacleGrid[0])
      dp = [[0] * n for _ in range(m)]
      obs = False
      for i, v in enumerate(obstacleGrid[0]):
          if v == 1:
              obs = True
          if obs:
              dp[0][i] = 0
          else:
              dp[0][i] = 1
      obs = False
      for i in range(m):
          if obstacleGrid[i][0] == 1:
              obs = True
          if obs:
              dp[i][0] = 0
          else:
              dp[i][0] = 1
      for r in range(1, m):
          for c in range(1, n):
              if obstacleGrid[r][c] == 1:
                  dp[r][c] = 0
              else:
                  dp[r][c] = dp[r - 1][c] + dp[r][c - 1]
      return dp[m - 1][n - 1]
```
space: O(n):
```python
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [0] * n
        dp[0] = 1 if obstacleGrid[0][0] == 0 else 0
        obs = False
        for i in range(1, n):
            if obstacleGrid[0][i] == 1:
                obs = True
            if obs:
                dp[i] = 0
            else:
                dp[i] = dp[i - 1]
        for r in range(1, m):
            dp[0] = dp[0] if obstacleGrid[r][0] == 0 else 0
            for c in range(1, n):
                if obstacleGrid[r][c] == 1:
                    dp[c] = 0
                else:
                    dp[c] = dp[c - 1] + dp[c]
        return dp[n - 1]
```
高频
面经：Celo, todo: space: O(1)

### [64. Minimum Path Sum (Medium)](https://leetcode.com/problems/minimum-path-sum/)
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.

Note: You can only move either down or right at any point in time.

Example:

Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
空间O(m*n):
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        rl = len(grid)
        cl = len(grid[0])
        f = [[0 for _ in range(cl)] for _ in range(rl)]
        f[0][0] = grid[0][0]
        for r in range(1, rl):
            f[r][0] = f[r - 1][0] + grid[r][0]
        for c in range(1, cl):
            f[0][c] = f[0][c - 1] + grid[0][c]
        for r in range(1, rl):
            for c in range(1, cl):
                f[r][c] = min(f[r - 1][c], f[r][c - 1]) + grid[r][c]
        return f[rl - 1][cl - 1]
```
空间O(n):
```python
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        dp = [0] * n
        dp[0] = grid[0][0]
        for c in range(1, n):
            dp[c] = dp[c - 1] + grid[0][c]
        for r in range(1, m):
            dp[0] += grid[r][0]
            for c in range(1, n):
                dp[c] = min(dp[c], dp[c - 1]) + grid[r][c]
        return dp[-1]
```
高频：优化空间可以将二维数组f压缩为一维，因为答案不关心中间值
面经：Amazon。优化空间

### [72. Edit Distance (Hard)](https://leetcode.com/problems/edit-distance/)
```html
Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character
Example 1:

Input: word1 = "horse", word2 = "ros"
Output: 3
Explanation:
horse -> rorse (replace 'h' with 'r')
rorse -> rose (remove 'r')
rose -> ros (remove 'e')
Example 2:

Input: word1 = "intention", word2 = "execution"
Output: 5
Explanation:
intention -> inention (remove 't')
inention -> enention (replace 'i' with 'e')
enention -> exention (replace 'n' with 'x')
exention -> exection (replace 'n' with 'c')
exection -> execution (insert 'u')
```
```python

```
高频：f 为从 m 的前 i 个变到 n 的前 j 个字符串所需的最少步骤, 第前 i 个字符串 == word1[i - 1]...if word1[i - 1] == word2[j - 1]: f[i][j] = f[i - 1][j - 1]...else: f[i][j] = min(f[i - 1][j - 1], f[i - 1][j], f[i][j - 1]) + 1

### [132. Palindrome Partitioning II (Hard)](https://leetcode.com/problems/palindrome-partitioning-ii/)
```html
Given a string s, partition s such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of s.

Example:

Input: "aab"
Output: 1
Explanation: The palindrome partitioning ["aa","b"] could be produced using 1 cut.
```
```python
class Solution:
    def minCut(self, s: str) -> int:
        n = len(s)
        f = [0 for _ in range(n)]
        p = [[False for _ in range(n + 1)] for _ in range(n + 1)]
        for i in range(n):
            f[i] = i
            for j in range(i + 1):
                if s[i] == s[j] and (i - j < 2 or p[j + 1][i - 1]):
                    p[j][i] = True
                    f[i] = 0 if j == 0 else min(f[i], f[j - 1] + 1)
        return f[n - 1]
```
高频：f为从0到i(i从0到n-1)字符串的mincut数。p为从j到i是否是回文，因为j（从0到i，i从0到n-1）可能到j+1，因此p [...in range(n **+ 1**)]。...for j in range(i + 1):...and (i - j < 2 **or** p[j + 1][i - 1])...

### [5. Longest Palindromic Substring (Medium)](https://leetcode.com/problems/longest-palindromic-substring/)
```html
Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.
Example 2:

Input: "cbbd"
Output: "bb"
```
暴力：
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        ans = ""
        def palAroundI(l, r):
            while l >= 0 and r < len(s) and s[l] == s[r]:
                l -= 1
                r += 1
            return s[l + 1 : r]
        for i in range(len(s)):
            t = palAroundI(i, i)
            if len(t) > len(ans):
                ans = t
            t = palAroundI(i, i + 1)
            if len(t) > len(ans):
                ans = t
        return ans
```
dp：
```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        ans = ""
        n = len(s)
        f = [[False] * n for _ in range(n)]
        for j in range(n):
            for i in range(j + 1):
                if s[i] == s[j] and (j - i <= 2 or f[i + 1][j - 1]):
                    f[i][j] = True
                if f[i][j] and len(ans) < j - i + 1:
                    ans = s[i:j + 1]
        return ans
```
高频：暴力：...def palAroundI(l, r):...return s[l + 1, r]...。dp: f为从i到j是否为回文串，...for j in range(n): for i in range(j **+ 1**):...

### [55. Jump Game (Medium)](https://leetcode.com/problems/jump-game/)
```html
Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:

Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.
```
dp:
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        f = [0 for _ in range(len(nums))]
        f[0] = nums[0]
        for i in range(1, len(nums)):
            f[i] = max(f[i - 1], nums[i - 1]) - 1
            if f[i] < 0:
                return False
        return True
```
greedy:
```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        reach = 0
        for i, n in enumerate(nums):
            if reach >= len(nums) - 1:
                return True
            if i > reach:
                return False
            reach = max(reach, i + n)
```
高频：dp: f为当前位置的剩余步数 f[i] = max(f[i - 1], nums[i - 1]) - 1。greedy：reach为从0点能到的最远距离

### [96. Unique Binary Search Trees (Medium)](https://leetcode.com/problems/unique-binary-search-trees/)
```html
Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?

Example:

Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST's:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```
```python
class Solution:
    def numTrees(self, n: int) -> int:
        f = [0] * (n + 1)
        f[0] = f[1] = 1
        for i in range(2, n + 1):
            for j in range(1, i + 1):
                f[i] += f[j - 1] * f[i - j]
        return f[n]
```
高频：关键是要知道f推导公式：g[i, n]代表以i为root的bst，f[n] = g[1, n] + g[2, n] +...+ g[n, n], g[i, n] = f[i - 1] \* f[n - i]。以i为root的左边是i - 1个数，右边是n - i个数，具体数值对于f方案数并不是那么重要。

### [95. Unique Binary Search Trees II (Medium)](https://leetcode.com/problems/unique-binary-search-trees-ii/)
```html
Given an integer n, generate all structurally unique BST's (binary search trees) that store values 1 ... n.

Example:

Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST's shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```
```python
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        if n == 0:
            return []
        def gen(s, e):
            if s > e: return [None]
            res = []
            for i in range(s, e + 1):
                for l in gen(s, i - 1):
                    for r in gen(i + 1, e):
                        root = TreeNode(i)
                        root.left = l
                        root.right = r
                        res.append(root)
            return res
        return gen(1, n)
```
高频：看着像非主流dp题。...def gen(s, e):...res = []...for l in gen(s, i **- 1**):...return gen(1, n)

### [198. House Robber (Easy)](https://leetcode.com/problems/house-robber/)
```html
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
```
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        if n == 1:
            return nums[0]
        f = [0] * n
        f[0] = nums[0]
        f[1] = max(nums[0], nums[1])
        for i in range(2, n):
            f[i] = max(f[i - 2] + nums[i], f[i - 1])
        return f[n - 1]
```
高频：f[i]有两个决定， 一个是抢，或不抢当前的房，取max即可
面经：Quora。

### [213. House Robber II (Medium)](https://leetcode.com/problems/house-robber-ii/)
You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.
Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:
Input: [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),
             because they are adjacent houses.
Example 2:
Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        if n == 1:
            return nums[0]
        if n == 2:
            return max(nums[0], nums[1])
        dp1 = [0] * n
        dp2 = [0] * n
        dp1[0] = nums[0]
        dp2[0] = 0
        dp1[1] = dp1[0]
        dp2[1] = nums[1]
        for i in range(2, n - 1):
            dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i])
            dp2[i] = max(dp2[i - 1], dp2[i - 2] + nums[i])  
        return max(dp1[n - 2], max(dp2[n - 2], dp2[n - 3] + nums[n - 1]))
```
面经：Quora。

### [10. Regular Expression Matching (Hard)](https://leetcode.com/problems/regular-expression-matching/)
```html
Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.

'.' Matches any single character.
'*' Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".
Example 2:

Input:
s = "aa"
p = "a*"
Output: true
Explanation: '*' means zero or more of the precedeng element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".
Example 3:

Input:
s = "ab"
p = ".*"
Output: true
Explanation: ".*" means "zero or more (*) of any character (.)".
Example 4:

Input:
s = "aab"
p = "c*a*b"
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches "aab".
Example 5:

Input:
s = "mississippi"
p = "mis*is*p*."
Output: false
```
DP：
```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        ls, lp = len(s), len(p)
        f = [[False] * (lp + 1) for _ in range(ls + 1)]
        f[0][0] = True
        for j in range(1, lp):
            if p[j] == '*':
                f[0][j + 1] = f[0][j - 1]
        for i in range(ls):
            for j in range(lp):
                if p[j] == '.' or s[i] == p[j]:
                    f[i + 1][j + 1] = f[i][j]
                if p[j] == '*':
                    if s[i] != p[j - 1] and p[j - 1] != '.':
                        f[i + 1][j + 1] = f[i + 1][j - 1]
                    else:
                        f[i + 1][j + 1] =  f[i][j + 1] or f[i + 1][j] or f[i + 1][j - 1]
        return f[-1][-1]
```
Backtracking：
```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        if not p:
            return not s
        first_matched = len(s) > 0 and (s[0] == p[0] or p[0] == '.')
        if len(p) > 1 and p[1] == '*':
            return self.isMatch(s, p[2:]) or (first_matched and self.isMatch(s[1:], p))
        else:
            return first_matched and self.isMatch(s[1:], p[1:])
```
高频：dp:怎么写都不是很直观，目前采用range和p[],s[]取值简化写。当前p的字符位'.'或者和s当前字符相等即前进。'\*'分两种情况：1.p前一位不是'.'与当前s字符也不等，a* counts as empty 2.等或者是'.(\*)'，a* counts as multiple a / a* counts as single a / a* counts as empty。时间空间复杂度均为O(ls*lp)
backtracking: 关键要用s = "aab" p = "c*a*b"来记住如果有*，要么忽略这部分p，要么删掉第一个匹配的字符这个算法。...if not p:...firt_matched = len(s) > 0 and (s[0]...)...时间空间复杂度：[leetcode solution](https://leetcode.com/problems/regular-expression-matching/solution/)里有，较复杂

### [44. Wildcard Matching (Hard)](https://leetcode.com/problems/wildcard-matching/)
Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.
'?' Matches any single character.
'*' Matches any sequence of characters (including the empty sequence).
The matching should cover the entire input string (not partial).

Note:
s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like ? or * .

Example 1:
Input:
s = "aa"
p = "a"
Output: false
Explanation: "a" does not match the entire string "aa".

Example 2:
Input:
s = "aa"
p = "*"
Output: true
Explanation: '*' matches any sequence.

Example 3:
Input:
s = "cb"
p = "?a"
Output: false
Explanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.

Example 4:
Input:
s = "adceb"
p = "*a*b"
Output: true
Explanation: The first '*' matches the empty sequence, while the second '* ' matches the substring "dce".

Example 5:
Input:
s = "acdcb"
p = "a*c?b"
Output: false
```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        ls, lp = len(s), len(p)
        dp = [[False] * (lp + 1) for _ in range(ls + 1)]
        dp[0][0] = True
        for j in range(lp):
            if p[j] == '*':
                dp[0][j + 1] = dp[0][j]
        for i in range(ls):
            for j in range(lp):
                if s[i] == p[j] or p[j] == '?':
                    dp[i + 1][j + 1] = dp[i][j]
                elif p[j] == '*':
                    dp[i + 1][j + 1] = dp[i][j + 1] or dp[i + 1][j]
        return dp[-1][-1]
```
高频：和上题统一的模板，当j位置的p是'?' 或者和i位置的s相等时，均前进...f[i + 1][j + 1] = f[i][j],当j位置是'\*'时，两种情况，* count as multiple char / * count as single char ...f[i + 1][j + 1] = f[i][j + 1] or f[i + 1][j]...
面经：Quora。

### [139. Word Break (Medium)](https://leetcode.com/problems/word-break/)
Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.

Note:
The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.

Example 1:
Input: s = "leetcode", wordDict = ["leet", "code"]
Output: true
Explanation: Return true because "leetcode" can be segmented as "leet code".

Example 2:
Input: s = "applepenapple", wordDict = ["apple", "pen"]
Output: true
Explanation: Return true because "applepenapple" can be segmented as "apple pen apple".
             Note that you are allowed to reuse a dictionary word.
Example 3:
Input: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
Output: false
```python
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        dp = [False] * n
        for i in range(n):
            for w in wordDict:
                if w == s[i - len(w) + 1:i + 1] and (dp[i - len(w)] or i == len(w) - 1):
                    dp[i] = True
        return dp[-1]
```
面经：Amazon。这题的关键是搞明白dp[i]的意义是代表此处为结束的单词w在表中，并且w前一位置的dp也为True

### [377. Combination Sum IV (Medium)](https://leetcode.com/problems/combination-sum-iv/)
Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

Example:
nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.
Therefore the output is 7.

Follow up:
What if negative numbers are allowed in the given array?
How does it change the problem?
What limitation we need to add to the question to allow negative numbers?
memo[4] = memo[4 - 1] + memo[4 - 3] + memo[4 - 1]的方法：
```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        memo = [-1] * (target + 1)
        memo[0] = 1
        return self.helper(nums, target, memo)
    def helper(self, nums, target, memo):
        if memo[target] != -1:
            return memo[target]
        cnt = 0
        for i in range(len(nums)):
            if target >= nums[i]:
                cnt += self.helper(nums, target - nums[i], memo)
        memo[target] = cnt
        return cnt
```
稍微DFS一点的模板：
```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        return self.dfs(nums, target, {})
    def dfs(self, nums, target, memo):
        if target == 0:
            return 1
        if target in memo:
            return memo[target]
        res = 0
        for i in range(len(nums)):
            if target >= nums[i]:
                res += self.dfs(nums, target - nums[i], memo)        
        memo[target] = res
        return res
```
面经：Amazon。

## 背包问题
### [322. Coin Change (Medium)](https://leetcode.com/problems/coin-change/)
You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

Example 1:
Input: coins = [1, 2, 5], amount = 11
Output: 3
Explanation: 11 = 5 + 5 + 1

Example 2:
Input: coins = [2], amount = 3
Output: -1

Note:
You may assume that you have an infinite number of each kind of coin.
```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        MAX = float('inf')
        dp = [MAX] * (amount + 1)
        dp[0] = 0
        for i in range(1, amount + 1):
            dp[i] = min([dp[i - coin] if i - coin >= 0 else MAX for coin in coins]) + 1
        if dp[amount] == MAX:
            return -1
        return dp[amount]
```
面经: Cruise。sys.maxsize和float('inf')是有区别的，前者可以被+1，后者+1还是inf

### [474. Ones and Zeroes (Medium)](https://leetcode.com/problems/ones-and-zeroes/)
In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.
For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.
Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.
Note:
The given numbers of 0s and 1s will both not exceed 100
The size of given string array won't exceed 600.

Example 1:
Input: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
Output: 4
Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”

Example 2:
Input: Array = {"10", "0", "1"}, m = 1, n = 1
Output: 2
Explanation: You could form "10", but then you'd have nothing left. Better form "0" and "1".
Bruteforce:
```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
            return self.helper(strs, m, n, 0, collections.defaultdict(dict))
        def helper(self, strs, m, n, idx, memo):
            if m in memo and n in memo[m] and idx in memo[m][n]:
                return memo[m][n][idx]
            memo.setdefault(m, {}).setdefault(n, {})[idx] = 0
            for i in range(idx, len(strs)):
                zeros, ones = strs[i].count('0'), strs[i].count('1')
                if zeros <= m and ones <= n:
                    memo[m][n][idx] = max(memo[m][n][idx], self.helper(strs, m - zeros, n - ones, i + 1, memo) + 1)
            return memo[m][n][idx]
```
DP:
```python
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[[0] * (n + 1) for _ in range(m + 1)] for _ in range(len(strs) + 1)]
        for i in range(1, len(strs) + 1):
            zeros, ones = strs[i - 1].count('0'), strs[i - 1].count('1')
            for j in range(m + 1):
                for k in range(n + 1):
                    if j >= zeros and k >= ones:
                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1)
                    else:
                        dp[i][j][k] = dp[i - 1][j][k]
        return dp[-1][-1][-1]
```
面经：Cruise。可惜两种方法都过不了python3的oj

### [416. Partition Equal Subset Sum (Medium)](https://leetcode.com/problems/partition-equal-subset-sum/)
Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

Note:
Each of the array element will not exceed 100.
The array size will not exceed 200.

Example 1:
Input: [1, 5, 11, 5]
Output: true
Explanation: The array can be partitioned as [1, 5, 5] and [11].

Example 2:
Input: [1, 2, 3, 5]
Output: false
Explanation: The array cannot be partitioned into equal sum subsets.
```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        target = sum(nums)
        if target % 2 != 0:
            return False
        target //= 2
        if max(nums) > target:
            return False
        dp = [[False] * (target + 1) for _ in range(len(nums) + 1)]
        dp[0][0] = True
        for i in range(1, len(nums) + 1):
            dp[i][0] = True
        for j in range(1, target + 1):
            dp[0][j] = False
        for i in range(1, len(nums) + 1):
            for j in range(1, target + 1):
                dp[i][j] = dp[i - 1][j]
                if j >= nums[i - 1]:
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]
        return dp[-1][-1]
```
面经：Cruise。dp为从前i个序列中是否能有组成和为j的组合，要么用i - 1，要么不用i - 1，用的话那么取决于dp[i - 1][j - nums[i -1]]


# Bit Manipulation

### [231. Power of Two (Easy)](https://leetcode.com/problems/power-of-two/description/)
```html
Given an integer, write a function to determine if it is a power of two.

Example 1:

Input: 1
Output: true
Explanation: 2^0 = 1
Example 2:

Input: 16
Output: true
Explanation: 2^4 = 16
Example 3:

Input: 218
Output: false
```
思路：既然是 bit manipulation 的题，肯定是变成 bits 操作，稍微看一下 2 的倍数都是 1 后面全是 0。怎么用 python 检查这个比较没思路。。。
```python
class Solution:
    def isPowerOfTwo(self, n):
        """
        :type n: int
        :rtype: bool
        """
        if n == 1:
            return True
        return bin(n)[2:] == '1'.ljust(len(bin(n)) - 2, '0')
```
总结：看了三年前比较屌的 trick 是 return n & n - 1, 当然 bin 这种土办法也 OK 的。

### [29. Divide Two Integers (Medium)](https://leetcode.com/problems/divide-two-integers/description/)
```html
Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Note:

Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.
```
```python
class Solution:
    def divide(self, dividend: int, divisor: int) -> int:
        positive = (dividend < 0) is (divisor < 0)
        dividend, divisor = abs(dividend), abs(divisor)
        ans = 0
        while dividend >= divisor:
            t, p = divisor, 1
            while dividend >= t:
                dividend -= t
                ans += p
                t <<= 1
                p <<= 1
        if not positive:
            ans = -ans
        if not (-pow(2, 31) <= ans <= pow(2, 31) - 1):
            return pow(2, 31) - 1
        return ans
```
高频：...while dividend >= divisor: ...while dividend >= t: dividend -= t; ans += p; t <<= 1; p <<= 1...

### [89. Gray Code (Medium)](https://leetcode.com/problems/gray-code/)
```html
The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

Example 1:

Input: 2
Output: [0,1,3,2]
Explanation:
00 - 0
01 - 1
11 - 3
10 - 2

For a given n, a gray code sequence may not be uniquely defined.
For example, [0,2,3,1] is also a valid gray code sequence.

00 - 0
10 - 2
11 - 3
01 - 1
Example 2:

Input: 0
Output: [0]
Explanation: We define the gray code sequence to begin with 0.
             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.
             Therefore, for n = 0 the gray code sequence is [0].
```
```python
class Solution:
    def grayCode(self, n: int) -> List[int]:
        ans = [0]
        for i in range(n):
            ans += [x + pow(2, i) for x in reversed(ans)]
        return ans
```
高频：这道题无面试意义，考点在于知道格雷码的[镜像性质](https://www.cnblogs.com/grandyang/p/4315649.html)


# Regular Expression

### [65. Valid Number (Hard)](https://leetcode.com/problems/valid-number/)
```html
Validate if a given string can be interpreted as a decimal number.

Some examples:
"0" => true
" 0.1 " => true
"abc" => false
"1 a" => false
"2e10" => true
" -90e3   " => true
" 1e" => false
"e3" => false
" 6e-1" => true
" 99e2.5 " => false
"53.5e93" => true
" --6 " => false
"-+3" => false
"95a54e53" => false

Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:

Numbers 0-9
Exponent - "e"
Positive/negative sign - "+"/"-"
Decimal point - "."
Of course, the context of these characters also matters in the input.
```
高频：
```python
class Solution:
    def isNumber(self, s: str) -> bool:
        pattern = r'^[+-]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(e[+-]?[0-9]+)?$'
        return re.match(pattern, s.strip()) != None
```
总结：学习了^, [], ?, +, \*, |, $的用法


# Misc 杂类型，偏门/特殊算法

### [7. Reverse Integer (Easy)](https://leetcode.com/problems/reverse-integer/)
```html
Given a 32-bit signed integer, reverse digits of an integer.

Example 1:

Input: 123
Output: 321
Example 2:

Input: -123
Output: -321
Example 3:

Input: 120
Output: 21
Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
```
高频
```python
class Solution:
    def reverse(self, x: int) -> int:
        if x == 0:
            return 0       
        if x > 0:
            sign = 1
        else:
            sign = -1
            x = -x       
        ans = 0
        while x:
            ans = ans * 10 + x % 10
            x //= 10
        if (sign == 1 and ans > pow(2, 31) - 1) or (sign == -1 and ans > pow(2, 31)):
            return 0
        return sign * ans
```
总结：...while x:...ans = ans * 10 + x **%** 10。转成字符串[::-1]是更优解

### [31. Next Permutation (Medium)](https://leetcode.com/problems/next-permutation/)
```html
Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
```
```python
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        if sorted(nums) == nums[::-1]:
            nums.sort()
            return
        i = len(nums) - 2
        while i and nums[i] >= nums[i + 1]:
            i -= 1
        j = len(nums) - 1
        while j and nums[j] <= nums[i]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
        nums[i + 1:] = sorted(nums[i + 1:])
```
高频：傻逼题，高频题表可能被坑了，这道题取决于知道[十四世纪的一个算法](https://leetcode.com/problems/next-permutation/discuss/13867/C%2B%2B-from-Wikipedia)，...i = len(nums) - 2; while...nums[i] **>=** nums[i + 1]:...while...nums[j] **<=** nums[i]:...
还有 Next Permutation II (Medium)

### [60. Permutation Sequence (Medium)](https://leetcode.com/problems/permutation-sequence/)
```html
The set [1,2,3,...,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, we get the following sequence for n = 3:

"123"
"132"
"213"
"231"
"312"
"321"
Given n and k, return the kth permutation sequence.

Note:

Given n will be between 1 and 9 inclusive.
Given k will be between 1 and n! inclusive.
Example 1:

Input: n = 3, k = 3
Output: "213"
Example 2:

Input: n = 4, k = 9
Output: "2314"
```
```python
class Solution:
    def getPermutation(self, n: int, k: int) -> str:
        nums = [i + 1 for i in range(n)]
        ans = ""
        while len(nums) > 1:
            import math
            nf = math.factorial(n - 1)
            i = (k - 1) // nf
            k = (k - 1) % nf + 1
            n -= 1
            ans += str(nums.pop(i))
        ans += str(nums.pop())
        return ans
```
高频：和上题一样无语。讨论区的python答案都不太行，提交结果里的高频可以。...while len(el) > 1:...i = (k - 1) **//** nf; k = (k - 1) % nf **+ 1**...

### [238. Product of Array Except Self (Medium)](https://leetcode.com/problems/product-of-array-except-self/)
```html
Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Example:

Input:  [1,2,3,4]
Output: [24,12,8,6]
Note: Please solve it without division and in O(n).

Follow up:
Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)
```
```python
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        p = 1
        n = len(nums)
        ans = [0] * n
        for i in range(n):
            ans[i] = p
            p *= nums[i]
        p = 1
        for i in range(n - 1, -1, -1):
            ans[i] *= p
            p *= nums[i]
        return ans
```
高频：这题取决于知道从左到右，再从右到左把元素乘一遍放到结果里这个方法

## Sliding Window 滑动窗口
### [438. Find All Anagrams in a String (Medium)](https://leetcode.com/problems/find-all-anagrams-in-a-string/)
```html
Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
The order of output does not matter.

Example 1:
Input:
s: "cbaebabacd" p: "abc"
Output:
[0, 6]
Explanation:
The substring with start index = 0 is "cba", which is an anagram of "abc".
The substring with start index = 6 is "bac", which is an anagram of "abc".

Example 2:
Input:
s: "abab" p: "ab"
Output:
[0, 1, 2]
Explanation:
The substring with start index = 0 is "ab", which is an anagram of "ab".
The substring with start index = 1 is "ba", which is an anagram of "ab".
The substring with start index = 2 is "ab", which is an anagram of "ab".
```
```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        ans = []
        n, m = len(s), len(p)
        from collections import Counter
        pCounter = Counter(p)
        sCounter = Counter(s[:m - 1])
        for i in range(m - 1, n):
            si = i - m + 1
            sCounter[s[i]] += 1
            if pCounter == sCounter:
                ans.append(si)
            sCounter[s[si]] -= 1
            if sCounter[s[si]] == 0:
                del sCounter[s[si]]
        return ans
```
面经：Amazon。注意sCounter[s[si]] -= 1需要减相应字母的计数，否则会产生bug。todo：也用sliding window的模板改下代码

### [3. Longest Substring Without Repeating Characters (Medium)](https://leetcode.com/problems/longest-substring-without-repeating-characters/)
```html
Given a string, find the length of the longest substring without repeating characters.

Example 1:

Input: "abcabcbb"
Output: 3
Explanation: The answer is "abc", with the length of 3.
Example 2:

Input: "bbbbb"
Output: 1
Explanation: The answer is "b", with the length of 1.
Example 3:

Input: "pwwkew"
Output: 3
Explanation: The answer is "wke", with the length of 3.
             Note that the answer must be a substring, "pwke" is a subsequence and not a substring.
```
```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
      l, cnt, window = 0, 0, collections.defaultdict(int)
      res = 0
      for i, c in enumerate(s):
          window[c] += 1
          if window[c] > 1:
              cnt += 1
          while cnt > 0:
              sChar = s[l]
              if i - l > res:
                  res = i - l
              if window[sChar] > 1:
                  cnt -= 1
              window[sChar] -= 1
              l += 1
      return max(res, len(s) - l)
```
面经：Amazon。注意:...if i - l > res:...

### [76. Minimum Window Substring (Hard)](https://leetcode.com/problems/minimum-window-substring/)
```html
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).

Example:

Input: S = "ADOBECODEBANC", T = "ABC"
Output: "BANC"
Note:

If there is no such window in S that covers all characters in T, return the empty string "".
If there is such window, you are guaranteed that there will always be only one unique minimum window in S.
```
```python
class Solution:
    def minWindow(self, s: str, t: str) -> str:
        mapping = collections.Counter(t)
        window = collections.defaultdict(int)
        l, tc, cnt = 0, len(mapping), 0
        ans = ""
        for i, c in enumerate(s):
            window[c] += 1
            if c in mapping and window[c] == mapping[c]:
                cnt += 1
            while cnt == tc:
                sChar = s[l]
                if not ans or i - l + 1 < len(ans):
                    ans = s[l:i + 1]
                window[sChar] -= 1
                if sChar in mapping and window[sChar] < mapping[sChar]:
                    cnt -= 1
                l += 1
        return ans
```
面经：Amazon。todo：总结一下 sliding window / substring search 模板，修改上题答案


# skipped

## DP Dynamic Programming 动态规划
### Best Time to Buy and Sell Stock II & III
### Longest Increasing Subsequence
### Longest Common Subsequence

## Binary Search
### [240. Search a 2D Matrix II (Medium)](https://leetcode.com/problems/search-a-2d-matrix-ii/description/)

## Heap
### [347. Top K Frequent Elements (Medium)](https://leetcode.com/problems/top-k-frequent-elements/description/)

## Hash
### [349. Intersection of Two Arrays (Easy)](https://leetcode.com/problems/intersection-of-two-arrays/description/)
### [350. Intersection of Two Arrays II (Easy)](https://leetcode.com/problems/intersection-of-two-arrays-ii/description/)
