<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治226. Invert Binary Tree (Easy)Invert a binary tree. Example: Input:      4    &#x2F;   \   2     7  &#x2F; \   &#x2F; \ 1   3 6   9 Output:      4    &#x2F;   \">
<meta property="og:type" content="article">
<meta property="og:title" content="面试刷题">
<meta property="og:url" content="http://ahtang.com//2019/08/13/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/index.html">
<meta property="og:site_name" content="汤包个人页">
<meta property="og:description" content="Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治226. Invert Binary Tree (Easy)Invert a binary tree. Example: Input:      4    &#x2F;   \   2     7  &#x2F; \   &#x2F; \ 1   3 6   9 Output:      4    &#x2F;   \">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturnbst.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg">
<meta property="og:image" content="http://ahtang.com/images/lintcode_127_topo_1.jpeg">
<meta property="og:image" content="http://ahtang.com/images/leetcode_17_lett_1.png">
<meta property="og:image" content="https://leetcode.com/static/images/problemset/maze_1_example_1.png">
<meta property="og:image" content="https://leetcode.com/static/images/problemset/maze_1_example_2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png">
<meta property="og:image" content="https://i.imgur.com/e6P0mDW.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/histogram.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/03/06/1266.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/31/1236_example_1.PNG">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/31/tree2.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png">
<meta property="og:image" content="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png">
<meta property="og:image" content="https://assets.leetcode.com/uploads/2019/01/30/interval1.png">
<meta property="article:published_time" content="2019-08-13T13:17:00.000Z">
<meta property="article:modified_time" content="2020-11-29T23:14:04.267Z">
<meta property="article:author" content="Alan">
<meta property="article:tag" content="产品经理，软件工程师，区块链，互联网，流量变现">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png">






  <link rel="canonical" href="http://ahtang.com//2019/08/13/面试刷题/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>面试刷题 | 汤包个人页</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-2155923-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-2155923-2');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">汤包个人页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ahtang.com//2019/08/13/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤包个人页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试刷题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2019-08-13 21:17:00" itemprop="dateCreated datePublished" datetime="2019-08-13T21:17:00+08:00">2019-08-13</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Binary-Tree-based-Recursion-amp-Divide-Conquer-二叉树递归与分治"><a href="#Binary-Tree-based-Recursion-amp-Divide-Conquer-二叉树递归与分治" class="headerlink" title="Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治"></a>Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治</h1><h3 id="226-Invert-Binary-Tree-Easy"><a href="#226-Invert-Binary-Tree-Easy" class="headerlink" title="226. Invert Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">226. Invert Binary Tree (Easy)</a></h3><p>Invert a binary tree.</p>
<pre><code>Example:
Input:
     4
   /   \
  2     7
 / \   / \
1   3 6   9
Output:
     4
   /   \
  7     2
 / \   / \
9   6 3   1
</code></pre><p>Trivia:<br>This problem was inspired by this original tweet by Max Howell:<br>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</p>
<p>递归1:</p>
<pre><code class="python">class Solution:
    def invertTree(self, root):
        if not root:
            return
        root.left, root.right = root.right, root.left
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
</code></pre>
<p>递归2：</p>
<pre><code class="python">class Solution:
    def invertTree(self, root):
        if not root:
            return
        l = self.invertTree(root.left)
        r = self.invertTree(root.right)
        root.left, root.right = r, l
        return root
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def invertTree(self, root):
        if not root:
            return
        stack = [root]
        while stack:
            cur = stack.pop(-1)
            cur.left, cur.right = cur.right, cur.left
            if cur.left:
                stack.append(cur.left)
            if cur.right:
                stack.append(cur.right)
        return root
</code></pre>
<p>九刷：高频</p>
<h3 id="100-Same-Tree-Easy"><a href="#100-Same-Tree-Easy" class="headerlink" title="100. Same Tree (Easy)"></a><a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">100. Same Tree (Easy)</a></h3><p>Given two binary trees, write a function to check if they are the same or not.<br>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p>
<pre><code>Example 1:
Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]
Output: true

Example 2:
Input:     1         1
          /           \
         2             2

        [1,2],     [1,null,2]
Output: false

Example 3:
Input:     1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]
Output: false
</code></pre><p>递归：</p>
<pre><code class="python">class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if not p and not q:
            return True
        if (p and not q) or (q and not p) or p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def isSameTree(self, p: TreeNode, q: TreeNode) -&gt; bool:
        if not p and not q:
            return True
        stack = [(p, q)]
        while stack:
            p, q = stack.pop(-1)
            if not p and not q:
                continue
            if (p and not q) or (q and not p) or p.val != q.val:
                return False
            stack.append((p.left, q.left))
            stack.append((p.right, q.right))
        return True
</code></pre>
<p>五刷：高频</p>
<h3 id="101-Symmetric-Tree-Easy"><a href="#101-Symmetric-Tree-Easy" class="headerlink" title="101. Symmetric Tree (Easy)"></a><a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">101. Symmetric Tree (Easy)</a></h3><p>Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).</p>
<pre><code>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:
    1
   / \
  2   2
 / \ / \
3  4 4  3
But the following [1,2,2,null,3,null,3] is not:
    1
   / \
  2   2
   \   \
   3    3
</code></pre><p>Note:<br>Bonus points if you could solve it both recursively and iteratively.</p>
<p>递归</p>
<pre><code class="python">class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if not root:
            return True
        def helper(l, r):
            if not l and not r:
                return True
            if (l and not r) or (not l and r):
                return False
            return l.val == r.val and helper(l.left, r.right) and helper(l.right, r.left)
        return helper(root.left, root.right)
</code></pre>
<p>遍历</p>
<pre><code class="python">class Solution:
    def isSymmetric(self, root: TreeNode) -&gt; bool:
        if not root:
            return True
        q = [(root.left, root.right)]
        while q:
            l, r = q.pop(0)
            if (l and not r) or (r and not l):
                return False
            if (l and r) and (l.val != r.val):
                return False
            if l:
                q.append((l.left, r.right))
                q.append((l.right, r.left))
        return True
</code></pre>
<p>六刷：高频</p>
<a id="more"></a>
<h3 id="104-Maximum-Depth-of-Binary-Tree-Easy"><a href="#104-Maximum-Depth-of-Binary-Tree-Easy" class="headerlink" title="104. Maximum Depth of Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree (Easy)</a></h3><p>again!<br>Given a binary tree, find its maximum depth.<br>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.<br>Note: A leaf is a node with no children.</p>
<pre><code>Example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its depth = 3.
</code></pre><p>递归1：</p>
<pre><code class="python">class Solution:
    def maxDepth(self, root):
        if not root:
            return 0
        ans = 0
        def helper(root, cur):
            nonlocal ans
            if not root:
                return
            if not root.left and not root.right:
                ans = max(ans, cur)
            helper(root.left, cur + 1)
            helper(root.right, cur + 1)
        helper(root, 1)
        return ans
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def maxDepth(self, root):
        if not root:
            return 0
        ans = 0
        stack = [(root, 1)]
        while stack:
            root, cur = stack.pop()
            if cur &gt; ans:
                ans = cur
            if root.left:
                stack.append((root.left, cur + 1))
            if root.right:
                stack.append((root.right, cur + 1))
        return ans
</code></pre>
<p>七刷：高频</p>
<h3 id="111-Minimum-Depth-of-Binary-Tree-Easy"><a href="#111-Minimum-Depth-of-Binary-Tree-Easy" class="headerlink" title="111. Minimum Depth of Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">111. Minimum Depth of Binary Tree (Easy)</a></h3><p>again!<br>Given a binary tree, find its minimum depth.<br>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.<br>Note: A leaf is a node with no children.<br>Example:</p>
<pre><code>Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its minimum depth = 2.
</code></pre><p>递归</p>
<pre><code class="python">class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        ans = sys.maxsize
        def helper(root, cur):
            nonlocal ans
            if not root:
                return
            if not root.left and not root.right:
                ans = min(ans, cur)
            helper(root.left, cur + 1)
            helper(root.right, cur + 1)
        helper(root, 1)
        return ans
</code></pre>
<p>遍历</p>
<pre><code class="python">class Solution:
    def minDepth(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        q = [(root, 1)]
        while q:
            n, depth = q.pop(0)
            if not n.left and not n.right:
                return depth
            if n.left:
                q.append((n.left, depth + 1))
            if n.right:
                q.append((n.right, depth + 1))
</code></pre>
<p>六刷：高频</p>
<h3 id="144-Binary-Tree-Preorder-Traversal-Medium"><a href="#144-Binary-Tree-Preorder-Traversal-Medium" class="headerlink" title="144. Binary Tree Preorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal (Medium)</a></h3><p>again!<br>Given a binary tree, return the preorder traversal of its nodes’ values.</p>
<pre><code>Example:
Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,2,3]
</code></pre><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<p>递归 Divide and Conquer 分治 / backtracking:</p>
<pre><code class="python">class Solution:
    def preorderTraversal(self, root):
        if not root:
            return []
        l = self.preorderTraversal(root.left)
        r = self.preorderTraversal(root.right)
        return [root.val] + l + r
</code></pre>
<p>遍历:</p>
<pre><code class="python">class Solution:
    def preorderTraversal(self, root):
        if not root:
            return []
        ans = []
        stack = []
        while stack or root:
            if root:
                ans.append(root.val)
                if root.right:
                    stack.append(root.right)
                root = root.left
            else:
                root = stack.pop(-1)
        return ans
</code></pre>
<p>递归 Traverse:</p>
<pre><code class="python">class Solution:
    def preorderTraversal(self, root):
        ans = []
        def helper(root):
            if not root:
                return
            ans.append(root.val)
            helper(root.left)
            helper(root.right)
        helper(root)
        return ans
</code></pre>
<p>七刷</p>
<h3 id="94-Binary-Tree-Inorder-Traversal-Medium"><a href="#94-Binary-Tree-Inorder-Traversal-Medium" class="headerlink" title="94. Binary Tree Inorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal (Medium)</a></h3><p>Given a binary tree, return the inorder traversal of its nodes’ values.<br>Example:</p>
<pre><code>Input: [1,null,2,3]
   1
    \
     2
    /
   3

Output: [1,3,2]
</code></pre><p>Follow up: Recursive solution is trivial, could you do it iteratively?</p>
<p>递归 Traverse:</p>
<pre><code class="python">class Solution:
    def inorderTraversal(self, root):
        ans = []
        def helper(root):
            if not root:
                return
            helper(root.left)
            ans.append(root.val)
            helper(root.right)
        helper(root)
        return ans
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def inorderTraversal(self, root):
        if not root:
          return []
        ans = []
        stack = []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop(-1)
                ans.append(root.val)
                root = root.right
        return ans
</code></pre>
<p>递归 Divide and Conquer/backtracking 分治:</p>
<pre><code class="python">class Solution:
    def inorderTraversal(self, root):
        if not root:
            return []
        l = self.inorderTraversal(root.left)
        r = self.inorderTraversal(root.right)
        return l + [root.val] + r
</code></pre>
<p>八刷：高频, 遍历，stack初始为空，while root or stack: if root: 向左入栈到底 else: root出栈，root.val入ans，向右走…root = <strong>root.right</strong></p>
<h3 id="230-Kth-Smallest-Element-in-a-BST-Medium"><a href="#230-Kth-Smallest-Element-in-a-BST-Medium" class="headerlink" title="230. Kth Smallest Element in a BST (Medium)"></a><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener">230. Kth Smallest Element in a BST (Medium)</a></h3><p>Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ BST’s total elements.</p>
<pre><code>Example 1:
Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1

Example 2:
Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3
</code></pre><p>Follow up:<br>What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</p>
<p>递归：</p>
<pre><code class="python">class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:
        ans = None
        def helper(root):
            nonlocal k, ans
            if not root:
                return
            helper(root.left)
            k -= 1
            if k == 0:
                ans = root.val
                return
            helper(root.right)
        helper(root)
        return ans
</code></pre>
<p>遍历:</p>
<pre><code class="python">class Solution:
    def kthSmallest(self, root: TreeNode, k: int) -&gt; int:
        stack = []
        while stack or root:
            if root:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop()
                k -= 1
                if k == 0:
                    return root.val
                root = root.right
</code></pre>
<p>九刷：面经，Triplebyte, 维萨<br>Follow up: 二叉树经常被修改 如何优化 kthSmallest 这个操作? <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution" target="_blank" rel="noopener">leetcode官方答案</a>提出做一个类似LRU双链表的数据结构实现O(h + k)插删和查询</p>
<h3 id="129-Sum-Root-to-Leaf-Numbers-Medium"><a href="#129-Sum-Root-to-Leaf-Numbers-Medium" class="headerlink" title="129. Sum Root to Leaf Numbers (Medium)"></a><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">129. Sum Root to Leaf Numbers (Medium)</a></h3><p>again!<br>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.<br>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.<br>Find the total sum of all root-to-leaf numbers.<br>Note: A leaf is a node with no children.</p>
<pre><code>Example:
Input: [1,2,3]
    1
   / \
  2   3
Output: 25
Explanation:
The root-to-leaf path 1-&gt;2 represents the number 12.
The root-to-leaf path 1-&gt;3 represents the number 13.
Therefore, sum = 12 + 13 = 25.

Example 2:
Input: [4,9,0,5,1]
    4
   / \
  9   0
 / \
5   1
Output: 1026
Explanation:
The root-to-leaf path 4-&gt;9-&gt;5 represents the number 495.
The root-to-leaf path 4-&gt;9-&gt;1 represents the number 491.
The root-to-leaf path 4-&gt;0 represents the number 40.
Therefore, sum = 495 + 491 + 40 = 1026.
</code></pre><p>递归:</p>
<pre><code class="python">class Solution:
    def sumNumbers(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        ans = 0
        def helper(root, cur):
            nonlocal ans
            if not root:
                return
            cur += root.val
            if not root.left and not root.right:
                ans += cur
                return
            helper(root.left, cur * 10)
            helper(root.right, cur * 10)
        helper(root, 0)
        return ans
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def sumNumbers(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        ans = 0
        s = [(root, 0)]
        while s:
            root, cur = s.pop(-1)
            if root:
                cur += root.val
                if not root.left and not root.right:
                    ans += cur
                    continue
                s.append((root.left, cur * 10))
                s.append((root.right, cur * 10))
        return ans
</code></pre>
<p>七刷：高频</p>
<h3 id="116-Populating-Next-Right-Pointers-in-Each-Node-Medium"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node-Medium" class="headerlink" title="116. Populating Next Right Pointers in Each Node (Medium)"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node" target="_blank" rel="noopener">116. Populating Next Right Pointers in Each Node (Medium)</a></h3><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<pre><code>struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<br>Initially, all next pointers are set to NULL.<br>Example:<br><img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="Populating Next Right Pointers example"></p>
<p>递归：</p>
<pre><code class="python">class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if not root:
            return root
        if root.left:
            root.left.next = root.right
            if root.next:
                root.right.next = root.next.left
        self.connect(root.right)
        self.connect(root.left)
        return root
</code></pre>
<p>六刷：高频，遍历允许用额外空间的话比较简单，就不写了，用O(1)额外空间的遍历写法与117题差不多</p>
<h3 id="117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium" class="headerlink" title="117. Populating Next Right Pointers in Each Node II (Medium)"></a><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii" target="_blank" rel="noopener">117. Populating Next Right Pointers in Each Node II (Medium)</a></h3><p>again!<br>Given a binary tree</p>
<pre><code>struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
</code></pre><p>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.<br>Initially, all next pointers are set to NULL.<br>Example:<br><img src="https://assets.leetcode.com/uploads/2019/02/15/117_sample.png" alt="Populating Next Right Pointers example II"><br>Note:<br>You may only use constant extra space.<br>Recursive approach is fine, implicit stack space does not count as extra space for this problem.</p>
<p>递归：</p>
<pre><code class="python">class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if not root:
            return
        def helper(root):
            if not root:
                return
            if root.left:
                return root.left
            if root.right:
                return root.right
            return helper(root.next)
        if root.left:
            if root.right:
                root.left.next = root.right
            else:
                root.left.next = helper(root.next)
        if root.right:
            root.right.next = helper(root.next)
        self.connect(root.right)
        self.connect(root.left)
        return root
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def connect(self, root: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        if not root:
            return
        cur = root
        nextLevelHead = Node(0)
        while cur:
            p = nextLevelHead
            while cur:
                if cur.left:
                    p.next = cur.left
                    p = p.next
                if cur.right:
                    p.next = cur.right
                    p = p.next
                cur = cur.next
            cur = nextLevelHead.next
            nextLevelHead.next = None
        return root
</code></pre>
<p>六刷：高频</p>
<h3 id="110-Balanced-Binary-Tree-Easy"><a href="#110-Balanced-Binary-Tree-Easy" class="headerlink" title="110. Balanced Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">110. Balanced Binary Tree (Easy)</a></h3><p>again!<br>Given a binary tree, determine if it is height-balanced.<br>For this problem, a height-balanced binary tree is defined as:<br>a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<pre><code>Example 1:
Given the following tree [3,9,20,null,null,15,7]:
    3
   / \
  9  20
    /  \
   15   7
Return true.

Example 2:
Given the following tree [1,2,2,3,3,null,null,4,4]:
       1
      / \
     2   2
    / \
   3   3
  / \
 4   4
Return false.
</code></pre><pre><code class="python">class Solution:
    def isBalanced(self, root):
        if not root:
            return True
        ans = True
        def helper(root):
            nonlocal ans
            if not root:
                return 0
            l = helper(root.left)
            r = helper(root.right)
            if abs(l - r) &gt; 1:
                ans = False
            return max(l, r) + 1
        helper(root)
        return ans
</code></pre>
<p>九刷：高频。<a href="https://leetcode.com/problems/balanced-binary-tree/discuss/35708/VERY-SIMPLE-Python-solutions-(iterative-and-recursive)-both-beat-90" target="_blank" rel="noopener">遍历需要用postorder</a>， 比较难，以后写，TODO</p>
<h3 id="108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy"><a href="#108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy" class="headerlink" title="108. Convert Sorted Array to Binary Search Tree (Easy)"></a><a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree" target="_blank" rel="noopener">108. Convert Sorted Array to Binary Search Tree (Easy)</a></h3><p>Given an array where elements are sorted in ascending order, convert it to a height balanced BST.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:<br>Given the sorted array: [-10,-3,0,5,9],<br>One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</p>
<pre><code>      0
     / \
   -3   9
   /   /
 -10  5
</code></pre><pre><code class="python">class Solution:
    def sortedArrayToBST(self, nums: List[int]) -&gt; TreeNode:
        if not nums:
            return
        rIdx = len(nums) // 2
        root = TreeNode(nums[rIdx])
        root.left = self.sortedArrayToBST(nums[:rIdx])
        root.right = self.sortedArrayToBST(nums[rIdx + 1:])
        return root
</code></pre>
<p>六刷：高频, 面经, Amazon。无他手熟尔 todo：<a href="https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/discuss/35218/Java-Iterative-Solution" target="_blank" rel="noopener">遍历方法</a></p>
<h3 id="109-Convert-Sorted-List-to-Binary-Search-Tree-Medium"><a href="#109-Convert-Sorted-List-to-Binary-Search-Tree-Medium" class="headerlink" title="109. Convert Sorted List to Binary Search Tree (Medium)"></a><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/" target="_blank" rel="noopener">109. Convert Sorted List to Binary Search Tree (Medium)</a></h3><p>again!<br>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.<br>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p>
<p>Example:<br>Given the sorted linked list: [-10,-3,0,5,9],<br>One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:</p>
<pre><code>      0
     / \
   -3   9
   /   /
 -10  5
</code></pre><p>解法1：space: O(n):</p>
<pre><code class="python">class Solution:
    def sortedListToBST(self, head: ListNode) -&gt; TreeNode:
        if not head:
            return None
        arr = []
        while head:
            arr.append(head.val)
            head = head.next
        def helper(nums):
            if not nums:
                return
            rIdx = len(nums) // 2
            root = TreeNode(nums[rIdx])
            root.left = helper(nums[:rIdx])
            root.right = helper(nums[rIdx + 1:])
            return root
        return helper(arr)
</code></pre>
<p>解法2：space: O(1):</p>
<pre><code class="python">class Solution:
    def sortedListToBST(self, head: ListNode) -&gt; TreeNode:
        if h == t:
                return
            s, f = h, h
            while f != t and f.next != t:
                s = s.next
                f = f.next.next
            root = TreeNode(s.val)
            root.left = helper(h, s)
            root.right = helper(s.next, t)
            return root
        return helper(head, None)
</code></pre>
<p>五刷：高频，time complexity: O(n), O(nlogn)</p>
<h3 id="112-Path-Sum-Easy"><a href="#112-Path-Sum-Easy" class="headerlink" title="112. Path Sum (Easy)"></a><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">112. Path Sum (Easy)</a></h3><p>Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.<br>Note: A leaf is a node with no children.</p>
<p>Example:<br>Given the below binary tree and sum = 22,</p>
<pre><code>      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1
return true, as there exist a root-to-leaf path 5-&gt;4-&gt;11-&gt;2 which sum is 22.
</code></pre><pre><code class="python">class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -&gt; bool:
        if not root:
            return False
        ans = False
        def helper(root, cur):
            nonlocal ans
            if not root:
                return
            cur -= root.val
            if not root.left and not root.right:
                if cur == 0:
                    ans =  True
                return
            helper(root.left, cur)
            helper(root.right, cur)
        helper(root, sum)
        return ans
</code></pre>
<p>七刷：高频，面经，Quora</p>
<h3 id="199-Binary-Tree-Right-Side-View-Medium"><a href="#199-Binary-Tree-Right-Side-View-Medium" class="headerlink" title="199. Binary Tree Right Side View (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">199. Binary Tree Right Side View (Medium)</a></h3><p>Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p>
<pre><code>Example:
Input: [1,2,3,null,5,null,4]
Output: [1, 3, 4]
Explanation:

   1            &lt;---
 /   \
2     3         &lt;---
 \     \
  5     4       &lt;---
</code></pre><p>递归：</p>
<pre><code class="python">class Solution:
    def rightSideView(self, root: TreeNode) -&gt; List[int]:
        if not root:
            return []
        ans = []
        def helper(root, depth):
            if not root:
                return
            if depth &gt; len(ans):
                ans.append(root.val)
            helper(root.right, depth + 1)
            helper(root.left, depth + 1)
        helper(root, 1)
        return ans
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def rightSideView(self, root: TreeNode) -&gt; List[int]:
        if not root:
            return []
        ans = []
        q = [root]
        while q:
            ans.append(q[-1].val)
            nq = []
            for root in q:
                if root.left:
                    nq.append(root.left)
                if root.right:
                    nq.append(root.right)
            q = nq
        return ans
</code></pre>
<p>五刷：面经, 维萨</p>
<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree (Easy)"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree (Easy)</a></h3><p>Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”<br>Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]<br><img src="https://assets.leetcode.com/uploads/2018/12/14/binarysearchtree_improved.png" alt="LCA of BST example"><br>Example 1:<br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8<br>Output: 6<br>Explanation: The LCA of nodes 2 and 8 is 6.</p>
<p>Example 2:<br>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4<br>Output: 2<br>Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</p>
<p>Note:<br>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the BST.</p>
<pre><code class="python">class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;: 
        if root.val &lt; p.val and root.val &lt; q.val:
            return self.lowestCommonAncestor(root.right, p, q)
        if root.val &gt; p.val and root.val &gt; q.val:
            return self.lowestCommonAncestor(root.left, p, q)
        return root
</code></pre>
<pre><code class="python">class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;: 
        while True:
            if root.val &lt; p.val and root.val &lt; q.val:
                root = root.right
            elif root.val &gt; p.val and root.val &gt; q.val:
                root = root.left
            else:
                return root
</code></pre>
<p>九刷：注意要return f()，否则会return最顶上的root</p>
<h3 id="543-Diameter-of-Binary-Tree-Easy"><a href="#543-Diameter-of-Binary-Tree-Easy" class="headerlink" title="543. Diameter of Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">543. Diameter of Binary Tree (Easy)</a></h3><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<pre><code>Example:
Given a binary tree
          1
         / \
        2   3
       / \
      4   5
Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
</code></pre><p>Note: The length of path between two nodes is represented by the number of edges between them.</p>
<pre><code class="python">class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        ans = 0
        def helper(root):
            nonlocal ans
            if not root:
                return 0
            l = helper(root.left)
            r = helper(root.right)
            ans = max(ans, l + r)
            return max(l, r) + 1
        helper(root)
        return ans
</code></pre>
<p>五刷： 重点是理解题的本质是求左右子树的maxDepth，O(n) 每一步都算一下当前l+r是否大于ans</p>
<h3 id="563-Binary-Tree-Tilt-Easy"><a href="#563-Binary-Tree-Tilt-Easy" class="headerlink" title="563. Binary Tree Tilt (Easy)"></a><a href="https://leetcode.com/problems/binary-tree-tilt" target="_blank" rel="noopener">563. Binary Tree Tilt (Easy)</a></h3><p>Given a binary tree, return the tilt of the whole tree.<br>The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0.<br>The tilt of the whole tree is defined as the sum of all nodes’ tilt.</p>
<p>Example:</p>
<pre><code>Input:
         1
       /   \
      2     3
Output: 1
</code></pre><p>Explanation:<br>Tilt of node 2 : 0<br>Tilt of node 3 : 0<br>Tilt of node 1 : |2-3| = 1<br>Tilt of binary tree : 0 + 0 + 1 = 1<br>Note:<br>The sum of node values in any subtree won’t exceed the range of 32-bit integer.<br>All the tilt values won’t exceed the range of 32-bit integer.</p>
<pre><code class="python">class Solution:
    def findTilt(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        ans = 0
        def helper(root):
            nonlocal ans
            if not root:
                return 0
            l = helper(root.left)
            r = helper(root.right)
            ans += abs(l - r)
            return l + r + root.val
        helper(root)
        return ans
</code></pre>
<p>六刷：O(n)</p>
<h3 id="669-Trim-a-Binary-Search-Tree-Easy"><a href="#669-Trim-a-Binary-Search-Tree-Easy" class="headerlink" title="669. Trim a Binary Search Tree (Easy)"></a><a href="https://leetcode.com/problems/trim-a-binary-search-tree/" target="_blank" rel="noopener">669. Trim a Binary Search Tree (Easy)</a></h3><p>Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p>
<pre><code>Example 1:
Input:
    1
   / \
  0   2
  L = 1
  R = 2
Output:
    1
      \
       2

Example 2:
Input:
    3
   / \
  0   4
   \
    2
   /
  1
  L = 1
  R = 3
Output:
      3
     /
   2
  /
 1
</code></pre><pre><code class="python">class Solution:
    def trimBST(self, root: TreeNode, L: int, R: int) -&gt; TreeNode:
        if not root:
            return
        l = self.trimBST(root.left, L, R)
        r = self.trimBST(root.right, L, R)
        if root.val &lt; L:
            return r
        if root.val &gt; R:
            return l
        root.left = l
        root.right = r
        return root
</code></pre>
<p>九刷：每层三种情况：1：小于最小，则返回右子树传上来的root；2：大于最大，则返回左子树传上来的root；3.大小之间，将root返回上层</p>
<h3 id="687-Longest-Univalue-Path-Easy"><a href="#687-Longest-Univalue-Path-Easy" class="headerlink" title="687. Longest Univalue Path (Easy)"></a><a href="https://leetcode.com/problems/longest-univalue-path/" target="_blank" rel="noopener">687. Longest Univalue Path (Easy)</a></h3><p>Given a binary tree, find the length of the longest path where each node in the path has the same value. This path may or may not pass through the root.<br>The length of path between two nodes is represented by the number of edges between them.</p>
<pre><code>Example 1:
Input:
              5
             / \
            4   5
           / \   \
          1   1   5
Output: 2

Example 2:
Input:
              1
             / \
            4   5
           / \   \
          4   4   5
Output: 2
</code></pre><p>Note: The given binary tree has not more than 10000 nodes. The height of the tree is not more than 1000.</p>
<pre><code class="python">class Solution:
    def longestUnivaluePath(self, root: TreeNode) -&gt; int:
        ans = 0
        def helper(root, pre):
            nonlocal ans
            if not root:
                return 0
            l = helper(root.left, root)
            r = helper(root.right, root)
            ans = max(ans, l + r)
            if pre and root.val == pre.val:
                return max(l, r) + 1
            else:
                return 0
        helper(root, None)
        return ans     
</code></pre>
<pre><code class="python">class Solution:
    def longestUnivaluePath(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        ans = 0
        def helper(root):
            nonlocal ans
            if not root:
                return 0
            l = helper(root.left)
            r = helper(root.right)
            lL = rL = 0
            if root.left and root.left.val == root.val:
                lL = l + 1
            if root.right and root.right.val == root.val:
                rL = r + 1
            ans = max(ans, lL + rL)
            return max(lL, rL)
        helper(root)
        return ans      
</code></pre>
<p>10刷</p>
<h3 id="114-Flatten-Binary-Tree-to-Linked-List-Medium"><a href="#114-Flatten-Binary-Tree-to-Linked-List-Medium" class="headerlink" title="114. Flatten Binary Tree to Linked List (Medium)"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List (Medium)</a></h3><p>Given a binary tree, flatten it to a linked list in-place.</p>
<pre><code>For example, given the following tree:
    1
   / \
  2   5
 / \   \
3   4   6
The flattened tree should look like:
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
</code></pre><p>解法1：</p>
<pre><code class="python">class Solution:
    def flatten(self, root: TreeNode) -&gt; None:
        if not root:
            return
        l = self.flatten(root.left)
        r = self.flatten(root.right)
        if l:
            root.right = l
            root.left = None
            while l.right:
                l = l.right
            l.right = r
        return root
</code></pre>
<p>九刷：高频</p>
<h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree (Medium)"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description" target="_blank" rel="noopener">236. Lowest Common Ancestor of a Binary Tree (Medium)</a></h3><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.<br>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”<br>Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</p>
<pre><code>        _______3______
       /              \
    ___5__          ___1__
   /      \        /      \
   6      _2       0       8
         /  \
         7   4
</code></pre><p>Example 1:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3<br>Explanation: The LCA of of nodes 5 and 1 is 3.</p>
<p>Example 2:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>Output: 5<br>Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself<br>             according to the LCA definition.</p>
<p>Note:<br>All of the nodes’ values will be unique.<br>p and q are different and both values will exist in the binary tree.</p>
<p>递归：</p>
<pre><code class="python">class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        if not root:
            return
        if root == p or root == q:
            return root
        l = self.lowestCommonAncestor(root.left, p, q)
        r = self.lowestCommonAncestor(root.right, p, q)
        if l and r:
            return root
        elif l:
            return l
        elif r:
            return r
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def lowestCommonAncestor(self, root: &#39;TreeNode&#39;, p: &#39;TreeNode&#39;, q: &#39;TreeNode&#39;) -&gt; &#39;TreeNode&#39;:
        parent = {root: None}
        stack = [root]
        while not (p in parent and q in parent):
            root = stack.pop()
            if root.left:
                parent[root.left] = root
                stack.append(root.left)
            if root.right:
                parent[root.right] = root
                stack.append(root.right)
        ancestors = []
        while p:
            ancestors.append(p)
            p = parent[p]
        while q not in ancestors:
            q = parent[q]
        return q
</code></pre>
<p>13刷：递归：注意最后返回root需要if l and r这个条件。遍历：遍历，建立parent关系，p存入ancestors，遍历p的parent入ancestors，遍历q和q的parent，在ancestors中即返回。TODO 不需要parent关系的算法</p>
<h3 id="285-Inorder-Successor-in-BST-Medium-带锁"><a href="#285-Inorder-Successor-in-BST-Medium-带锁" class="headerlink" title="285. Inorder Successor in BST (Medium) 带锁"></a><a href="https://leetcode.com/problems/inorder-successor-in-bst" target="_blank" rel="noopener">285. Inorder Successor in BST (Medium) 带锁</a></h3><p><a href="http://www.lintcode.com/problem/inorder-successor-in-binary-search-tree/" target="_blank" rel="noopener">LinC 448. Inorder Successor in BST (Medium)</a><br>Given a binary search tree and a node in it, find the in-order successor of that node in the BST.<br>If the given node has no in-order successor in the tree, return null.<br>It’s guaranteed p is one node in the given tree. (You can directly compare the memory address to find p)</p>
<pre><code>Example
Given tree = [2,1] and node = 1:
  2
 /
1
return node 2.

Given tree = [2,1,3] and node = 2:
  2
 / \
1   3
return node 3.
</code></pre><p>Challenge<br>O(h), where h is the height of the BST.</p>
<p>O(n):</p>
<pre><code class="python">class Solution:
    def inorderSuccessor(self, root, p):
        pre = None
        ans = None
        def helper(root):
            nonlocal pre, ans
            if not root:
                return
            helper(root.left)
            if pre == p:
                ans = root
            pre = root
            helper(root.right)
        helper(root)
        return ans
</code></pre>
<p>O(h)</p>
<pre><code class="python">class Solution:
    def inorderSuccessor(self, root, p):
        if not root:
            return
        suc = None
        while root != p:
            if root.val &lt; p.val:
                root = root.right
            else:
                suc = root
                root = root.left
        if not root.right:
            return suc
        root = root.right
        while root.left:
            root = root.left
        return root
</code></pre>
<p>O(n)遍历：</p>
<pre><code class="python">class Solution:
    def inorderSuccessor(self, root, p):
        pre = None
        stack = []
        while root or stack:
            if root:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop()
                if pre == p:
                    return root
                pre = root
                root = root.right
</code></pre>
<p>O(n)递归2：</p>
<pre><code class="python">class Solution:
    def inorderSuccessor(self, root, p):
        found = False
        ans = None
        def helper(root):
            nonlocal found, ans
            if not root:
                return
            helper(root.left)
            if found:
                ans = root
                found = False
            if  root == p:
                found = True
            helper(root.right)
        helper(root)
        return ans
</code></pre>
<p>十刷：递归O(n)解法：注意：处理p == pre需要在递归调用左子树之后，否则pre为空；找到ans以后如果想return需要将pre = None，否则会锁定pre，导致上层的 pre == p，而将上层的root赋值到ans中。<br>O(h)解法：找p的successor，那么如果root比p小p在右子树，反之p在左子树，去左子树之前要记一下suc节点，以防找到的root.val == p.val节点无右节点（即需要返回上层的suc）。如有右节点，则返回右节点中最小的（往右走一个然后返回最左节点）</p>
<h3 id="98-Validate-Binary-Search-Tree-Medium"><a href="#98-Validate-Binary-Search-Tree-Medium" class="headerlink" title="98. Validate Binary Search Tree (Medium)"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/description/" target="_blank" rel="noopener">98. Validate Binary Search Tree (Medium)</a></h3><p>Given a binary tree, determine if it is a valid binary search tree (BST).<br>Assume a BST is defined as follows:<br>The left subtree of a node contains only nodes with keys less than the node’s key.<br>The right subtree of a node contains only nodes with keys greater than the node’s key.<br>Both the left and right subtrees must also be binary search trees.</p>
<pre><code>Example 1:
Input:
    2
   / \
  1   3
Output: true

Example 2:

    5
   / \
  1   4
     / \
    3   6
Output: false

Explanation: The input is: [5,1,4,null,null,3,6]. The root node&#39;s value
             is 5 but its right child&#39;s value is 4.
</code></pre><p>高频<br>递归：</p>
<pre><code class="python">class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        def helper(root, minV, maxV):
            if not root:
                return True
            if root.val &lt;= minV or root.val &gt;= maxV:
                return False
            return helper(root.left, minV, root.val) and helper(root.right, root.val, maxV)
        return helper(root, -sys.maxsize, sys.maxsize)
</code></pre>
<p>inorder 中序遍历遍历无额外数组：</p>
<pre><code class="python">class Solution:
    def isValidBST(self, root):
        stack = []
        pre = None
        while root or stack:
            if root:
                stack.append(root)
                root = root.left
            else:
                root = stack.pop(-1)
                if pre and pre.val &gt;= root.val:
                    return False
                pre = root
                root = root.right
        return True
</code></pre>
<p>inorder 中序遍历递归无额外数组：</p>
<pre><code class="python">class Solution:
    def isValidBST(self, root: TreeNode) -&gt; bool:
        pre = None
        ans = True
        def inorder(root):
            nonlocal pre, ans
            if not root:
                return
            inorder(root.left)
            if pre and pre.val &gt;= root.val:
                ans = False
                return
            pre = root
            inorder(root.right)
        inorder(root)
        return ans
</code></pre>
<p>inorder 中序遍历递归额外数组：</p>
<pre><code class="python">class Solution:
    def isValidBST(self, root):
        res = []
        self.inOrder(root, res)
        for i in range(1, len(res)):
            if res[i] &lt;= res[i - 1]:
                return False
        return True
    def inOrder(self, root, res):
        if not root:
            return
        self.inOrder(root.left, res)
        res.append(root.val)
        self.inOrder(root.right, res)
</code></pre>
<p>高频，七刷：五种解法：1.利用BST性质的递归，2，3.中序遍历递归（有/无额外数组），4，5.中序遍历遍历（有/无额外数组）<br>          中序遍历遍历无额外数组：…if pre and n.val &lt;= pre.val: return False; pre = n…<br>          BST性质递归：…if root.val &lt;<strong>=</strong> minV or root.val &gt;<strong>=</strong> maxV…</p>
<h3 id="572-Subtree-of-Another-Tree-Easy"><a href="#572-Subtree-of-Another-Tree-Easy" class="headerlink" title="572. Subtree of Another Tree (Easy)"></a><a href="https://leetcode.com/problems/subtree-of-another-tree/" target="_blank" rel="noopener">572. Subtree of Another Tree (Easy)</a></h3><p>Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself.</p>
<pre><code>Example 1:
Given tree s:
     3
    / \
   4   5
  / \
 1   2
Given tree t:
   4
  / \
 1   2
Return true, because t has the same structure and node values with a subtree of s.

Example 2:
Given tree s:

     3
    / \
   4   5
  / \
 1   2
    /
   0
Given tree t:
   4
  / \
 1   2
Return false.
</code></pre><p>again!</p>
<pre><code class="python">class Solution:
    def isSubtree(self, s: TreeNode, t: TreeNode) -&gt; bool:
        if not s and t:
            return False
        def helper(s, t):
            if not s and not t:
                return True
            if (s and not t) or (not s and t) or (s.val != t.val):
                return False
            return helper(s.left, t.left) and helper(s.right, t.right)
        return helper(s, t) or self.isSubtree(s.left, t) or self.isSubtree(s.right, t)
</code></pre>
<p>七刷：注意：要判断s是否为空，否则递归入口会因为s为空出错；既有内层helper的递归，又有外层isSubtree递归遍历s树</p>
<h3 id="606-Construct-String-from-Binary-Tree-Easy"><a href="#606-Construct-String-from-Binary-Tree-Easy" class="headerlink" title="606. Construct String from Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/construct-string-from-binary-tree/" target="_blank" rel="noopener">606. Construct String from Binary Tree (Easy)</a></h3><p>You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way.<br>The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree.</p>
<pre><code>Example 1:
Input: Binary tree: [1,2,3,4]
       1
     /   \
    2     3
   /
  4
Output: &quot;1(2(4))(3)&quot;
Explanation: Originallay it needs to be &quot;1(2(4)())(3()())&quot;,
but you need to omit all the unnecessary empty parenthesis pairs.
And it will be &quot;1(2(4))(3)&quot;.

Example 2:
Input: Binary tree: [1,2,3,null,4]
       1
     /   \
    2     3
     \
      4

Output: &quot;1(2()(4))(3)&quot;
Explanation: Almost the same as the first example,
except we can&#39;t omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output.
</code></pre><p>写法1：</p>
<pre><code class="python">class Solution:
    def tree2str(self, t: TreeNode) -&gt; str:
        if not t:
            return &#39;&#39;
        l = self.tree2str(t.left)
        r = self.tree2str(t.right)
        if r:
            return f&quot;{t.val}({l})({r})&quot;
        elif l:
            return f&quot;{t.val}({l})&quot;
        else:
            return str(t.val)
</code></pre>
<p>写法2：</p>
<pre><code class="python">class Solution:
    def tree2str(self, t: TreeNode) -&gt; str:
        if not t:
            return &#39;&#39;
        ans = &#39;&#39;
        def helper(root):
            nonlocal ans
            if not root:
                return &#39;&#39;
            ans += str(root.val)
            if root.right:
                ans += &#39;(&#39;
                helper(root.left)
                ans += &#39;)(&#39;
                helper(root.right)
                ans += &#39;)&#39;
            elif root.left:
                ans += &#39;(&#39;
                helper(root.left)
                ans += &#39;)&#39;
        helper(t)
        return ans
</code></pre>
<p>九刷</p>
<h3 id="297-Serialize-and-Deserialize-Binary-Tree-Hard"><a href="#297-Serialize-and-Deserialize-Binary-Tree-Hard" class="headerlink" title="297. Serialize and Deserialize Binary Tree (Hard)"></a><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree" target="_blank" rel="noopener">297. Serialize and Deserialize Binary Tree (Hard)</a></h3><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.<br>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p>
<pre><code>Example:
You may serialize the following tree:
    1
   / \
  2   3
     / \
    4   5
as &quot;[1,2,3,null,null,4,5]&quot;
</code></pre><p>Clarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.<br>Note: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.</p>
<p>dfs递归：</p>
<pre><code class="python">class Codec:
    def serialize(self, root):
        if not root:
            return
        res = []
        def helper(root):
            if not root:
                res.append(&#39;#&#39;)
                return
            res.append(str(root.val))
            helper(root.left)
            helper(root.right)
        helper(root)
        return &#39;,&#39;.join(res)

    def deserialize(self, data):
        if not data:
            return
        arr = data.split(&#39;,&#39;)
        def helper():
            if not arr:
                return
            rootV = arr.pop(0)
            if rootV == &#39;#&#39;:
                return
            root = TreeNode(int(rootV))
            root.left = helper()
            root.right = helper()
            return root
        return helper()
</code></pre>
<p>bfs：</p>
<pre><code class="python">class Codec:
    def serialize(self, root) -&gt; str:
        if not root:
            return
        q = [root]
        res = []
        while q:
            root = q.pop(0)
            if not root:
                res.append(&#39;#&#39;)
            else:
                res.append(str(root.val))
                q.append(root.left)
                q.append(root.right)
        return &#39;,&#39;.join(res)

    def deserialize(self, data: str) -&gt; TreeNode:
        if not data:
            return
        arr = data.split(&#39;,&#39;)
        root = TreeNode(int(arr.pop(0)))
        q = [root]
        while arr:
            lV, rV = arr.pop(0), arr.pop(0)
            node = q.pop(0)
            if lV != &#39;#&#39;:
                node.left = TreeNode(int(lV))
                q.append(node.left)
            if rV != &#39;#&#39;:
                node.right = TreeNode(int(rV))
                q.append(node.right)
        return root
</code></pre>
<p>dfs遍历：</p>
<pre><code class="python">class Codec:
    def serialize(self, root) -&gt; str:
        if not root:
            return
        stack = [root]
        res = []
        while root or stack:
            if root:
                res.append(str(root.val))
                stack.append(root)
                root = root.left
            else:
                res.append(&#39;#&#39;)
                root = stack.pop()
                root = root.right
        return &#39;,&#39;.join(res)

    def deserialize(self, data: str) -&gt; TreeNode:
        if not data:
            return
        arr = data.split(&#39;,&#39;)
        p = root = TreeNode(arr[0])
        i = 1
        stack = [root]
        while i &lt; len(arr):
            if p:
                if arr[i] != &#39;#&#39;:
                    p.left = TreeNode(int(arr[i]))
                stack.append(p)
                p = p.left
            else:
                p = stack.pop()
                if arr[i] != &#39;#&#39;:
                    p.right = TreeNode(int(arr[i]))
                p = p.right
            i += 1
</code></pre>
<p>九刷</p>
<h3 id="536-Construct-Binary-Tree-from-String-Medium-带锁"><a href="#536-Construct-Binary-Tree-from-String-Medium-带锁" class="headerlink" title="536. Construct Binary Tree from String (Medium) 带锁"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-string" target="_blank" rel="noopener">536. Construct Binary Tree from String (Medium) 带锁</a></h3><p><a href="https://www.lintcode.com/problem/construct-binary-tree-from-string/description" target="_blank" rel="noopener">LinC 880. Construct Binary Tree from String (Medium)</a><br>You need to construct a binary tree from a string consisting of parenthesis and integers.<br>The whole input represents a binary tree. It contains an integer followed by zero, one or two pairs of parenthesis. The integer represents the root’s value and a pair of parenthesis contains a child binary tree with the same structure.<br>You always start to construct the left child node of the parent first if it exists.</p>
<pre><code>Example 1:
Input: &quot;-4(2(3)(1))(6(5))&quot;
Output: {-4,2,6,3,1,5}
Explanation:
The output is look like this:
      -4
     /  \
    2    6
   / \   /
  3   1 5

Example 2:
Input: &quot;1(-1)&quot;
Output: {1,-1}
Explanation:
The output is look like this:
     1
    /
  -1
</code></pre><p>Notice<br>There will only be ‘(‘, ‘)’, ‘-‘ and ‘0’ ~ ‘9’ in the input string.<br>An empty tree is represented by “” instead of “()”.</p>
<pre><code class="python">class Solution:
    def str2tree(self, s):
        if not s:
            return
        stack = []
        i = 0
        while i &lt; len(s):
            cur = &#39;&#39;
            while s[i] and s[i] not in &#39;()&#39;:
                cur += s[i]
                i += 1
            if cur:
                root = TreeNode(int(cur))
                if stack:
                    if stack[-1].left:
                        stack[-1].right = root
                    else:
                        stack[-1].left = root
                stack.append(root)
            if s[i] == &quot;)&quot;:
                stack.pop()
            i += 1
        return stack[0]
</code></pre>
<p>七刷：Facebook tag，递归的方法不适合面试时写，将此较好想的方法写熟。注意：string没有pop()</p>
<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank" rel="noopener">105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</a></h3><p>Given preorder and inorder traversal of a tree, construct the binary tree.<br>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given<br>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>Return the following binary tree:</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><pre><code class="python">class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not preorder:
            return
        root = TreeNode(preorder[0])
        lLen = inorder.index(preorder[0])
        root.left = self.buildTree(preorder[1:lLen + 1], inorder[:lLen])
        root.right = self.buildTree(preorder[lLen + 1:], inorder[lLen + 1:])
        return root
</code></pre>
<p>O(n)时间和空间：</p>
<pre><code class="python">class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -&gt; TreeNode:
        if not preorder:
            return
        iMap = {}
        for i, v in enumerate(inorder):
            iMap[v] = i
        def helper(preS, preE, inS, inE):
            if preS &gt; preE:
                return
            root = TreeNode(preorder[preS])
            if preS &lt; preE:
                lEIIn = iMap[preorder[preS]] - 1
                lEIPre = preS + 1 + lEIIn - inS
                root.left = helper(preS + 1, lEIPre, inS, lEIIn)
                root.right = helper(lEIPre + 1, preE, lEIIn + 2, inE)
            return root
        return helper(0, len(preorder) - 1, 0, len(inorder) - 1)
</code></pre>
<p>六刷：高频</p>
<h3 id="106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium"><a href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium" class="headerlink" title="106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal" target="_blank" rel="noopener">106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</a></h3><p>Given inorder and postorder traversal of a tree, construct the binary tree.<br>Note:<br>You may assume that duplicates do not exist in the tree.</p>
<p>For example, given<br>inorder = [9,3,15,20,7]<br>postorder = [9,15,7,20,3]<br>Return the following binary tree:</p>
<pre><code>    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>O(n^2) time and space:</p>
<pre><code class="python">class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:
        if not postorder:
            return
        root = TreeNode(postorder[-1])
        lLen = inorder.index(postorder[-1])
        root.left = self.buildTree(inorder[:lLen], postorder[:lLen])
        root.right = self.buildTree(inorder[lLen + 1:], postorder[lLen:-1])
        return root
</code></pre>
<p>O(n) time and space:</p>
<pre><code class="python">class Solution:
    def buildTree(self, inorder: List[int], postorder: List[int]) -&gt; TreeNode:
        if not postorder:
            return
        iMap = {}
        for i, v in enumerate(inorder):
            iMap[v] = i
        def helper(inS, inE, postS, postE):
            if inS &gt; inE:
                return
            root = TreeNode(postorder[postE])
            ilE = iMap[root.val] - 1
            plE = postS + ilE - inS                
            root.left = helper(inS, ilE, postS, plE)
            root.right = helper(ilE + 2, inE, plE + 1, postE - 1)
            return root
        return helper(0, len(inorder) - 1, 0, len(postorder) - 1)
</code></pre>
<p>七刷: 高频</p>
<h3 id="889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal-Medium"><a href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal-Medium" class="headerlink" title="889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal" target="_blank" rel="noopener">889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)</a></h3><p>Return any binary tree that matches the given preorder and postorder traversals.<br>Values in the traversals pre and post are distinct positive integers.</p>
<p>Example 1:<br>Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]<br>Output: [1,2,3,4,5,6,7]</p>
<p>Note:<br>1 &lt;= pre.length == post.length &lt;= 30<br>pre[] and post[] are both permutations of 1, 2, …, pre.length.<br>It is guaranteed an answer exists. If there exists multiple answers, you can return any of them.</p>
<p>O(n)时间和空间解：</p>
<pre><code class="python">class Solution:
    def constructFromPrePost(self, pre: List[int], post: List[int]) -&gt; TreeNode:
        if not pre:
            return
        iMap = {}
        for i, v in enumerate(post):
            iMap[v] = i
        def helper(preS, preE, postS, postE):
            if preS &gt; preE:
                return
            root = TreeNode(pre[preS])
            if preS &lt; preE:
                lEIPost = iMap[pre[preS + 1]]
                lEIPre = preS + 1 + lEIPost - postS
                root.left = helper(preS + 1, lEIPre, postS, lEIPost)
                root.right = helper(lEIPre + 1, preE, lEIPost + 1, postE - 1)
            return root
        return helper(0, len(pre) - 1, 0, len(post) - 1)
</code></pre>
<p>六刷：Facebook tag。需要一个insight：root in left subtree of pre show up last in left subtree of post</p>
<h3 id="865-Smallest-Subtree-with-all-the-Deepest-Nodes-Medium"><a href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes-Medium" class="headerlink" title="865. Smallest Subtree with all the Deepest Nodes (Medium)"></a><a href="https://leetcode.com/problems/smallest-subtree-with-all-the-deepest-nodes" target="_blank" rel="noopener">865. Smallest Subtree with all the Deepest Nodes (Medium)</a></h3><p>Given a binary tree rooted at root, the depth of each node is the shortest distance to the root.<br>A node is deepest if it has the largest depth possible among any node in the entire tree.<br>The subtree of a node is that node, plus the set of all descendants of that node.<br>Return the node with the largest depth such that it contains all the deepest nodes in its subtree.</p>
<p>Example 1:<br>Input: [3,5,1,6,2,0,8,null,null,7,4]<br>Output: [2,7,4]<br>Explanation:<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png" alt="Smallest Subtree with all the Deepest Nodes example"><br>We return the node with value 2, colored in yellow in the diagram.<br>The nodes colored in blue are the deepest nodes of the tree.<br>The input “[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]” is a serialization of the given tree.<br>The output “[2, 7, 4]” is a serialization of the subtree rooted at the node with value 2.<br>Both the input and output have TreeNode type.</p>
<p>Note:<br>The number of nodes in the tree will be between 1 and 500.<br>The values of each node are unique.</p>
<pre><code class="python">class Solution:
    def subtreeWithAllDeepest(self, root: TreeNode) -&gt; TreeNode:
        if not root:
            return
        parent = {}
        deepest = []
        maxDepth = 0
        def helper(root, pre, depth):
            nonlocal maxDepth, deepest
            if not root:
                return
            parent[root] = pre
            if depth == maxDepth:
                deepest.append(root)
            if depth &gt; maxDepth:
                maxDepth = depth
                deepest = [root]
            helper(root.left, root, depth + 1)
            helper(root.right, root, depth + 1)
        helper(root, None, 0)
        while len(deepest) &gt; 1:
            deepest = set([parent[root] for root in deepest])
        return list(deepest)[0]
</code></pre>
<p>七刷：Facebook tag</p>
<h3 id="426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List-Medium-带锁"><a href="#426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List-Medium-带锁" class="headerlink" title="426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium) 带锁"></a><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list" target="_blank" rel="noopener">426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium) 带锁</a></h3><p><a href="https://www.lintcode.com/problem/convert-binary-search-tree-to-sorted-doubly-linked-list/description" target="_blank" rel="noopener">Linc 1534. Convert Binary Search Tree to Sorted Doubly Linked List</a></p>
<p>Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list.<br>Let’s take the following BST as an example, it may help you understand the problem better:<br><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdlloriginalbst.png" alt="bstdll original bst example"><br>We want to transform this BST into a circular doubly linked list. Each node in a doubly linked list has a predecessor and successor. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.<br>The figure below shows the circular doubly linked list for the BST above. The “head” symbol means the node it points to is the smallest element of the linked list.<br><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturndll.png" alt="bstdll return dll example"><br>Specifically, we want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. We should return the pointer to the first element of the linked list.<br>The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.<br><img src="https://assets.leetcode.com/uploads/2018/10/12/bstdllreturnbst.png" alt="bstdll return bst example"></p>
<pre><code>Example 1:
Input: {4,2,5,1,3}
        4
       /  \
      2   5
     / \
    1   3
Output: &quot;left:1-&gt;5-&gt;4-&gt;3-&gt;2  right:1-&gt;2-&gt;3-&gt;4-&gt;5&quot;
Explanation:
Left: reverse output
Right: positive sequence output

Example 2:
Input: {2,1,3}
        2
       /  \
      1   3
Output: &quot;left:1-&gt;3-&gt;2  right:1-&gt;2-&gt;3&quot;
</code></pre><pre><code class="python">&quot;&quot;&quot;
Definition of TreeNode:
class TreeNode:
    def __init__(self, val):
        self.val = val
        self.left, self.right = None, None
&quot;&quot;&quot;
class Solution:
    def treeToDoublyList(self, root):
        if not root:
            return
        head = None
        pre = None
        def helper(root):
            nonlocal head, pre
            if not root:
                return
            helper(root.left)
            if not head:
                head = root
            if pre:
                root.left = pre
                pre.right = root
            pre = root
            helper(root.right)
        helper(root)
        head.left = pre
        pre.right = head
        return head
</code></pre>
<p>四刷：Facebook tag。中序遍历可以升序遍历。连接相邻结点，需要用变量 pre 记录上一个遍历到的结点。需要变量head来指向最小（最左）的节点。在递归函数中，先判空，之后对左子结点递归调用，一直递归到最左结点。此时如果 head 为空的话，那么当前就是最左结点，赋值给 head 然后给 pre，对于之后遍历到的结点，就可以和 pre 接上</p>
<h3 id="298-Binary-Tree-Longest-Consecutive-Sequence-Medium-带锁"><a href="#298-Binary-Tree-Longest-Consecutive-Sequence-Medium-带锁" class="headerlink" title="298. Binary Tree Longest Consecutive Sequence (Medium) 带锁"></a><a href="https://leetcode.com/problems/binary-tree-longest-consecutive-sequence" target="_blank" rel="noopener">298. Binary Tree Longest Consecutive Sequence (Medium) 带锁</a></h3><p><a href="https://www.lintcode.com/problem/binary-tree-longest-consecutive-sequence/description" target="_blank" rel="noopener">LinC 595. Binary Tree Longest Consecutive Sequence</a><br>Given a binary tree, find the length of the longest consecutive sequence path.<br>The path refers to any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The longest consecutive path need to be from parent to child (cannot be the reverse).</p>
<pre><code>Example
Example 1:
Input:
   1
    \
     3
    / \
   2   4
        \
         5
Output:3
Explanation:
Longest consecutive sequence path is 3-4-5, so return 3.

Example 2:
Input:
   2
    \
     3
    /
   2
  /
 1
Output:2
Explanation:
Longest consecutive sequence path is 2-3,not 3-2-1, so return 2.
</code></pre><pre><code class="python">class Solution:
    def longestConsecutive(self, root):
        if not root:
            return 0
        ans = 0
        def helper(root, pre, cur):
            nonlocal ans
            if not root:
                return
            if root.val == pre.val + 1:
                cur += 1
            else:
                cur = 1
            ans = max(ans, cur)
            helper(root.left, root, cur)
            helper(root.right, root, cur)
        helper(root, root, 1)
        return ans
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def longestConsecutive(self, root):
        if not root:
            return 0
        ans = 0
        q = [(root, root, 1)]
        while q:
            root, pre, cur = q.pop(0)
            if not root:
                continue
            if root.val == pre.val + 1:
                cur += 1
            else:
                cur = 1
            ans = max(ans, cur)
            q.append((root.left, root, cur))
            q.append((root.right, root, cur))
        return ans
</code></pre>
<p>五刷：Facebook tag</p>
<h3 id="897-Increasing-Order-Search-Tree-Easy"><a href="#897-Increasing-Order-Search-Tree-Easy" class="headerlink" title="897. Increasing Order Search Tree (Easy)"></a><a href="https://leetcode.com/problems/increasing-order-search-tree/" target="_blank" rel="noopener">897. Increasing Order Search Tree (Easy)</a></h3><p>Given a binary search tree, rearrange the tree in in-order so that the leftmost node in the tree is now the root of the tree, and every node has no left child and only 1 right child.</p>
<pre><code>Example 1:
Input: [5,3,6,2,4,null,8,1,null,null,null,7,9]
       5
      / \
    3    6
   / \    \
  2   4    8
 /        / \
1        7   9
Output: [1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]
 1
  \
   2
    \
     3
      \
       4
        \
         5
          \
           6
            \
             7
              \
               8
                \
                 9
</code></pre><p>Note:<br>The number of nodes in the given tree will be between 1 and 100.<br>Each node will have a unique integer value from 0 to 1000.</p>
<pre><code class="python">class Solution:
    def increasingBST(self, root: TreeNode) -&gt; TreeNode:
        dummy = pre = TreeNode(0)
        def helper(root):
            nonlocal pre
            if not root:
                return
            helper(root.left)
            root.left = None
            pre.right = root
            pre = root
            helper(root.right)
        helper(root)
        return dummy.right
</code></pre>
<p>三刷：Facebook tag，关键要建立pre</p>
<h2 id="Tree-based-BFS-基于树的-BFS"><a href="#Tree-based-BFS-基于树的-BFS" class="headerlink" title="Tree based BFS 基于树的 BFS"></a>Tree based BFS 基于树的 BFS</h2><h3 id="102-Binary-Tree-Level-Order-Traversal-Medium"><a href="#102-Binary-Tree-Level-Order-Traversal-Medium" class="headerlink" title="102. Binary Tree Level Order Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal (Medium)</a></h3><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<pre><code>For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its level order traversal as:
[
  [3],
  [9,20],
  [15,7]
]
</code></pre><p>递归：</p>
<pre><code class="python">class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        ans = []
        def helper(root, depth):
            if not root:
                return
            if depth == len(ans):
                ans.append([root.val])
            else:
                ans[depth].append(root.val)
            helper(root.left, depth + 1)
            helper(root.right, depth + 1)
        helper(root, 0)
        return ans
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def levelOrder(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        ans = []
        q = [root]
        while q:
            cur = []
            for _ in range(len(q)):
                n = q.pop(0)
                cur.append(n.val)
                if n.left:
                    q.append(n.left)
                if n.right:
                    q.append(n.right)
            ans.append(cur)
        return ans
</code></pre>
<p>四刷：高频</p>
<h3 id="107-Binary-Tree-Level-Order-Traversal-II-Easy"><a href="#107-Binary-Tree-Level-Order-Traversal-II-Easy" class="headerlink" title="107. Binary Tree Level Order Traversal II (Easy)"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">107. Binary Tree Level Order Traversal II (Easy)</a></h3><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p>
<pre><code>For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its bottom-up level order traversal as:
[
  [15,7],
  [9,20],
  [3]
]
</code></pre><pre><code class="python">class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        ans = []
        def helper(root, depth):
            if not root:
                return
            if depth == len(ans) :
                ans.insert(0, [])
            ans[len(ans) - 1 - depth].append(root.val)
            helper(root.left, depth + 1)
            helper(root.right, depth + 1)
        helper(root, 0)
        return ans
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        if not root:
            return []
        q = [root]
        ans = []
        while q:
            nq = []
            cur = []
            for root in q:
                cur.append(root.val)
                if root.left:
                    nq.append(root.left)
                if root.right:
                    nq.append(root.right)
            ans.insert(0, cur)
            q = nq
        return ans
</code></pre>
<p>五刷：高频。list.insert(0, x), 也可用deque的appendleft</p>
<h3 id="103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/" target="_blank" rel="noopener">103. Binary Tree Zigzag Level Order Traversal (Medium)</a></h3><p><a href="http://www.lintcode.com/en/problem/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">LinC 71. Binary Tree Zigzag Order Traversal</a><br>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p>
<pre><code>For example:
Given binary tree [3,9,20,null,null,15,7],
    3
   / \
  9  20
    /  \
   15   7
return its zigzag level order traversal as:
[
  [3],
  [20,9],
  [15,7]
]
</code></pre><pre><code class="python">class Solution:
    def zigzagLevelOrder(self, root):
        if not root:
            return []
        q = [root]
        ans = []
        zig = True
        while q:        
            ans.append([root.val for root in q])
            if not zig:
                ans[-1].reverse()
            zig = not zig
            nq = []
            for root in q:
                if root.left:
                    nq.append(root.left)
                if root.right:
                    nq.append(root.right)
            q = nq
        return ans       
</code></pre>
<p>二刷：高频，递归的话可以用list.insert(0, val)来处理偶数层的reverse</p>
<h3 id="958-Check-Completeness-of-a-Binary-Tree-Medium"><a href="#958-Check-Completeness-of-a-Binary-Tree-Medium" class="headerlink" title="958. Check Completeness of a Binary Tree (Medium)"></a><a href="https://leetcode.com/problems/check-completeness-of-a-binary-tree/" target="_blank" rel="noopener">958. Check Completeness of a Binary Tree (Medium)</a></h3><p>Given a binary tree, determine if it is a complete binary tree.<br>Definition of a complete binary tree from Wikipedia:<br>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-1.png" alt="Check Completeness of a Binary Tree example1"><br>Input: [1,2,3,4,5,6]<br>Output: true<br>Explanation: Every level before the last is full (ie. levels with node-values {1} and {2, 3}), and all nodes in the last level ({4, 5, 6}) are as far left as possible.</p>
<p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2018/12/15/complete-binary-tree-2.png" alt="Check Completeness of a Binary Tree example1"><br>Input: [1,2,3,4,5,null,7]<br>Output: false<br>Explanation: The node with value 7 isn’t as far left as possible.</p>
<p>Note:<br>The tree will have between 1 and 100 nodes.</p>
<pre><code class="python">class Solution:
    def isCompleteTree(self, root: TreeNode) -&gt; bool:
        q = [root]
        noMore = False
        while q:
            root = q.pop(0)
            if root and noMore:
                return False
            if not root:
                noMore = True
            else:
                q.append(root.left)
                q.append(root.right)
        return True
</code></pre>
<p>五刷</p>
<h1 id="Binary-Search-amp-LogN-Algorithm"><a href="#Binary-Search-amp-LogN-Algorithm" class="headerlink" title="Binary Search &amp; LogN Algorithm"></a>Binary Search &amp; LogN Algorithm</h1><p>二分法模板: start + 1 &lt; end; start + (end - start) / 2; A[mid] ==, &lt;, &gt;; A[start] A[end] ? target</p>
<h3 id="704-Binary-Search-Easy"><a href="#704-Binary-Search-Easy" class="headerlink" title="704. Binary Search (Easy)"></a><a href="https://leetcode.com/problems/binary-search/description/" target="_blank" rel="noopener">704. Binary Search (Easy)</a></h3><p><a href="https://www.lintcode.com/problem/classical-binary-search/description" target="_blank" rel="noopener">lintcode’s version</a></p>
<pre><code class="html">Find any position of a target number in a sorted array. Return -1 if target does not exist.

Example
Given [1, 2, 2, 4, 5, 5].

For target = 2, return 1 or 2.

For target = 5, return 4 or 5.

For target = 6, return -1.

Challenge
O(logn) time
</code></pre>
<pre><code class="python">class Solution:
    &quot;&quot;&quot;
    @param: nums: An integer array sorted in ascending order
    @param: target: An integer
    @return: An integer
    &quot;&quot;&quot;
    def findPosition(self, nums, target):
        # write your code here
        if (len(nums) == 0):
          return -1
        start, end = 0, len(nums) - 1
        while (start + 1 &lt; end):
            mid = start + (end - start) // 2
            if (nums[mid] == target):
                return mid
            elif (nums[mid] &lt; target):
                start = mid
            else:
                end = mid
        if (nums[start] == target):
            return start
        if (nums[end] == target):
            return end
        return -1

</code></pre>
<p>总结：背好模板，lintcode 的 test case 包含空输入数组，需要 python3 的 // 整除运算符才能过</p>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def search(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: int
        &quot;&quot;&quot;
        if len(nums) == 0 or (len(nums) == 1 and nums[0] != target):
            return -1
        return self.helper(nums, target, 0, len(nums) - 1)
    def helper(self, nums, target, start, end):
        if (start &gt; end):
            return -1
        if (start + 1 == end):
            if nums[end] == target:
                return end
            if nums[start] == target:
                return start
            else:
                return -1
        mid = start + (end - start) // 2
        if (nums[mid] == target):
            return mid
        elif (nums[mid] &lt; target):
            start = mid
        else:
            end = mid
        return self.helper(nums, target, start, end)
</code></pre>
<p>总结：不背模板也能写。 但是写出来不如模板的优雅。如果递归调用前面不加 return 的话，还会发生不 return 的情况</p>
<h3 id="LinC-14-First-Position-of-Target-Easy"><a href="#LinC-14-First-Position-of-Target-Easy" class="headerlink" title="LinC 14. First Position of Target (Easy)"></a><a href="https://www.lintcode.com/problem/first-position-of-target/description" target="_blank" rel="noopener">LinC 14. First Position of Target (Easy)</a></h3><pre><code class="html">Description
For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.

If the target number does not exist in the array, return -1.

Have you met this question in a real interview?
Example
If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.

Challenge
If the count of numbers is bigger than 2^32, can your code work properly?
</code></pre>
<p>思路：找到了不要 return，扔掉大的一半，继续找</p>
<pre><code class="python">class Solution:
    &quot;&quot;&quot;
    @param nums: The integer array.
    @param target: Target to find.
    @return: The first position of target. Position starts from 0.
    &quot;&quot;&quot;
    def binarySearch(self, nums, target):
        # write your code here
        if (len(nums) == 0):
            return -1
        start, end = 0, len(nums) - 1
        while (start + 1 &lt; end):
            mid = start + (end - start) // 2
            if (nums[mid] &gt;= target):
                end = mid
            else:
                start = mid
        if (nums[start] == target):
            return start
        if (nums[end] == target):
            return end
        return -1
</code></pre>
<p>总结：背好模板，模板 v5</p>
<h3 id="278-First-Bad-Version-Easy"><a href="#278-First-Bad-Version-Easy" class="headerlink" title="278. First Bad Version (Easy)"></a><a href="https://leetcode.com/problems/first-bad-version/description/" target="_blank" rel="noopener">278. First Bad Version (Easy)</a></h3><pre><code class="html">You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

Example:

Given n = 5, and version = 4 is the first bad version.

call isBadVersion(3) -&gt; false
call isBadVersion(5) -&gt; true
call isBadVersion(4) -&gt; true

Then 4 is the first bad version.
</code></pre>
<p>思路：前面 first position of target 的变体，可以不做</p>
<pre><code class="python"># The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution(object):
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        start, end = 0, n
        while (start + 1 &lt; end):
            mid = start + (end - start) // 2
            if (isBadVersion(mid)):
                end = mid
            else:
                start = mid
        if (isBadVersion(start)):
            return start
        if (isBadVersion(end)):
            return end
        return -1
</code></pre>
<p>总结：可不做</p>
<p>二刷：</p>
<pre><code class="python"># The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

class Solution:
    def firstBadVersion(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        if n == 1:
            return 1 if isBadVersion(1) else -1
        return self.helper(1, n)
    def helper(self, start, end):
        if start + 1 == end:
            return start if isBadVersion(start) else end
        mid = start + (end - start) // 2
        if isBadVersion(mid):
            end = mid
        else:
            start = mid
        return self.helper(start, end)
</code></pre>
<p>总结：递归思维更自然。二刷之前没有看模板。模板大法更普适</p>
<h3 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/" target="_blank" rel="noopener">34. Find First and Last Position of Element in Sorted Array (Medium)</a></h3><pre><code class="html">Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.

Your algorithm&#39;s runtime complexity must be in the order of O(log n).

If the target is not found in the array, return [-1, -1].

Example 1:

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
Example 2:

Input: nums = [5,7,7,8,8,10], target = 6
Output: [-1,-1]
</code></pre>
<p>思路：二分法找 Target, 两次二分法，一次找左边界，一次找右边界</p>
<pre><code class="python">class Solution(object):
    def searchRange(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        ans = [-1, -1]
        if len(nums) == 0:
            return ans
        l, r = 0, len(nums) - 1
        # 找左边界
        while l + 1 &lt; r:
            mid = l + (r - l ) // 2
            if nums[mid] &lt; target:
                l = mid
            else:
                r = mid

        if nums[l] == target:
            ans[0] = l
        elif nums[r] == target:
            ans[0] = r
        else:
            return ans

        # 找右边界
        r = len(nums) - 1
        while l + 1 &lt; r:
            mid = l + (r - l) // 2
            if nums[mid] &lt;= target:
                l = mid
            else:
                r = mid
        if nums[r] == target:
            ans[1] = r
        elif nums[l] == target:
            ans[1] = l
        return ans
</code></pre>
<p>总结：按今天的水平，写的时候注意 while 的终止条件是 while l + 1 &lt; r (l, r 不要重合就终止循环)。 两年多前写了稍微更简洁些的版本。可以回头再看看能不能写得出。</p>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def searchRange(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;

        if len(nums) == 0:
            return [-1, -1]

        if len(nums) == 1:
            return [0, 0] if nums[0] == target else [-1, -1]

        start, end = 0, len(nums) - 1
        while (start + 1 &lt; end):
            mid = start + (end - start) // 2
            if nums[mid] == target:
                end = mid
            if nums[mid] &lt; target:
                start = mid
            if nums[mid] &gt; target:
                end = mid
        res1 = end if nums[end] == target else -1
        res1 = start if nums[start] == target else res1
        if res1 == -1:
            return [-1, -1]

        start, end = res1, len(nums) - 1
        while(start + 1 &lt; end):
            mid = start + (end - start) // 2
            if nums[mid] == target:
                start = mid
            if nums[mid] &lt; target:
                start = mid
            if nums[mid] &gt; target:
                end = mid
        res2 = start if nums[start] == target else -1
        res2 = end if nums[end] == target else res2
        if res2 == -1:
            return [res1, res1]
        else:
            return [res1, res2]
</code></pre>
<p>总结： 凭借模板大法战胜 100% 的 python 选手。<br>高频：…if <strong>nums[mid] == target</strong>: r = <strong>mid</strong>…res1 = r … res1 = l …else res1; if res1 == -1: return [-1, -1]…res2 = l … res2 = r …else res2; if …: return [res1, res1]…</p>
<h3 id="LinC-61-Search-for-a-Range-Medium"><a href="#LinC-61-Search-for-a-Range-Medium" class="headerlink" title="LinC 61. Search for a Range (Medium)"></a><a href="https://www.lintcode.com/problem/search-for-a-range/description" target="_blank" rel="noopener">LinC 61. Search for a Range (Medium)</a></h3><pre><code class="html">Given a sorted array of n integers, find the starting and ending position of a given target value.

If the target is not found in the array, return [-1, -1].

Example
Given [5, 7, 7, 8, 8, 10] and target value 8,
return [3, 4].

Challenge
O(log n) time.
</code></pre>
<p>思路：找一个数的第一次和最后一次出现的 index</p>
<pre><code class="python">class Solution:
    &quot;&quot;&quot;
    @param A: an integer sorted array
    @param target: an integer to be inserted
    @return: a list of length 2, [index1, index2]
    &quot;&quot;&quot;
    def searchRange(self, A, target):
        # write your code here
        firstO, lastO = -1, -1
        if len(A) == 0:
            return [firstO, lastO]
        start, end = 0, len(A) - 1
        while (start + 1 &lt; end):
            mid = start + (end - start) // 2
            if (A[mid] &lt; target):
                start = mid
            else:
                end = mid
        if (A[end] == target):
            firstO = end
        if (A[start] == target):
            firstO = start
        start, end = 0, len(A) - 1
        while (start + 1 &lt; end):
            mid = start + (end - start) // 2
            if (A[mid] &lt;= target):
                start = mid
            else:
                end = mid
        if (A[start] == target):
            lastO = start
        if (A[end] == target):
            lastO = end
        return [firstO, lastO]
</code></pre>
<p>总结：注意检查空输入！</p>
<h3 id="852-Peak-Index-in-a-Mountain-Array"><a href="#852-Peak-Index-in-a-Mountain-Array" class="headerlink" title="852. Peak Index in a Mountain Array"></a><a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/description/" target="_blank" rel="noopener">852. Peak Index in a Mountain Array</a></h3><p><a href="https://www.lintcode.com/problem/maximum-number-in-mountain-sequence/description" target="_blank" rel="noopener">LinC 585. Maximum Number in Mountain Sequence (Medium)</a><br>Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.<br>Example<br>Given nums = [1, 2, 4, 8, 6, 3] return 8<br>Given nums = [10, 9, 8, 7], return 10</p>
<p>思路：切一刀，判断递增就扔左边，递减就扔右边， 不然就找到了中点<br>二刷：</p>
<pre><code class="python">class Solution:
    def peakIndexInMountainArray(self, A):
        &quot;&quot;&quot;
        :type A: List[int]
        :rtype: int
        &quot;&quot;&quot;
        start, end = 0, len(A) - 1
        while start + 1 &lt; end:
            mid = start + (end - start) // 2
            if A[mid - 1] &lt; A[mid] &lt; A[mid + 1]:
                start = mid
            elif A[mid - 1] &gt; A[mid] &gt; A[mid + 1]:
                end = mid
            else:
                return mid
        return start if A[start] &gt; A[end] else end
</code></pre>
<p>总结：二刷写法跟一刷一样，哪怕是简单的题，题要看清楚， mid min 不要拼错</p>
<h3 id="162-Find-Peak-Element-Medium"><a href="#162-Find-Peak-Element-Medium" class="headerlink" title="162. Find Peak Element (Medium)"></a><a href="https://leetcode.com/problems/find-peak-element/description/" target="_blank" rel="noopener">162. Find Peak Element (Medium)</a></h3><p>A peak element is an element that is greater than its neighbors.<br>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.<br>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.<br>You may imagine that nums[-1] = nums[n] = -∞.</p>
<p>Example 1:<br>Input: nums = [1,2,3,1]<br>Output: 2<br>Explanation: 3 is a peak element and your function should return the index number 2.</p>
<p>Example 2:<br>Input: nums = [1,2,1,3,5,6,4]<br>Output: 1 or 5<br>Explanation: Your function can return either index number 1 where the peak element is 2,<br>             or index number 5 where the peak element is 6.<br>Note:<br>Your solution should be in logarithmic complexity.</p>
<pre><code class="python">class Solution:
    def findPeakElement(self, nums: List[int]) -&gt; int:
        l, r = 0, len(nums) - 1
        while l + 1 &lt; r:
            mid = l + (r - l) // 2
            if nums[mid - 1] &lt; nums[mid] &lt; nums[mid + 1]:
                l = mid
            elif nums[mid - 1] &lt; nums[mid] &gt; nums[mid + 1]:
                return mid
            else:
                r = mid
        return r if nums[l] &lt; nums[r] else l
</code></pre>
<p>面经：Quora。关键要知道切中点，如果是///向上，则顶点在右，如果/^\则找到顶点，否则顶点在左</p>
<h3 id="74-Search-a-2D-Matrix-Medium"><a href="#74-Search-a-2D-Matrix-Medium" class="headerlink" title="74. Search a 2D Matrix (Medium)"></a><a href="https://leetcode.com/problems/search-a-2d-matrix/description/" target="_blank" rel="noopener">74. Search a 2D Matrix (Medium)</a></h3><pre><code class="html">Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted from left to right.
The first integer of each row is greater than the last integer of the previous row.
Example 1:

Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 3
Output: true
Example 2:

Input:
matrix = [
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
target = 13
Output: false
</code></pre>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def searchMatrix(self, matrix, target):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        &quot;&quot;&quot;
        if len(matrix) == 0 or len(matrix[0]) == 0:
            return False
        rows, cols = len(matrix) - 1, len(matrix[0]) - 1
        startR, endR = 0, rows
        while startR + 1 &lt; endR:
            midR = startR + (endR - startR) // 2
            if matrix[midR][0] &lt; target:
                startR = midR
            elif matrix[midR][0] &gt; target:
                endR = midR
            else:
                return True
        if startR &lt; endR:
            if matrix[startR][cols] &lt; target:
                startR = endR
        startC, endC = 0, cols
        while startC + 1 &lt; endC:
            midC = startC + (endC - startC) // 2
            if matrix[startR][midC] &lt; target:
                startC = midC
            elif matrix[startR][midC] &gt; target:
                endC = midC
            else:
                return True
        return False if matrix[startR][startC] != target and matrix[startR][endC] != target else True
</code></pre>
<p>高频：</p>
<pre><code class="python">class Solution:
    def searchMatrix(self, matrix, target):
        &quot;&quot;&quot;
        :type matrix: List[List[int]]
        :type target: int
        :rtype: bool
        &quot;&quot;&quot;
        m = len(matrix)
        if m == 0:
            return False
        n = len(matrix[0])
        if n == 0:
            return False
        rs, re = 0, m - 1
        while rs + 1 &lt; re:
            rm = rs + (re - rs) // 2
            if matrix[rm][0] &lt; target:
                rs = rm
            elif matrix[rm][0] &gt; target:
                re = rm - 1
            else:
                return True
        if matrix[rs][n - 1] &lt; target:
            rs = re
        return True if target in matrix[rs] else False
</code></pre>
<p>1总结：注意检查空输入<br>2总结：有两种空情况需要判断 [] 和 [[]]，击败 100% python3 选手。。。<br>高频：记住二分查找的模板：…s + 1 &lt; e…。注意判断…if <strong>matrix[rs][n - 1] &lt;</strong> target:…</p>
<h3 id="153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium" class="headerlink" title="153. Find Minimum in Rotated Sorted Array (Medium)"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">153. Find Minimum in Rotated Sorted Array (Medium)</a></h3><pre><code class="html">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

You may assume no duplicate exists in the array.

Example 1:
Input: [3,4,5,1,2]
Output: 1

Example 2:
Input: [4,5,6,7,0,1,2]
Output: 0
</code></pre>
<p>思路：找 pivot，pivot &gt; 0 时返回 nums[pivot + 1]。找 pivot 时,如果 mid &lt; start, 扔 end， 如果 mid &gt; start 扔 start</p>
<pre><code class="python">class Solution:
    def findMin(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        if (nums[0] &lt; nums[len(nums) - 1]):
            return nums[0]
        start, end = 0, len(nums) - 1
        while (start + 1 &lt; end):
            mid = start + (end - start) // 2
            if (nums[mid] &lt; nums[start]):
                end = mid
            else:
                start = mid
        return nums[end]
</code></pre>
<p>总结：应改为 Easy 难度的题。<br>Follow up: 如果有重复的数? 无法保证在 Log(N) 的时间复杂度内解决 例子:[1,1,1,1,1….,1] 里藏着一个 0.最坏情况下需要把每个位置上的1都看一遍，才能找到最后一个有0 的位置. 考点:能想到这个最坏情况的例子</p>
<h3 id="33-Search-in-Rotated-Sorted-Array-Medium"><a href="#33-Search-in-Rotated-Sorted-Array-Medium" class="headerlink" title="33. Search in Rotated Sorted Array (Medium)"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">33. Search in Rotated Sorted Array (Medium)</a></h3><pre><code class="html">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).

You are given a target value to search. If found in the array return its index, otherwise return -1.

You may assume no duplicate exists in the array.

Your algorithm&#39;s runtime complexity must be in the order of O(log n).

Example 1:

Input: nums = [4,5,6,7,0,1,2], target = 0
Output: 4
Example 2:

Input: nums = [4,5,6,7,0,1,2], target = 3
Output: -1
</code></pre>
<p>思路：第一感觉是得知道 pivot 在哪，有 pivot 一侧不能随便扔，但是更优的方法是查单调的侧是否可以扔</p>
<pre><code class="python">class Solution:
    def search(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: int
        &quot;&quot;&quot;
        if len(nums) == 0:
            return -1
        start, end = 0, len(nums) - 1
        while (start + 1 &lt; end):
            mid = start + (end - start) // 2
            if nums[start] &lt; nums[mid]:
                if nums[start] &lt;= target &lt;= nums[mid]:
                    end = mid
                else:
                    start = mid
            else:
                if nums[mid] &lt;= target &lt;= nums[end]:
                    start = mid
                else:
                    end = mid
        if nums[start] == target:
            return start
        if nums[end] == target:
            return end
        return -1
</code></pre>
<p>总结： 注意 [1, 3, 5] target 为 1 这种边界条件， 判断 target 在单调这边需要加等号</p>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def search(self, nums: &#39;List[int]&#39;, target: &#39;int&#39;) -&gt; &#39;int&#39;:
        if len(nums) == 0:
            return -1
        if len(nums) == 1:
            return 0 if nums[0] == target else -1
        start, end = 0, len(nums) - 1
        while start + 1 &lt; end:
            mid = start + (end - start) // 2
            if nums[mid] == target:
                return mid
                # pivot 在左
            elif nums[mid] &lt; nums[start]:
                if nums[mid] &lt; target &lt;= nums[end] :
                    start = mid + 1
                else:
                    end = mid - 1
                # piviot 在右
            else:
                if nums[mid] &gt; target &gt;= nums[start]:
                    end = mid - 1
                else:
                    start = mid + 1
        if nums[start] == target:
            return start
        if nums[end] == target:
            return end
        return -1
</code></pre>
<p>总结：判断是否保留单调一边不能只看 nums[mid], 扔一侧的时候可以多扔一个 mid + 1 或 mid - 1<br>高频：…while <strong>l + 1</strong> &lt; r…if nums[mid] <strong>&lt;</strong> nums[l]: if <strong>nums[mid] &lt; target &lt;= nums[r]</strong>: …</p>
<h3 id="81-Search-in-Rotated-Sorted-Array-II-Medium"><a href="#81-Search-in-Rotated-Sorted-Array-II-Medium" class="headerlink" title="81. Search in Rotated Sorted Array II (Medium)"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">81. Search in Rotated Sorted Array II (Medium)</a></h3><pre><code class="html">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).

You are given a target value to search. If found in the array return true, otherwise return false.

Example 1:

Input: nums = [2,5,6,0,0,1,2], target = 0
Output: true
Example 2:

Input: nums = [2,5,6,0,0,1,2], target = 3
Output: false
Follow up:

This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.
Would this affect the run-time complexity? How and why?
</code></pre>
<pre><code class="python">class Solution:
    def search(self, nums: List[int], target: int) -&gt; bool:
        if len(nums) == 0:
            return False
        l, r = 0, len(nums) - 1
        while l + 1 &lt; r:
            mid = l + (r - l) // 2
            if nums[mid] == target:
                return True
            if nums[l] &lt; nums[mid]:
                if nums[l] &lt;= target &lt; nums[mid]:
                    r = mid - 1
                else:
                    l = mid + 1
            elif nums[l] &gt; nums[mid]:
                if nums[mid] &lt; target &lt;= nums[r]:
                    l = mid + 1
                else:
                    r = mid - 1
            else:
                l += 1
        if nums[l] == target or nums[r] == target:
            return True
        return False
</code></pre>
<p>高频：注意r = len(nums) - 1，判断nums[mid] == nums[l] 的情况下l += 1</p>
<h3 id="69-Sqrt-x-Easy"><a href="#69-Sqrt-x-Easy" class="headerlink" title="69. Sqrt(x) (Easy)"></a><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">69. Sqrt(x) (Easy)</a></h3><pre><code class="html">Implement int sqrt(int x).

Compute and return the square root of x, where x is guaranteed to be a non-negative integer.

Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.

Example 1:

Input: 4
Output: 2
Example 2:

Input: 8
Output: 2
Explanation: The square root of 8 is 2.82842..., and since
             the decimal part is truncated, 2 is returned.
</code></pre>
<pre><code class="python">class Solution:
    def mySqrt(self, x: int) -&gt; int:
        l, r = 0, x
        while l + 1 &lt; r:
            mid = l + (r - l) // 2
            if mid * mid &lt;= x &lt; (mid + 1) * (mid + 1):
                return mid
            elif mid * mid &lt; x:
                l = mid + 1
            else:
                r = mid - 1
        return l if l * l &lt;= x &lt; (l + 1) * (l + 1) else r
</code></pre>
<p>高频：统一模板…l + 1 &lt; r…if mid <em> mid <strong>&lt;=</strong> x <strong>&lt;</strong>(mid + 1) </em> (mid + 1)…return l if l * l &lt;= x &lt;…</p>
<h3 id="35-Search-Insert-Position-Easy"><a href="#35-Search-Insert-Position-Easy" class="headerlink" title="35. Search Insert Position (Easy)"></a><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="noopener">35. Search Insert Position (Easy)</a></h3><pre><code class="html">Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Example 1:

Input: [1,3,5,6], 5
Output: 2
Example 2:

Input: [1,3,5,6], 2
Output: 1
Example 3:

Input: [1,3,5,6], 7
Output: 4
Example 4:

Input: [1,3,5,6], 0
Output: 0
</code></pre>
<pre><code class="python">class Solution:
    def searchInsert(self, nums: List[int], target: int) -&gt; int:
        l, r = 0, len(nums) - 1
        while l + 1 &lt; r:
            mid = l + (r - l) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] &lt; target:
                l = mid
            else:
                r = mid
        if target &lt;= nums[l]:
            return l
        if target &lt;= nums[r]:
            return r
        return len(nums)
</code></pre>
<p>高频：…l = mid…if target &lt;= nums[l]: return l…return len(nums)</p>
<h3 id="658-Find-K-Closest-Elements-Medium"><a href="#658-Find-K-Closest-Elements-Medium" class="headerlink" title="658. Find K Closest Elements (Medium)"></a><a href="https://leetcode.com/problems/find-k-closest-elements/description/" target="_blank" rel="noopener">658. Find K Closest Elements (Medium)</a></h3><p><a href="https://www.lintcode.com/problem/find-k-closest-elements/description" target="_blank" rel="noopener">LinC 460. Find K Closest Elements (Medium)</a></p>
<pre><code class="html">Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.

Example 1:
Input: [1,2,3,4,5], k=4, x=3
Output: [1,2,3,4]
Example 2:
Input: [1,2,3,4,5], k=4, x=-1
Output: [1,2,3,4]
Note:
The value k is positive and will always be smaller than the length of the sorted array.
Length of the given array is positive and will not exceed 104
Absolute value of elements in the array and x will not exceed 104
UPDATE (2017/9/19):
The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.
</code></pre>
<p>三刷</p>
<pre><code class="python">class Solution:
    def findClosestElements(self, arr: List[int], k: int, x: int) -&gt; List[int]:
        n = len(arr)
        l, r = 0, n - 1
        while l + 1 &lt; r:
            mid = l + (r - l) // 2
            if arr[mid] &lt; x:
                l = mid
            else:
                r = mid
        cnt = 0
        res = []
        while l &gt;= 0 and r &lt;= n - 1 and cnt &lt; k:
            if abs(arr[l] - x) &lt;= abs(arr[r] - x):
                res.append(arr[l])
                l -= 1
            else:
                res.append(arr[r])
                r += 1
            cnt += 1
        while l &gt;= 0 and cnt &lt; k:
            res.append(arr[l])
            l -= 1
            cnt += 1
        while r &lt;= n - 1 and cnt &lt; k:
            res.append(arr[r])
            r += 1
            cnt += 1
        return sorted(res)
</code></pre>
<p>三刷：整理一，二刷代码。算法：1.二分法查找 target，将 l, r 指针放到正确的位置；2.左右按 diff 走 k；3.往左走到底，往右走到底…if nums[mid] <strong>&lt;</strong> x: l = <strong>mid</strong> else: r = <strong>mid</strong>…<br>网上还有一种很妖的O(logN)算法，破坏了模板，核心原理是l, r = 0, len(arr) - k…if abs(arr[mid] - x) &gt; abs(arr[mid + k] - x): l = mid + 1 else: r = mid; return arr[l: l + k]</p>
<h1 id="Two-pointers"><a href="#Two-pointers" class="headerlink" title="Two pointers"></a>Two pointers</h1><h3 id="LinC-373-Partition-Array-by-Odd-and-Even-Easy"><a href="#LinC-373-Partition-Array-by-Odd-and-Even-Easy" class="headerlink" title="LinC 373. Partition Array by Odd and Even (Easy)"></a><a href="http://www.lintcode.com/problem/partition-array-by-odd-and-even/" target="_blank" rel="noopener">LinC 373. Partition Array by Odd and Even (Easy)</a></h3><pre><code class="html">Partition an integers array into odd number first and even number second.

Example
Given [1, 2, 3, 4], return [1, 3, 2, 4]
</code></pre>
<p>思路：双指针一头一尾，碰到不符合的就换。</p>
<pre><code class="python">class Solution:
    &quot;&quot;&quot;
    @param: nums: an array of integers
    @return: nothing
    &quot;&quot;&quot;
    def partitionArray(self, nums):
        # write your code here
        if len(nums) &lt; 2:
            return
        l, r = 0, len(nums) - 1
        while l &lt; r:
            while l &lt; r and nums[l] % 2 != 0:
                l += 1
            while l &lt; r and nums[r] % 2 == 0:
                r -= 1
            if nums[l] % 2 == 0 or nums[r] % 2 != 0:
                nums[l], nums[r] = nums[r], nums[l]
        if nums[l] % 2 == 0 or nums[r] % 2 != 0:
            nums[l], nums[r] = nums[r], nums[l]
</code></pre>
<p>总结：送两个测试数据进去就能写对。 最后两个 if 可以简化。</p>
<h3 id="26-Remove-Duplicates-from-Sorted-Array-Easy"><a href="#26-Remove-Duplicates-from-Sorted-Array-Easy" class="headerlink" title="26. Remove Duplicates from Sorted Array (Easy)"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">26. Remove Duplicates from Sorted Array (Easy)</a></h3><pre><code class="html">Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,2],

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.

It doesn&#39;t matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,2,2,3,3,4],

Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.

It doesn&#39;t matter what values are set beyond the returned length.
Clarification:

Confused why the returned value is an integer but your answer is an array?

Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.

Internally you can think of this:

// nums is passed in by reference. (i.e., without making a copy)
int len = removeDuplicates(nums);

// any modification to nums in your function would be known by the caller.
// using the length returned by your function, it prints the first len elements.
for (int i = 0; i &lt; len; i++) {
    print(nums[i]);
}
</code></pre>
<p>思路：简单题， 慢指针只有在快指针碰到不同的值才走。</p>
<pre><code class="python">class Solution:
    def removeDuplicates(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        if len(nums) == 0:
            return 0
        slow, fast = 0, 1
        while fast &lt; len(nums):
            if nums[fast] == nums[slow]:
                fast += 1
            else:
                slow += 1
                nums[slow] = nums[fast]
                fast += 1
        return slow + 1
</code></pre>
<p>总结：纯热身，秒解</p>
<p>二刷</p>
<pre><code class="python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if len(nums) &lt;= 1:
            return len(nums)
        slow, fast = 0, 1
        while fast &lt; len(nums):
            if nums[slow] == nums[fast]:
                fast += 1
            else:
                slow += 1
                nums[slow], nums[fast] = nums[fast], nums[slow]
                fast += 1
        return slow + 1
</code></pre>
<p>总结：虽然是容易热身题，却要思考两个问题，第一，数组需要 in place sort, 需要利用已经排好序这个条件来在 slow 往前一个以后交换 slow 和 fast 的数； 第二，返回 slow + 1 可以省一个 ans 变量<br>高频: …else: slow += 1; nums[slow], nums[fast] = nums[fast], nums[slow]; fast += 1…</p>
<h3 id="80-Remove-Duplicates-from-Sorted-Array-II-Medium"><a href="#80-Remove-Duplicates-from-Sorted-Array-II-Medium" class="headerlink" title="80. Remove Duplicates from Sorted Array II (Medium)"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/" target="_blank" rel="noopener">80. Remove Duplicates from Sorted Array II (Medium)</a></h3><pre><code class="html">Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

Example 1:

Given nums = [1,1,1,2,2,3],

Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.

It doesn&#39;t matter what you leave beyond the returned length.
Example 2:

Given nums = [0,0,1,1,1,1,2,3,3],

Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.

It doesn&#39;t matter what values are set beyond the returned length.
</code></pre>
<pre><code class="python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        w = 0
        for i, n in enumerate(nums):
            if i &lt; 2 or n != nums[w - 2]:
                nums[w] = n
                w += 1
        return w
</code></pre>
<p>高频：反正两周前的代码也看不懂了，抄个简单一点的…if i &lt; 2 or n != nums[w <strong>- 2</strong>]</p>
<h3 id="28-Implement-strStr-Easy"><a href="#28-Implement-strStr-Easy" class="headerlink" title="28. Implement strStr() (Easy)"></a><a href="https://leetcode.com/problems/implement-strstr/description/" target="_blank" rel="noopener">28. Implement strStr() (Easy)</a></h3><pre><code class="html">Implement strStr().

Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

Example 1:

Input: haystack = &quot;hello&quot;, needle = &quot;ll&quot;
Output: 2
Example 2:

Input: haystack = &quot;aaaaa&quot;, needle = &quot;bba&quot;
Output: -1
Clarification:

What should we return when needle is an empty string? This is a great question to ask during an interview.

For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C&#39;s strstr() and Java&#39;s indexOf().
</code></pre>
<p>思路：快慢指针</p>
<pre><code class="python">class Solution(object):
    def strStr(self, haystack, needle):
        &quot;&quot;&quot;
        :type haystack: str
        :type needle: str
        :rtype: int
        &quot;&quot;&quot;
        if len(needle) == 0:
            return 0
        if len(haystack) == 0:
            return -1
        for i in range(len(haystack)):
            if haystack[i] == needle[0]:
                if i + len(needle) - 1 &lt; len(haystack):
                    if needle == haystack[i: i + len(needle)]:
                        return i
                else:
                    return -1
        return -1
</code></pre>
<p>总结: 思路是双指针没问题，实际用 python 的时候可以用 python 的性质直接取子串</p>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def strStr(self, haystack: str, needle: str) -&gt; int:
        if len(needle) == 0:
            return 0
        if len(haystack) == 0:
            return -1
        end = len(haystack) - len(needle) + 1
        if end &lt; 0:
            return -1
        for i in range(0, end):
            if haystack[i:i + len(needle)] == needle:
                return i
        return -1
</code></pre>
<p>总结：注意空串的时候要返回 int 而不是 bool, needle 为空时，直接返回 0, 优化 end = len(haystack) - len(needle) + 1; if end &lt; 0: return -1; for i in range(0, end)<br>高频：考点 end = lh - ln + 1; … if haystack[i:i + ln] == needle: return i。代码能优化一点点，但是大同小异。</p>
<h3 id="283-Move-Zeroes-Easy"><a href="#283-Move-Zeroes-Easy" class="headerlink" title="283. Move Zeroes (Easy)"></a><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">283. Move Zeroes (Easy)</a></h3><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>Example:<br>Input: [0,1,0,3,12]<br>Output: [1,3,12,0,0]</p>
<p>Note:<br>You must do this in-place without making a copy of the array.<br>Minimize the total number of operations.</p>
<pre><code class="python">class Solution:
    def moveZeroes(self, nums: List[int]) -&gt; None:
        n = len(nums)
        l, r = 0, 0
        while r &lt; n:
            while nums[r] == 0 and r &lt; n - 1:
                r += 1
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r += 1
</code></pre>
<p>总结：三刷出了更简洁的写法，跑测试用例的时候仍然要考虑 0 在左中右三种情况<br>高频：两个月没刷这题，导致思路僵化在一刷的l, r均从0，0开始需要考虑很多种情况的算法。三刷或者l, r从0，1开始代码就简洁很多（本质是一样的）。删掉一刷代码的复杂情况判断。 非要l，r从0，0开始，就不考虑各种情况，l，r永远前进<br>五刷：写出了也能过的代码，但是不如高频代码简洁</p>
<h3 id="125-Valid-Palindrome-Easy"><a href="#125-Valid-Palindrome-Easy" class="headerlink" title="125. Valid Palindrome (Easy)"></a><a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">125. Valid Palindrome (Easy)</a></h3><pre><code class="html">Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

Note: For the purpose of this problem, we define empty string as valid palindrome.

Example 1:

Input: &quot;A man, a plan, a canal: Panama&quot;
Output: true
Example 2:

Input: &quot;race a car&quot;
Output: false
</code></pre>
<p>思路：头尾双指针， 碰头了返回 True，相同继续走，不同返回 False</p>
<pre><code class="python">class Solution(object):
    def isPalindrome(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        if len(s) == 0 or len(s) == 1:
            return True
        head, tail = 0, len(s) - 1
        while head &lt; tail:
            while not s[head].isalnum() and head &lt; tail:
                head += 1
            while not s[tail].isalnum() and head &lt; tail:
                tail -= 1
            if s[head].lower() != s[tail].lower():
                return False
            else:
                head += 1
                tail -= 1
        return True
</code></pre>
<p>总结：思路简单， 但是要想到的 case 很多。考虑带标点符号，连续两个位置都是标点符号，整个字符串都是标点符合这三个情况才能写对</p>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def isPalindrome(self, s: str) -&gt; bool:
        if len(s) &lt;= 1:
            return True
        head, tail = 0, len(s) - 1
        while head &lt; tail:
            while not s[head].isalnum() and head &lt; tail:
                head += 1
            while not s[tail].isalnum() and head &lt; tail:
                tail -= 1
            if s[head].lower() == s[tail].lower():
                head += 1
                tail -= 1
            else:
                return False
        return True
</code></pre>
<p>总结：关键是知道 .isalnum() 这个 function<br>高频</p>
<h3 id="680-Valid-Palindrome-II-Easy"><a href="#680-Valid-Palindrome-II-Easy" class="headerlink" title="680. Valid Palindrome II (Easy)"></a><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">680. Valid Palindrome II (Easy)</a></h3><pre><code class="html">Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.

Example 1:
Input: &quot;aba&quot;
Output: True
Example 2:
Input: &quot;abca&quot;
Output: True
Explanation: You could delete the character &#39;c&#39;.
Note:
The string will only contain lowercase characters a-z. The maximum length of the string is 50000.
</code></pre>
<p>思路：目前网上看到大部分答案都以贪心算法为主，等看贪心了再刷这题。再看一眼感觉就是统计有没有 &gt; 2 单数的题，撸之</p>
<pre><code class="python">class Solution(object):
    def validPalindrome(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: bool
        &quot;&quot;&quot;
        if len(s) &lt;= 2:
            return True
        l, r = 0, len(s) - 1
        while l &lt; r:
            if s[l] != s[r]:
                break
            l += 1
            r -= 1
        if l &gt;= r:
            return True
        # 要么删左边，要么删右边
        return self.isPalindrome(s[:l] + s[l + 1:]) or self.isPalindrome(s[:r] + s[r + 1:])
    def isPalindrome(self, s):
        return s == s[::-1]
</code></pre>
<p>总结：没那么简单，还要考虑这些情况 1.如果有 2 个 single 均不在 mid 位置；2. 去掉 single 点后的 string 仍然不是 palindrome; 3. 1 个 single，多个位置可以删除； 然后就抓狂了。 看了答案， 真他妈的妖。双指针算法。从两头走到中间，发现第一对不一样的字符之后，要么删左边的，要么删右边的。</p>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def validPalindrome(self, s: str) -&gt; bool:
        if len(s) &lt;= 2:
            return True
        l, r = 0, len(s) - 1
        while l &lt; r:
            if s[l] != s[r]:
                break
            l += 1
            r -= 1
        if not l &lt; r:
            return True
        return self.isPalindrome(s[:l] + s[l + 1:]) or self.isPalindrome(s[:r] + s[r + 1:])
    def isPalindrome(self, s):
        return s == s[::-1]
</code></pre>
<p>总结：如一刷所说，是一道比较妖的题，背熟吧</p>
<h3 id="1-Two-Sum-Easy"><a href="#1-Two-Sum-Easy" class="headerlink" title="1. Two Sum (Easy)"></a><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">1. Two Sum (Easy)</a></h3><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.<br>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:<br>Given nums = [2, 7, 11, 15], target = 9,<br>Because nums[0] + nums[1] = 2 + 7 = 9,<br>return [0, 1].</p>
<pre><code class="python">class Solution:
    def twoSum(self, nums, target):
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]
</code></pre>
<pre><code class="python">class Solution(object):
    def twoSum(self, nums, target):
        remain = {}
        for i, n in enumerate(nums):
            if n in remain:
                return [remain[n], i]
            remain[target - n] = i
</code></pre>
<p>一刷，高频，面经：维萨。简化代码， 双指针， hashmap</p>
<h3 id="167-Two-Sum-II-Input-array-is-sorted-Easy"><a href="#167-Two-Sum-II-Input-array-is-sorted-Easy" class="headerlink" title="167. Two Sum II - Input array is sorted (Easy)"></a><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">167. Two Sum II - Input array is sorted (Easy)</a></h3><pre><code class="html">Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.

Note:

Your returned answers (both index1 and index2) are not zero-based.
You may assume that each input would have exactly one solution and you may not use the same element twice.
Example:

Input: numbers = [2,7,11,15], target = 9
Output: [1,2]
Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
</code></pre>
<p>思路：增加了 sorted 这个条件， 第一感觉是可以折半查找了。固定 index1，index2 用折半查找获得</p>
<pre><code class="python">class Solution:
    def twoSum(self, numbers, target):
        &quot;&quot;&quot;
        :type numbers: List[int]
        :type target: int
        :rtype: List[int]
        &quot;&quot;&quot;
        for index1 in range(len(numbers)):
            start, end = index1 + 1, len(numbers) - 1
            while start + 1 &lt; end:
                mid = start + (end - start) // 2
                if numbers[index1] + numbers[mid] == target:
                    return [index1 + 1, mid + 1]
                elif numbers[index1] + numbers[mid] &lt; target:
                    start = mid + 1
                else:
                    end = mid - 1
            if numbers[index1] + numbers[start] == target:
                return [index1 + 1, start + 1]
            elif numbers[index1] + numbers[end] == target:
                return [index1 + 1, end + 1]
</code></pre>
<p>总结：要细心。1.题中 answers are not zero-based 2.要测两个情况 [2, 7, 19], 9 和 [5, 25, 75] 可以测出代码的问题</p>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def twoSum(self, numbers: List[int], target: int) -&gt; List[int]:
        l, r = 0, len(numbers) - 1
        while l &lt; r:
            tsum = numbers[l] + numbers[r]
            if tsum == target:
                return [l + 1, r + 1]
            if tsum &lt; target:
                l += 1
            else:
                r -= 1
</code></pre>
<p>总结：二分法跑分不如直接双指针，可能是测试数据导致。双指针代码也简单很多</p>
<h3 id="LinC-607-Two-Sum-III-Data-structure-design-Easy"><a href="#LinC-607-Two-Sum-III-Data-structure-design-Easy" class="headerlink" title="LinC 607. Two Sum III - Data structure design (Easy)"></a><a href="https://www.lintcode.com/problem/two-sum-iii-data-structure-design/description" target="_blank" rel="noopener">LinC 607. Two Sum III - Data structure design (Easy)</a></h3><pre><code class="html">Design and implement a TwoSum class. It should support the following operations: add and find.

add - Add the number to an internal data structure.
find - Find if there exists any pair of numbers which sum is equal to the value.

Example
add(1); add(3); add(5);
find(4) // return true
find(7) // return false
</code></pre>
<p>思路：add 的时候把 sum 都存 dict 里面， 查的时候直接返回 dict 里面有没有 sum. 会超时。</p>
<pre><code class="python">class TwoSum:
    keys = {}
    &quot;&quot;&quot;
    @param: number: An integer
    @return: nothing
    &quot;&quot;&quot;
    def add(self, number):
        # write your code here
        if number not in self.keys:
            self.keys[number] = 1
        else:
            self.keys[number] = 2
    &quot;&quot;&quot;
    @param: value: An integer
    @return: Find if there exists any pair of numbers which sum is equal to the value.
    &quot;&quot;&quot;
    def find(self, value):
        # write your code here
        for key in self.keys:
            if value - key in self.keys:
                if value - key == key:
                    if self.keys[key] == 2:
                        return True
                else:
                    return True
        return False
</code></pre>
<p>总结：虽然是一道容易题， 第一反应的思路会超时。 需要在 find 的时候判断能凑出答案的另一个 key 是不是已经在 keys 里了。而不是先存好 sum。 还要判断两个数相同的时候有没有存过两个数。</p>
<h3 id="15-3Sum-Medium"><a href="#15-3Sum-Medium" class="headerlink" title="15. 3Sum (Medium)"></a><a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">15. 3Sum (Medium)</a></h3><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.<br>Note:<br>The solution set must not contain duplicate triplets.</p>
<pre><code>Example:
Given array nums = [-1, 0, 1, 2, -1, -4],
A solution set is:
[
  [-1, 0, 1],
  [-1, -1, 2]
]
</code></pre><p>暴力，会超时：</p>
<pre><code class="python">class Solution:
    def threeSum(self, nums):
        remain = {}
        ans = set()
        nums.sort()
        for i in range(len(nums) - 2):
            if i and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, len(nums)):
                for k in range(j + 1, len(nums)):
                    if len(set([i, j, k])) == len([i, j, k]):
                        twoSum = nums[i] + nums[j]
                        remain[0 - twoSum] = (i, j)
                        if nums[k] in remain:
                            a, b = remain[nums[k]]
                            if len(set([a, b, k])) == len([a, b, k]):
                                ans.add(tuple(sorted([nums[a], nums[b], nums[k]])))
        return list(ans)
</code></pre>
<p>四刷：</p>
<pre><code class="python">class Solution:
    def threeSum(self, nums):
        nums.sort()
        n = len(nums)
        ans = []
        for i in range(n - 2):
            if i and nums[i] == nums[i - 1] :
                continue
            l, r = i + 1, n - 1
            while l &lt; r:
                tSum = nums[i] + nums[l] + nums[r]
                if tSum &lt; 0:
                    l += 1
                elif tSum &gt; 0:
                    r -= 1
                else:
                    ans.append([nums[i], nums[l], nums[r]])
                    while l &lt; r and nums[l] == nums[l + 1]:
                        l += 1
                    while l &lt; r and nums[r] == nums[r - 1]:
                        r -= 1
                    l += 1
                    r -= 1
        return ans
</code></pre>
<p>面经：维萨。</p>
<h3 id="LinC-382-Triangle-Count-Medium"><a href="#LinC-382-Triangle-Count-Medium" class="headerlink" title="LinC 382. Triangle Count (Medium)"></a><a href="https://www.lintcode.com/problem/triangle-count/description" target="_blank" rel="noopener">LinC 382. Triangle Count (Medium)</a></h3><pre><code class="html">Given an array of integers, how many three numbers can be found in the array, so that we can build an triangle whose three edges length is the three numbers that we find?

Example
Given array S = [3,4,6,7], return 3. They are:

[3,4,6]
[3,6,7]
[4,6,7]
Given array S = [4,4,4,4], return 4. They are:

[4(1),4(2),4(3)]
[4(1),4(2),4(4)]
[4(1),4(3),4(4)]
[4(2),4(3),4(4)]
</code></pre>
<p>思路： 判断能不能做三角形以后全排列</p>
<pre><code class="python">class Solution:
    &quot;&quot;&quot;
    @param S: A list of integers
    @return: An integer
    &quot;&quot;&quot;
    def triangleCount(self, S):
        # write your code here
        S.sort(reverse=True)
        sum = 0
        for index1, longest in enumerate(S):
            head, tail = index1 + 1, index1 + 2
            while tail &lt; len(S) and S[head] + S[tail] &gt; longest:
                tail += 1
            tail -= 1
            while head &lt; tail:
                sum += tail - head
                head += 1
                while head &lt; tail and S[head] + S[tail] &lt;= longest:
                    tail -= 1
        return sum
</code></pre>
<p>总结：看清题目，问的是有多少个这样的三角形， 返回数就行。 全排列效率比较低。 更优解是每次定下最长边， 寻找符合条件的另外两个边的数量。 双指针的解法是将 tail 推到最小不能组成三角形的位置， 退一步， 然后从 tail 到 head 的位置的都可以组， 因为他们相加只会比最长边更长。 然后将 head 进一步（缩短），tail 边加长到大于最长边的位置，新 tail 到 head 的位置又都可以组。</p>
<h3 id="16-3Sum-Closest-Medium"><a href="#16-3Sum-Closest-Medium" class="headerlink" title="16. 3Sum Closest (Medium)"></a><a href="https://leetcode.com/problems/3sum-closest/description/" target="_blank" rel="noopener">16. 3Sum Closest (Medium)</a></h3><pre><code class="html">Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.

Example:

Given array nums = [-1, 2, 1, -4], and target = 1.

The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
</code></pre>
<pre><code class="python">class Solution:
    def threeSumClosest(self, nums: List[int], target: int) -&gt; int:
        ans = None
        nums.sort()
        for i in range(len(nums) - 2):
            l, r = i + 1, len(nums) - 1
            while l &lt; r:
                t = nums[i] + nums[l] + nums[r]
                if t == target:
                    return t
                elif t &lt; target:
                    l += 1
                else:
                    r -= 1
                if ans == None or abs(t - target) &lt; abs(ans - target):
                    ans = t
        return ans
</code></pre>
<p>高频：将1，2刷的代码思路总结都删了，都差不多。注意这里没有mid，不是二分查找。</p>
<h3 id="LinC-31-Partition-Array-Medium"><a href="#LinC-31-Partition-Array-Medium" class="headerlink" title="LinC 31. Partition Array (Medium)"></a><a href="https://www.lintcode.com/problem/partition-array/description" target="_blank" rel="noopener">LinC 31. Partition Array (Medium)</a></h3><p>Description<br>Given an array nums of integers and an int k, partition the array (i.e move the elements in “nums”) such that:<br>All elements &lt; k are moved to the left<br>All elements &gt;= k are moved to the right<br>Return the partitioning index, i.e the first index i nums[i] &gt;= k.<br>You should do really partition in array nums instead of just counting the numbers of integers smaller than k.<br>If all elements in nums are smaller than k, then return nums.length</p>
<p>Example<br>If nums = [3,2,2,1] and k=2, a valid answer is 1.</p>
<p>Challenge<br>Can you partition the array in-place and in O(n)?</p>
<pre><code class="python">class Solution:
    def partitionArray(self, nums, k):
        if len(nums) == 0:
            return 0
        l, r = 0, len(nums) - 1
        while l &lt;= r:
            while l &lt; len(nums) and nums[l] &lt; k:
                l += 1
            while r &gt;= 0 and nums[r] &gt;= k:
                r -= 1
            if l &gt; r:
                break
            nums[l], nums[r] = nums[r], nums[l]
        return l
</code></pre>
<p>总结：注意：1。while 的条件是 l &lt;= r 2.l &gt; r 的时候需要 break</p>
<h3 id="215-Kth-Largest-Element-in-an-Array-Medium"><a href="#215-Kth-Largest-Element-in-an-Array-Medium" class="headerlink" title="215. Kth Largest Element in an Array (Medium)"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">215. Kth Largest Element in an Array (Medium)</a></h3><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.<br>Example 1:<br>Input: [3,2,1,5,6,4] and k = 2<br>Output: 5</p>
<p>Example 2:<br>Input: [3,2,3,1,2,4,5,5,6] and k = 4<br>Output: 4<br>Note:<br>You may assume k is always valid, 1 ≤ k ≤ array’s length.</p>
<pre><code class="python">class Solution(object):
    def findKthLargest(self, nums, k):
        return self.quickSelect(nums, 0, len(nums) - 1, k - 1)
    def quickSelect(self, nums, l, r, k):
        hi = l
        from random import randint
        rand = randint(l, r)
        nums[r], nums[rand] = nums[rand], nums[r]
        for i in range(l, r):
            if nums[i] &gt; nums[r]:
                nums[hi], nums[i] = nums[i], nums[hi]
                hi += 1
        nums[hi], nums[r] = nums[r], nums[hi]
        if hi &gt; k:
            return self.quickSelect(nums, l, hi - 1, k)
        elif hi &lt; k:
            return self.quickSelect(nums, hi + 1, r, k)
        else:
            return nums[hi]
</code></pre>
<p>思路：quickselect算法，基于quicksort<br>总结：递归调用的时候函数名前要加 return 否则不会返回任何值。由于完全抛弃另一侧，时间复杂度平均由 quick sort 的 O(nlogn) 降为 O(n) 因为输入变小了， quicksort 的输入一直是 n, 最差情况 O(n^2)<br>二刷：删掉一刷代码。递归调用的时候记得函数名前要加 return 否则不会返回任何值。…hi = l…for i, v in enumerate(nums[l:r], l):…<br>面经：维萨</p>
<h3 id="75-Sort-Colors-Medium"><a href="#75-Sort-Colors-Medium" class="headerlink" title="75. Sort Colors (Medium)"></a><a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="noopener">75. Sort Colors (Medium)</a></h3><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.<br>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p>
<p>Note: You are not suppose to use the library’s sort function for this problem.</p>
<p>Example:<br>Input: [2,0,2,1,1,0]<br>Output: [0,0,1,1,2,2]<br>Follow up:</p>
<p>A rather straight forward solution is a two-pass algorithm using counting sort.<br>First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.<br>Could you come up with a one-pass algorithm using only constant space?</p>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def sortColors(self, nums: List[int]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        if len(nums) &lt;= 1:
            return
        l, r, i = 0, len(nums) - 1, 0
        while i &lt;= r:
            if nums[i] == 0 and i &gt; l:
                nums[l], nums[i] = nums[i], nums[l]
                l += 1
            elif nums[i] == 2 and i &lt; r:
                nums[i], nums[r] = nums[r], nums[i]
                r -= 1
            else:
                i += 1
</code></pre>
<p>总结：in place 不数元素的话得用 l, r 和 i, 要过的话需要熟记交换的第二条件分别为 i &gt; l 和 i &lt; r, 其他情况 i 均前进<br>高频：去掉了一刷繁琐的方法。counting sort只需要count 0和1。1 pass：…while i &lt;= r:…and i &gt; l:…and i &lt; r:…<br>面经：Celo。3个数要保持两个边界l和r，和一个worker i，交换条件要加…i &gt; l…和…i &lt; r，否则会过度交换导致结果有bug</p>
<h3 id="18-4Sum-Medium"><a href="#18-4Sum-Medium" class="headerlink" title="18. 4Sum (Medium)"></a><a href="https://leetcode.com/problems/4sum/description/" target="_blank" rel="noopener">18. 4Sum (Medium)</a></h3><pre><code class="html">Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.

Note:

The solution set must not contain duplicate quadruplets.

Example:

Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

A solution set is:
[
  [-1,  0, 0, 1],
  [-2, -1, 1, 2],
  [-2,  0, 0, 2]
]
</code></pre>
<p>思路：看了下三年前的答案，不是特别直观。看了九章的答案，貌似好理解一点：去重，枚举一个数，然后用 3Sum 的做法，O(N^3)</p>
<pre><code class="python">class Solution:
    def fourSum(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        nums.sort()
        ans = []
        for i in range(0, len(nums) - 3):
            if i and nums[i] == nums[i - 1]:
                continue
            for j in range(i + 1, len(nums) - 2):
                if j != i + 1 and nums[j] == nums[j - 1]:
                    continue
                l, r = j + 1, len(nums) - 1
                while l &lt; r:
                    sum = nums[i] + nums[j] + nums[l] + nums[r]
                    if sum == target:
                        ans.append([nums[i], nums[j], nums[l], nums[r]])
                        l += 1
                        r -= 1
                        while l &lt; r and nums[l] == nums[l - 1]:
                            l += 1
                        while l &lt; r and nums[r] == nums[r + 1]:
                            r -= 1
                    elif sum &lt; target:
                        l += 1
                    else:
                        r -= 1
        return ans
</code></pre>
<p>总结：有一个自己肯定想不出的条件就是第二层循环怎么跳过：<strong>if j != i + 1 and nums[j] == nums[j - 1]: continue</strong>; 非常勉强能过 AC. 看了网上和三年前的，都是用 dict 先存 2sum，然后再 loop 两遍，用 if pair[0] &gt; j 来去重（第三个元素的 index 要大于前面两个）。</p>
<pre><code class="python">class Solution:
    def fourSum(self, nums: List[int], target: int) -&gt; List[List[int]]:
        ans = []
        def nsum(l, r, N, target, path):
            if r - l + 1 &lt; N or N &lt; 2 or N &gt; len(nums) or N * nums[l] &gt; target or N * nums[r] &lt; target:
                return
            if N == 2:
                while l &lt; r:
                    t = nums[l] + nums[r]
                    if t == target:
                        ans.append(path + [nums[l], nums[r]])
                        while l &lt; r and nums[l] == nums[l + 1]:
                            l += 1
                        while l &lt; r and nums[r] == nums[r - 1]:
                            r -= 1
                        l += 1
                        r -= 1
                    elif t &lt; target:
                        l += 1
                    else:
                        r -= 1
            else:
                for i in range(l, r + 1):
                    if i == l or (i &gt; l and nums[i] != nums[i - 1]):
                        nsum(i + 1, r, N - 1, target - nums[i], path + [nums[i]])
        nums.sort()
        nsum(0, len(nums) - 1, 4, target, [])
        return ans
</code></pre>
<p>二刷：看 leetcode ac 的流行答案， 返回递归 nsum， 递归内终结条件为解决 2sum，，注意两处去重，1.找到 target 以后，在 l &lt; r 条件下跳过所有后面与 l 相同的；2.进入 nsum 前，if i == 0 or (i &gt; 0 and nums[i - 1] != nums[i])<br>总结：很多坑，N == 2 时要注意 while l &lt; r 做二分法；N &gt; 2 时 for i in range(l, r + 1); nsum(i + 1, …); 如是高频题需要练熟<br>高频：…def nsum(l, r, N, target, path): if r - l + 1 &lt; N or N &lt; 2 or…if N == 2: while l &lt; r:…  while l &lt; r and nums[l] == nums[l + 1]:…while…l += 1; r -= 1…  for i in range(l, r + 1): if (i == l) or…: nsum(i + 1, r…)…</p>
<h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27. Remove Element"></a><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="noopener">27. Remove Element</a></h3><pre><code class="html">Given an array nums and a value val, remove all instances of that value in-place and return the new length.

Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

The order of elements can be changed. It doesn&#39;t matter what you leave beyond the new length.

Example 1:

Given nums = [3,2,2,3], val = 3,

Your function should return length = 2, with the first two elements of nums being 2.

It doesn&#39;t matter what you leave beyond the returned length.
Example 2:

Given nums = [0,1,2,2,3,0,4,2], val = 2,

Your function should return length = 5, with the first five elements of nums containing 0, 1, 3, 0, and 4.

Note that the order of those five elements can be arbitrary.

It doesn&#39;t matter what values are set beyond the returned length.
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        ans = len(nums)
        i = 0
        j = ans - 1
        while i &lt;= j:
            while i &lt;= j and nums[i] != val:
                i += 1
            while i &lt;= j and nums[j] == val:
                j -= 1
                ans -= 1
            if i &lt; j:
                nums[i], nums[j] = nums[j], nums[i]
        return ans
</code></pre>
<p>总结：背while i <strong>&lt;=</strong> j: while i &lt;= j and … while i &lt;= j and …if i &lt; j: …</p>
<h3 id="11-Container-With-Most-Water-Medium"><a href="#11-Container-With-Most-Water-Medium" class="headerlink" title="11. Container With Most Water (Medium)"></a><a href="https://leetcode.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. Container With Most Water (Medium)</a></h3><p>Given n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.</p>
<p>Note: You may not slant the container and n is at least 2.<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg" alt="Container With Most Water example"><br>The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</p>
<p>Example:<br>Input: [1,8,6,2,5,4,8,3,7]<br>Output: 49</p>
<pre><code class="python">class Solution:
    def maxArea(self, height: List[int]) -&gt; int:
        ans, l, r = 0, 0, len(height) - 1
        while l &lt; r:
            ans = max(ans, (r - l) * min(height[l], height[r]))
            if height[l] &lt; height[r]:
                l += 1
            else:
                r -= 1
        return ans
</code></pre>
<p>高频, 二刷：1.短的不能贡献更大的面积，可以移除2.其他的都需要更高的才有可能变成更大面积</p>
<h3 id="345-Reverse-Vowels-of-a-String-Easy"><a href="#345-Reverse-Vowels-of-a-String-Easy" class="headerlink" title="345. Reverse Vowels of a String (Easy)"></a><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/" target="_blank" rel="noopener">345. Reverse Vowels of a String (Easy)</a></h3><p>Write a function that takes a string as input and reverse only the vowels of a string.</p>
<p>Example 1:<br>Input: “hello”<br>Output: “holle”</p>
<p>Example 2:<br>Input: “leetcode”<br>Output: “leotcede”<br>Note:</p>
<pre><code class="python">class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        stack = []
        for c in s:
            if c in &quot;aeiouAEIOU&quot;:
                stack.append(c)
        for i, c in enumerate(s):
            if c in &quot;aeiouAEIOU&quot;:
                s = s[:i] + stack.pop() + s[i + 1:]
        return s
</code></pre>
<p>inplace:</p>
<pre><code class="python">class Solution:
    def reverseVowels(self, s: str) -&gt; str:
        l, r = 0, len(s) - 1
        arr = list(s)
        while l &lt; r:
            while arr[l] not in &quot;aeiouAEIOU&quot; and l &lt; len(s) - 1:
                l += 1
            while arr[r] not in &quot;aeiouAEIOU&quot; and r &gt; 0:
                r -= 1
            if l &lt; r:
                arr[l], arr[r] = arr[r], arr[l]
                l += 1
                r -= 1
        return &quot;&quot;.join(arr)
</code></pre>
<p>面经：DJI。</p>
<h1 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS 广度优先搜索"></a>BFS 广度优先搜索</h1><h3 id="695-Max-Area-of-Island-Medium"><a href="#695-Max-Area-of-Island-Medium" class="headerlink" title="695. Max Area of Island (Medium)"></a><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">695. Max Area of Island (Medium)</a></h3><pre><code class="html">Given a non-empty 2D array grid of 0&#39;s and 1&#39;s, an island is a group of 1&#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)

Example 1:
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.
Example 2:
[[0,0,0,0,0,0,0,0]]
Given the above grid, return 0.
Note: The length of each dimension in the given grid does not exceed 50.
</code></pre>
<p>思路：没啥太多好说的，BFS 暴力</p>
<pre><code class="python">class Solution:
    def maxAreaOfIsland(self, grid):
        &quot;&quot;&quot;
        :type grid: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        if len(grid) == 0:
            return 0
        ans = 0
        for row in range(len(grid)):
            for col in range(len(grid[0])):
                if grid[row][col] == 1:
                    ans = max(self.bfs(grid, row, col), ans)
        return ans
    def bfs(self, grid, row, col):
        import collections
        q = collections.deque()
        q.append((row, col))
        grid[row][col] = 0
        size = 0
        while q:
            row, col = q.popleft()
            size += 1
            if self.isValid(grid, row - 1, col) and grid[row - 1][col] == 1:
                q.append((row - 1, col))
                grid[row - 1][col] = 0
            if self.isValid(grid, row + 1, col) and grid[row + 1][col] == 1:
                q.append((row + 1, col))
                grid[row + 1][col] = 0
            if self.isValid(grid, row, col - 1) and grid[row][col - 1] == 1:
                q.append((row, col - 1))
                grid[row][col - 1] = 0
            if self.isValid(grid, row, col + 1) and grid[row][col + 1] == 1:
                q.append((row, col + 1))
                grid[row][col + 1] = 0
        return size
    def isValid(self, grid, row, col):
        return row &gt;= 0 and row &lt; len(grid) and col &gt;= 0 and col &lt; len(grid[0])
</code></pre>
<p>总结：在上下左右走的时候注意入 q 以后立刻将该点标为 0， 以防同一个点入两次。<br>二刷：</p>
<pre><code class="python">class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -&gt; int:
        if len(grid) == 0 or len(grid[0]) == 0:
            return 0
        ans = 0
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == 1:
                    s = 0
                    q = collections.deque()
                    q.append((r, c))
                    grid[r][c] = 0
                    while len(q) &gt; 0:
                        (rq, cq) = q.popleft()
                        s += 1
                        if rq &gt; 0 and grid[rq - 1][cq] == 1:
                            q.append((rq - 1, cq))
                            grid[rq - 1][cq] = 0
                        if rq &lt; len(grid) - 1 and grid[rq + 1][cq] == 1:
                            q.append((rq + 1, cq))
                            grid[rq + 1][cq] = 0
                        if cq &gt; 0 and grid[rq][cq - 1] == 1:
                            q.append((rq, cq - 1))
                            grid[rq][cq - 1] = 0
                        if cq &lt; len(grid[0]) - 1 and grid[rq][cq + 1] == 1:
                            q.append((rq, cq + 1))
                            grid[rq][cq + 1] = 0
                    if s &gt; ans:
                        ans = s
        return ans
</code></pre>
<p>总结：一次写完， 没有像一刷那样拆成三个函数。 各有优劣吧。注意清零的位置要在放 queue 之后立刻清零，以防同一个点如两次， lol 二刷踩同样的坑 :’(</p>
<h3 id="133-Clone-Graph-Medium"><a href="#133-Clone-Graph-Medium" class="headerlink" title="133. Clone Graph (Medium)"></a><a href="https://leetcode.com/problems/clone-graph/description/" target="_blank" rel="noopener">133. Clone Graph (Medium)</a></h3><pre><code class="html">Given a reference of a node in a connected undirected graph, return a deep copy (clone) of the graph. Each node in the graph contains a val (int) and a list (List[Node]) of its neighbors.

Example:
&lt;img src=&quot;https://assets.leetcode.com/uploads/2019/02/19/113_sample.png&quot;
     alt=&quot;graph example&quot;/&gt;
Input:
{&quot;$id&quot;:&quot;1&quot;,&quot;neighbors&quot;:[{&quot;$id&quot;:&quot;2&quot;,&quot;neighbors&quot;:[{&quot;$ref&quot;:&quot;1&quot;},{&quot;$id&quot;:&quot;3&quot;,&quot;neighbors&quot;:[{&quot;$ref&quot;:&quot;2&quot;},{&quot;$id&quot;:&quot;4&quot;,&quot;neighbors&quot;:[{&quot;$ref&quot;:&quot;3&quot;},{&quot;$ref&quot;:&quot;1&quot;}],&quot;val&quot;:4}],&quot;val&quot;:3}],&quot;val&quot;:2},{&quot;$ref&quot;:&quot;4&quot;}],&quot;val&quot;:1}

Explanation:
Node 1&#39;s value is 1, and it has two neighbors: Node 2 and 4.
Node 2&#39;s value is 2, and it has two neighbors: Node 1 and 3.
Node 3&#39;s value is 3, and it has two neighbors: Node 2 and 4.
Node 4&#39;s value is 4, and it has two neighbors: Node 1 and 3.

Note:
The number of nodes will be between 1 and 100.
The undirected graph is a simple graph, which means no repeated edges and no self-loops in the graph.
Since the graph is undirected, if node p has node q as neighbor, then node q must have node p as neighbor too.
You must return the copy of the given node as a reference to the cloned graph.
</code></pre>
<p>思路：BFS, 用一个 dict 存当前节点的邻居，如果没见过就加 dict 存 queue，queue 出来建 node，放 neighbor；概念上比较好懂，写码可能有坑</p>
<pre><code class="python"># Definition for a undirected graph node
# class UndirectedGraphNode:
#     def __init__(self, x):
#         self.label = x
#         self.neighbors = []

class Solution:
    # @param node, a undirected graph node
    # @return a undirected graph node
    def cloneGraph(self, node):
        if node == None:
            return None
        dict = {}
        _cloneNode = UndirectedGraphNode(node.label)
        dict[node] = _cloneNode
        q = [node]
        while q:
            new_q = []
            for _node in q:
                for neighbor in _node.neighbors:
                    if neighbor not in dict:
                        _cloneNode = UndirectedGraphNode(neighbor.label)
                        dict[neighbor] = _cloneNode
                        new_q.append(neighbor)
                    dict[_node].neighbors.append(dict[neighbor])
            q = new_q
        return dict[node]
</code></pre>
<p>总结：思路用 dict 来存当前节点的邻居是错的，需要用 dict 存当前节点和克隆节点的映射关系。因为反正映射关系在，加邻居可以后加. 邻居是不能直接 copy 或者 = 的， 因为邻居的类型也是节点， 需要创造以后加进去。测一下，然后 debug 细一点， 要测出</p>
<pre><code class="python">dict[_node].neighbors.append(dict[neighbor])
</code></pre>
<p>二刷：</p>
<pre><code class="python">&quot;&quot;&quot;
# Definition for a Node.
class Node:
    def __init__(self, val, neighbors):
        self.val = val
        self.neighbors = neighbors
&quot;&quot;&quot;
class Solution:
    def cloneGraph(self, node: &#39;Node&#39;) -&gt; &#39;Node&#39;:
        d = {}
        n = Node(node.val, [])
        if node.neighbors == None or len(node.neighbors) == 0:
            return n
        d[node] = n
        q = collections.deque()
        q.append(node)
        while q:
            nq = q.popleft()
            if nq not in d:
                n = Node(nq.val, [])
                d[nq] = n
            for nn in nq.neighbors:
                if nn not in d:
                    q.append(nn)
                    n = Node(nn.val, [])
                    d[nn] = n
                d[nq].neighbors.append(d[nn])
        return d[node]
</code></pre>
<p>总结：二刷第一遍没有想到 nn 在不在 d 里面，都要加入到克隆出来的节点的 neighbors 中去。此次击败了 100% 的内存使用，如需提高速度，可以增加一个 visited = set() 如果已经访问过就 return，可以用空间换时间</p>
<h3 id="127-Word-Ladder-Medium"><a href="#127-Word-Ladder-Medium" class="headerlink" title="127. Word Ladder (Medium)"></a><a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="noopener">127. Word Ladder (Medium)</a></h3><p>Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that:<br>Only one letter can be changed at a time.<br>Each transformed word must exist in the word list. Note that beginWord is not a transformed word.<br>Note:<br>Return 0 if there is no such transformation sequence.<br>All words have the same length.<br>All words contain only lowercase alphabetic characters.<br>You may assume no duplicates in the word list.<br>You may assume beginWord and endWord are non-empty and are not the same.</p>
<p>Example 1:<br>Input:<br>beginWord = “hit”,<br>endWord = “cog”,<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”,”cog”]<br>Output: 5<br>Explanation: As one shortest transformation is “hit” -&gt; “hot” -&gt; “dot” -&gt; “dog” -&gt; “cog”,<br>return its length 5.</p>
<p>Example 2:<br>Input:<br>beginWord = “hit”<br>endWord = “cog”<br>wordList = [“hot”,”dot”,”dog”,”lot”,”log”]<br>Output: 0<br>Explanation: The endWord “cog” is not in wordList, therefore no possible transformation.</p>
<p>可以输出此path：</p>
<pre><code class="python">class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; int:
        if endWord not in wordList or len(beginWord) != len(endWord):
            return 0
        q = [[beginWord]]
        wordList = set(wordList)
        visited = set()
        while q:
            curPath = q.pop(0)
            curWord = curPath[-1]
            if curWord == endWord:
                return len(curPath)
            for i in range(len(curWord)):
                for c in [chr(x) for x in range(ord(&quot;a&quot;), ord(&quot;z&quot;) + 1)]:
                    newW = curWord[:i] + c + curWord[i + 1:]
                    if newW in wordList and newW not in visited:
                        visited.add(newW)
                        q.append(curPath + [newW])
        return 0
</code></pre>
<p>精简无需输出path：</p>
<pre><code class="python">class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -&gt; int:
        if endWord not in wordList or len(beginWord) != len(endWord):
            return 0
        q = [(beginWord, 1)]
        wordList = set(wordList)
        visited = set()
        while q:
            word, length = q.pop(0)
            if word == endWord:
                return length
            for i in range(len(word)):
                for c in [chr(i) for i in range(ord(&quot;a&quot;), ord(&quot;z&quot;))]:
                    newW = word[:i] + c + word[i + 1:]
                    if newW in wordList and newW not in visited:
                        visited.add(newW)
                        q.append((newW, length + 1))
        return 0
</code></pre>
<p>面试：DJI<br>三刷：注意简版需要visited</p>
<h3 id="200-Number-of-Islands-Medium"><a href="#200-Number-of-Islands-Medium" class="headerlink" title="200. Number of Islands (Medium)"></a><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">200. Number of Islands (Medium)</a></h3><pre><code class="html">Given a 2d grid map of &#39;1&#39;s (land) and &#39;0&#39;s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

Example 1:
Input:
11110
11010
11000
00000
Output: 1

Example 2:
Input:
11000
11000
00100
00011
Output: 3
</code></pre>
<p>思路：遍历矩阵，碰到 1 就上下左右 BFS，碰到 0 跳过。BFS 访问过的标 0</p>
<pre><code class="python">class Solution:
    def numIslands(self, grid: List[List[str]]) -&gt; int:
        ans = 0
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == &quot;1&quot;:
                    ans += 1
                    grid[r][c] = &quot;0&quot;
                    self.bfs(grid, r, c)
        return ans
    def bfs(self, matrix, r, c):
        q = [(r, c)]
        while q:
            r, c = q.pop(0)
            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:
                newR = r + dr
                newC = c + dc
                if 0 &lt;= newR &lt;= len(matrix) - 1 and 0 &lt;= newC &lt;= len(matrix[0]) - 1 and matrix[newR][newC] == &quot;1&quot;:
                    matrix[newR][newC] = &quot;0&quot;
                    q.append((newR, newC))
</code></pre>
<p>面经，三刷：Amazon。对于 leetcode ac 比较重要的细节是，gird[][] = ‘0’ 这句话要在 if 里面，否则逻辑 OK 但是会 TLE</p>
<h3 id="LinC-611-Knight-Shortest-Path-Medium"><a href="#LinC-611-Knight-Shortest-Path-Medium" class="headerlink" title="LinC 611. Knight Shortest Path (Medium)"></a><a href="https://www.lintcode.com/problem/knight-shortest-path/description" target="_blank" rel="noopener">LinC 611. Knight Shortest Path (Medium)</a></h3><pre><code class="html">Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.
Return -1 if knight can not reached.

source and destination must be empty.
Knight can not enter the barrier.

Clarification
If the knight is at (x, y), he can get to the following positions in one step:

(x + 1, y + 2)
(x + 1, y - 2)
(x - 1, y + 2)
(x - 1, y - 2)
(x + 2, y + 1)
(x + 2, y - 1)
(x - 2, y + 1)
(x - 2, y - 1)
Example
[[0,0,0],
 [0,0,0],
 [0,0,0]]
source = [2, 0] destination = [2, 2] return 2

[[0,1,0],
 [0,0,0],
 [0,0,0]]
source = [2, 0] destination = [2, 2] return 6

[[0,1,0],
 [0,0,1],
 [0,0,0]]
source = [2, 0] destination = [2, 2] return -1
</code></pre>
<p>思路：没什么思路， 看了下答案，就是 BFS 硬来，需要检查走了某个方向以后是不是还是在棋盘内</p>
<pre><code class="python">&quot;&quot;&quot;
Definition for a point.
class Point:
    def __init__(self, a=0, b=0):
        self.x = a
        self.y = b
&quot;&quot;&quot;

class Solution:
    &quot;&quot;&quot;
    @param grid: a chessboard included 0 (false) and 1 (true)
    @param source: a point
    @param destination: a point
    @return: the shortest path
    &quot;&quot;&quot;
    def shortestPath(self, grid, source, destination):
        # write your code here
        if len(grid) == 0 or (len(grid[0]) == 1 and grid[0][0] == 1):
            return -1
        ans = 0
        dx = [1, 1, -1, -1, 2, 2, -2, -2]
        dy = [2, -2, 2, -2, 1, -1, 1, -1]
        q = collections.deque([source])
        grid[source.x][source.y] = 1
        while q:
            qlen = len(q)
            next_q = collections.deque()
            for i in range(qlen):
                pt = q.popleft()
                if pt.x == destination.x and pt.y == destination.y:
                    return ans
                for move in range(len(dx)):
                    nextPt = Point(pt.x + dx[move], pt.y + dy[move])
                    if (self.isInbound(grid, nextPt) and grid[nextPt.x][nextPt.y] == 0):
                        next_q.append(nextPt)
                        grid[nextPt.x][nextPt.y] = 1
            ans += 1
            q = next_q
        return -1
    def isInbound(self, grid, pt):
        return pt.x &gt;= 0 and pt.x &lt; len(grid) and pt.y &gt;= 0 and pt.y &lt; len(grid[0])
</code></pre>
<p>总结：注意 isInbound 要查的是 &gt;=0 和 &lt; len()， 其他的问题可以通过跑一个测试数据发现</p>
<h3 id="785-Is-Graph-Bipartite-Medium"><a href="#785-Is-Graph-Bipartite-Medium" class="headerlink" title="785. Is Graph Bipartite? (Medium)"></a><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">785. Is Graph Bipartite? (Medium)</a></h3><pre><code class="html">Given an undirected graph, return true if and only if it is bipartite.

Recall that a graph is bipartite if we can split it&#39;s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.

The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn&#39;t contain any element twice.

Example 1:
Input: [[1,3], [0,2], [1,3], [0,2]]
Output: true
Explanation:
The graph looks like this:
0----1
|    |
|    |
3----2
We can divide the vertices into two groups: {0, 2} and {1, 3}.
Example 2:
Input: [[1,2,3], [0,2], [0,1,3], [0,2]]
Output: false
Explanation:
The graph looks like this:
0----1
| \  |
|  \ |
3----2
We cannot find a way to divide the set of nodes into two independent subsets.


Note:

graph will have length in range [1, 100].
graph[i] will contain integers in range [0, graph.length - 1].
graph[i] will not contain i or duplicate values.
The graph is undirected: if any element j is in graph[i], then i will be in graph[j].
</code></pre>
<p>思路：用染色的方法，可以用 DFS, BFS 给所有 node 染上两种色中的一种。1.未上色，既上色，给相邻节点上相反色 2.已上色，查是否和目前要上的色相同<br>DFS:</p>
<pre><code class="python">class Solution:
    def isBipartite(self, graph):
        &quot;&quot;&quot;
        :type graph: List[List[int]]
        :rtype: bool
        &quot;&quot;&quot;
        seen = {}
        def dfs(n, color):
            if n in seen:
                return color == seen[n]
            seen[n] = color
            for v in graph[n]:
                if not dfs(v, -color):
                    return False
            return True
        for i in range(len(graph)):
            if i not in seen and dfs(i, 1) == False:
                return False
        return True
</code></pre>
<p>BFS:</p>
<pre><code class="python">class Solution:
    def isBipartite(self, graph):
        seen = {}
        for i in range(len(graph)):
            if i not in seen:
                s = [(i, 1)]
                seen[i] = 1
                while s:
                    n, color = s.pop()
                    for v in graph[n]:
                        if v in seen:
                            if color == seen[v]:
                                return False
                        else:
                            seen[v] = -color
                            s.append((v, -color))
        return True
</code></pre>
<p>二刷：DFS: …return color == seen[n]…if not dfs(v, -color): return False…return True… BFS: …seen[i] = 1; while…</p>
<h3 id="LinC-178-Graph-Valid-Tree-Medium"><a href="#LinC-178-Graph-Valid-Tree-Medium" class="headerlink" title="LinC 178. Graph Valid Tree (Medium)"></a><a href="http://www.lintcode.com/problem/graph-valid-tree/" target="_blank" rel="noopener">LinC 178. Graph Valid Tree (Medium)</a></h3><p>Leetcode 261. Graph Valid Tree 带锁</p>
<pre><code class="html">Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.

You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.

Example
Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.

Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.
</code></pre>
<p>思路：树的两个条件是不能有环，不能有孤儿节点。怎么实现想不太出来。看了答案，用 defaultdict(list) 放节点之间的关系， 有没有环其实不用管，因为只要确保边的数量 == n - 1, 并且 <strong>BFS</strong> 走过一遍之后访问过了所有的点，就确定没有环了。</p>
<pre><code class="python">class Solution:
    def validTree(self, n, edges):
        if len(edges) == 0 and n == 1:
            return True
        if len(edges) != n - 1:
            return False
        mapping = collections.defaultdict(list)
        for edge in edges:
            mapping[edge[0]].append(edge[1])
            mapping[edge[1]].append(edge[0])
        visited = set()
        q = [0]
        while q:
            node = q.pop()
            visited.add(node)
            for neighbor in mapping[node]:
                if neighbor not in visited:
                    q.append(neighbor)
                    visited.add(neighbor)
        return len(visited) == n
</code></pre>
<p>总结：相当值得做的一道 BFS 题。注意 已经访问过的节点不要入 q，不然无向图的边会导致死循环</p>
<h3 id="130-Surrounded-Regions-Medium"><a href="#130-Surrounded-Regions-Medium" class="headerlink" title="130. Surrounded Regions (Medium)"></a><a href="https://leetcode.com/problems/surrounded-regions/" target="_blank" rel="noopener">130. Surrounded Regions (Medium)</a></h3><pre><code class="html">Given a 2D board containing &#39;X&#39; and &#39;O&#39; (the letter O), capture all regions surrounded by &#39;X&#39;.

A region is captured by flipping all &#39;O&#39;s into &#39;X&#39;s in that surrounded region.

Example:

X X X X
X O O X
X X O X
X O X X
After running your function, the board should be:

X X X X
X X X X
X X X X
X O X X
Explanation:

Surrounded regions shouldn’t be on the border, which means that any &#39;O&#39; on the border of the board are not flipped to &#39;X&#39;. Any &#39;O&#39; that is not on the border and it is not connected to an &#39;O&#39; on the border will be flipped to &#39;X&#39;. Two cells are connected if they are adjacent cells connected horizontally or vertically.
</code></pre>
<pre><code class="python">class Solution:
    def solve(self, board: List[List[str]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify board in-place instead.
        &quot;&quot;&quot;
        if not board:
            return
        m, n = len(board), len(board[0])
        rule = lambda ij: 0 &lt;= ij[0] &lt; m and 0 &lt;= ij[1] &lt; n and board[ij[0]][ij[1]] == &#39;O&#39;
        q = list(filter(rule, [ij for k in range(max(m, n)) for ij in [(0, k), (k, 0), (m - 1, k), (k, n - 1)]]))
        while q:
            (i, j) = q.pop()
            board[i][j] = &#39;S&#39;
            q += list(filter(rule, [(i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j)]))
        for i in range(m):
            for j in range(n):
                if board[i][j] == &#39;S&#39;:
                    board[i][j] = &#39;O&#39;
                else:
                    board[i][j] = &#39;X&#39;
</code></pre>
<p>高频：需要改为q.pop(0)才是BFS，否则是DFS，但是代码风格放在BFS比较合适</p>
<h3 id="675-Cut-Off-Trees-for-Golf-Event-Hard"><a href="#675-Cut-Off-Trees-for-Golf-Event-Hard" class="headerlink" title="675. Cut Off Trees for Golf Event (Hard)"></a><a href="https://leetcode.com/problems/cut-off-trees-for-golf-event/" target="_blank" rel="noopener">675. Cut Off Trees for Golf Event (Hard)</a></h3><p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:<br>0 represents the obstacle can’t be reached.<br>1 represents the ground can be walked through.<br>The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.</p>
<p>You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).<br>You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.<br>You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.</p>
<pre><code>Example 1:
Input:
[
 [1,2,3],
 [0,0,4],
 [7,6,5]
]
Output: 6

Example 2:
Input:
[
 [1,2,3],
 [0,0,0],
 [7,6,5]
]
Output: -1

Example 3:
Input:
[
 [2,3,4],
 [0,0,5],
 [8,7,6]
]
Output: 6
Explanation: You started from the point (0,0) and you can cut off the tree in (0,0) directly without walking.
</code></pre><pre><code class="python">class Solution:
    def cutOffTree(self, forest):
        m, n = len(forest), len(forest[0])
        trees = [[forest[r][c], r, c] for r in range(m) for c in range(n) if forest[r][c] &gt; 1]
        trees.sort(key = lambda x: x[0])
        ans = 0
        nextR, nextC = 0, 0
        for h, r, c in trees:
            step = self.bfs(forest, nextR, nextC, r, c, m, n)
            if step == -1:
                return -1
            else:
                forest[r][c] = 1
                nextR, nextC = r, c
                ans += step
        return ans
    def bfs(self, forest, startR, startC, endR, endC, m, n):
        step = 0
        q = [(startR, startC)]
        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        visited = set()
        while q:
            nq = []
            for _ in range(len(q)):
                r, c = q.pop()
                if r == endR and c == endC:
                    return step
                visited.add((r, c))
                for dr, dc in dirs:
                    if 0 &lt;= r + dr &lt;= m - 1 and 0 &lt;= c + dc &lt;= n - 1 and forest[r + dr][c + dc] != 0 and (r + dr, c + dc) not in visited:
                        nq.append((r + dr, c + dc))
            step += 1
            q = nq
        return -1
</code></pre>
<p>面经：Amazon。比较不偏门的算法，可惜会TLE</p>
<h3 id="310-Minimum-Height-Trees-Medium"><a href="#310-Minimum-Height-Trees-Medium" class="headerlink" title="310. Minimum Height Trees (Medium)"></a><a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="noopener">310. Minimum Height Trees (Medium)</a></h3><p>For an undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels.<br>Format<br>The graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels).<br>You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</p>
<pre><code>Example 1 :
Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]]
        0
        |
        1
       / \
      2   3

Output: [1]

Example 2 :
Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]
     0  1  2
      \ | /
        3
        |
        4
        |
        5

Output: [3, 4]
</code></pre><p>Note:<br>According to the definition of tree on Wikipedia: “a tree is an undirected graph in which any two vertices are connected by exactly one path. In other words, any connected graph without simple cycles is a tree.”<br>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.</p>
<pre><code class="python">class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -&gt; List[int]:
        if not edges:
            return [0]
        from collections import defaultdict
        adj = defaultdict(list)
        for u, v in edges:
            adj[u].append(v)
            adj[v].append(u)
        leaves = [k for k, v in adj.items() if len(v) == 1]
        while n &gt; 2:
            n -= len(leaves)
            newLeaves = []
            for u in leaves:
                v = adj[u].pop()
                adj[v].remove(u)
                if len(adj[v]) == 1:
                    newLeaves.append(v)
            leaves = newLeaves
        return leaves
</code></pre>
<p>一刷：Facebook tag，<a href="https://leetcode.com/problems/minimum-height-trees/discuss/76055/Share-some-thoughts" target="_blank" rel="noopener">leetcode 讨论区解法</a></p>
<h2 id="Topological-sorting-拓扑排序"><a href="#Topological-sorting-拓扑排序" class="headerlink" title="Topological sorting 拓扑排序"></a>Topological sorting 拓扑排序</h2><h3 id="LinC-127-Topological-Sorting-Medium"><a href="#LinC-127-Topological-Sorting-Medium" class="headerlink" title="LinC 127. Topological Sorting (Medium)"></a><a href="https://www.lintcode.com/problem/topological-sorting/description" target="_blank" rel="noopener">LinC 127. Topological Sorting (Medium)</a></h3><p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p>
<p>For each directed edge A -&gt; B in graph, A must before B in the order list.<br>The first node in the order can be any node in the graph with no nodes direct to it.<br>Find any topological order for the given graph.<br>You can assume that there is at least one topological order in the graph.<br>Clarification<br><a href="http://www.lintcode.com/help/graph" target="_blank" rel="noopener">Learn more about representation of graphs</a></p>
<p>Example:<br>For graph as follow:<br><img src="/images/lintcode_127_topo_1.jpeg" alt="graph example"><br>The topological order can be:<br>[0, 1, 2, 3, 4, 5]<br>[0, 2, 3, 1, 5, 4]<br>思路：拓扑排序，算法貌似是：1.统计每个点的入度；2.将入度为 0 的点入 queue；3.从队列中 pop 点，去掉所有指向别的点的边: 相应点入度 -1；4.新入度为 0 的点入 queue</p>
<pre><code class="python">&quot;&quot;&quot;
Definition for a Directed graph node
class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
&quot;&quot;&quot;
class Solution:
    &quot;&quot;&quot;
    @param: graph: A list of Directed graph node
    @return: Any topological order for the given graph.
    &quot;&quot;&quot;
    def topSort(self, graph):
        # write your code here
        if len(graph) == 0:
            return []
        ans = []
        inBound = {}
        for node in graph:
            if node not in inBound:
                inBound[node] = 0
            for neighbor in node.neighbors:
                if neighbor not in inBound:
                    inBound[neighbor] = 0
                inBound[neighbor] += 1
        q = collections.deque()
        for node in inBound:
            if inBound[node] == 0:
                q.append(node)
        while q:
            zNode = q.popleft()
            ans.append(zNode)
            for node in zNode.neighbors:
                inBound[node] -= 1
                if inBound[node] == 0:
                    q.append(node)
        return ans
</code></pre>
<p>总结：顺利。但是题目没有说清楚 return 的是一个拓扑排序好的 node 的 list</p>
<h3 id="207-Course-Schedule-Medium"><a href="#207-Course-Schedule-Medium" class="headerlink" title="207. Course Schedule (Medium)"></a><a href="https://leetcode.com/problems/course-schedule/description/" target="_blank" rel="noopener">207. Course Schedule (Medium)</a></h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.<br>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]<br>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: true<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0. So it is possible.</p>
<p>Example 2:<br>Input: 2, [[1,0],[0,1]]<br>Output: false<br>Explanation: There are a total of 2 courses to take.<br>             To take course 1 you should have finished course 0, and to take course 0 you should<br>             also have finished course 1. So it is impossible.</p>
<p>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>
<p>二刷：</p>
<pre><code class="python">class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -&gt; bool:
        inDegree = [0] * numCourses
        graph = collections.defaultdict(list)
        for e in prerequisites:
            graph[e[1]].append(e[0])
            inDegree[e[0]] += 1
        q = []
        for i, d in enumerate(inDegree):
            if d == 0:
                q.append(i)
        while q:
            v1 = q.pop(0)
            for v2 in graph[v1]:
                inDegree[v2] -= 1
                if inDegree[v2] == 0:
                    q.append(v2)
        for d in inDegree:
            if d != 0:
                return False
        return True
</code></pre>
<p>总结：较值得二刷的题，发现了for i, v in enumerate(list)和for k, v in dict.items()这两种用法混淆的薄弱环节。 还有对入度和建的graph概念没有完全理解<br>面经：Cruise。…collecitons.default <strong>dict</strong>()…统计入度需要…inDegree[<strong>e[0]</strong>] += 1…被指向的vertex入度加一</p>
<h3 id="210-Course-Schedule-II-Medium"><a href="#210-Course-Schedule-II-Medium" class="headerlink" title="210. Course Schedule II (Medium)"></a><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">210. Course Schedule II (Medium)</a></h3><p>There are a total of n courses you have to take, labeled from 0 to n-1.<br>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]<br>Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.<br>There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</p>
<p>Example 1:<br>Input: 2, [[1,0]]<br>Output: [0,1]<br>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished<br>             course 0. So the correct course order is [0,1] .</p>
<p>Example 2:<br>Input: 4, [[1,0],[2,0],[3,1],[3,2]]<br>Output: [0,1,2,3] or [0,2,1,3]<br>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both<br>             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.<br>             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .<br>Note:<br>The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.<br>You may assume that there are no duplicate edges in the input prerequisites.</p>
<pre><code class="python">class Solution:
    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -&gt; List[int]:
        graph = collections.defaultdict(list)
        indegree = [0] * numCourses
        for e in prerequisites:
            graph[e[1]].append(e[0])
            indegree[e[0]] += 1
        q = []
        ans = []
        for i, v in enumerate(indegree):
            if v == 0:
                q.append(i)
                ans.append(i)
        while q:
            v1 = q.pop(0)
            for v2 in graph[v1]:
                indegree[v2] -= 1
                if indegree[v2] == 0:
                    q.append(v2)
                    ans.append(v2)
        return ans if len(ans) == numCourses else []
</code></pre>
<p>面经：Cruise。</p>
<h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS 深度优先搜索"></a>DFS 深度优先搜索</h1><h2 id="Binary-Tree-DFS-二叉树与树上的深度优先搜索"><a href="#Binary-Tree-DFS-二叉树与树上的深度优先搜索" class="headerlink" title="Binary Tree DFS 二叉树与树上的深度优先搜索"></a>Binary Tree DFS 二叉树与树上的深度优先搜索</h2><h3 id="257-Binary-Tree-Paths-Easy"><a href="#257-Binary-Tree-Paths-Easy" class="headerlink" title="257. Binary Tree Paths (Easy)"></a><a href="https://leetcode.com/problems/binary-tree-paths/description/" target="_blank" rel="noopener">257. Binary Tree Paths (Easy)</a></h3><p>Given a binary tree, return all root-to-leaf paths.<br>Note: A leaf is a node with no children.</p>
<pre><code>Example:
Input:
   1
 /   \
2     3
 \
  5
Output: [&quot;1-&gt;2-&gt;5&quot;, &quot;1-&gt;3&quot;]
</code></pre><p>Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</p>
<pre><code class="python">class Solution:
    def binaryTreePaths(self, root: TreeNode) -&gt; List[str]:
        ans = []
        cur = []
        def dfs(root):
            if not root:
                return
            cur.append(str(root.val))
            if not root.left and not root.right:
                ans.append(&quot;-&gt;&quot;.join(cur))
            dfs(root.left)
            dfs(root.right)
            del cur[-1]
        dfs(root)
        return ans
</code></pre>
<p>六刷：注意：1.剪枝，因为cur是一个reference，递归过程中cur会变长，当前层完成返回上一级函数调用时需要将当前层加上的多余的枝减去 2.ans.append()后不要return，不然无法剪枝</p>
<h3 id="113-Path-Sum-II-Medium"><a href="#113-Path-Sum-II-Medium" class="headerlink" title="113. Path Sum II (Medium)"></a><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">113. Path Sum II (Medium)</a></h3><p>Given a binary tree and a sum, find all root-to-leaf paths where each path’s sum equals the given sum.<br>Note: A leaf is a node with no children.</p>
<pre><code>Example:
Given the below binary tree and sum = 22,
      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:
[
   [5,4,11,2],
   [5,8,4,5]
]
</code></pre><pre><code class="python">class Solution:
    def pathSum(self, root: TreeNode, sum: int) -&gt; List[List[int]]:
        ans = []
        cur = []
        target = sum
        def dfs(root):
            global sum
            if not root:
                return
            cur.append(root.val)
            if not root.left and not root.right and sum(cur) == target:
                ans.append(cur[:])
            dfs(root.left)
            dfs(root.right)
            del cur[-1]
        dfs(root)
        return ans
</code></pre>
<p>八刷：高频，面经：Quora, 大疆。注意：ans.append()后面不要return，否则会丢失剪枝。TODO 用遍历再刷</p>
<h3 id="437-Path-Sum-III-Medium"><a href="#437-Path-Sum-III-Medium" class="headerlink" title="437. Path Sum III (Medium)"></a><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">437. Path Sum III (Medium)</a></h3><p>You are given a binary tree in which each node contains an integer value.<br>Find the number of paths that sum to a given value.<br>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).<br>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p>
<pre><code>Example:
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:
1.  5 -&gt; 3
2.  5 -&gt; 2 -&gt; 1
3. -3 -&gt; 11
</code></pre><p>O(n^2)</p>
<pre><code class="python">class Solution:
    def pathSum(self, root: TreeNode, sum: int) -&gt; int:
        if not root:
            return 0
        ans = 0
        def dfs(root):
            if not root:
                return
            helper(root, sum)
            dfs(root.left)
            dfs(root.right)
        def helper(root, cur):  
            nonlocal ans
            if not root:
                return
            cur -= root.val
            if cur == 0:
                ans += 1
            helper(root.left, cur)
            helper(root.right, cur)
        dfs(root)
        return ans
</code></pre>
<p>DFS + Memo：</p>
<pre><code class="python">class Solution:
    def pathSum(self, root: TreeNode, sum: int) -&gt; int:
        ans = 0
        memo = {0: 1}
        def dfs(root, cur):
            nonlocal ans, sum
            if not root:
                return
            cur += root.val
            ans += memo.get(cur - sum, 0)
            memo[cur] = memo.get(cur, 0) + 1
            dfs(root.left, cur)
            dfs(root.right, cur)
            memo[cur] -= 1
        dfs(root, 0)
        return ans
</code></pre>
<p>三刷：面经：Quora</p>
<h2 id="Combination-based-DFS-基于组合的深度优先搜索"><a href="#Combination-based-DFS-基于组合的深度优先搜索" class="headerlink" title="Combination based DFS - 基于组合的深度优先搜索"></a>Combination based DFS - 基于组合的深度优先搜索</h2><h3 id="78-Subsets-Medium"><a href="#78-Subsets-Medium" class="headerlink" title="78. Subsets (Medium)"></a><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">78. Subsets (Medium)</a></h3><p>Given a set of distinct integers, nums, return all possible subsets (the power set).<br>Note: The solution set must not contain duplicate subsets.</p>
<p>Example:<br>Input: nums = [1,2,3]<br>Output:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]</p>
<pre><code class="python">class Solution:
    def subsets(self, nums):
        ans = []
        cur = []
        def dfs(idx):
            ans.append(cur[:])
            for i in range(idx, len(nums)):
                cur.append(nums[i])
                dfs(i + 1)
                del cur[-1]
        dfs(0)
        return ans
</code></pre>
<p>六刷：高频。O(2^n)</p>
<h3 id="39-Combination-Sum-Medium"><a href="#39-Combination-Sum-Medium" class="headerlink" title="39. Combination Sum (Medium)"></a><a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="noopener">39. Combination Sum (Medium)</a></h3><p>Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>The same repeated number may be chosen from candidates unlimited number of times.<br>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.</p>
<pre><code>Example 1:
Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]

Example 2:
Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
</code></pre><pre><code class="python">class Solution:
    def combinationSum(self, candidates, target):
        ans = []
        cur = []
        nums = sorted(candidates)
        def dfs(idx):
            nonlocal target
            if sum(cur) == target:
                ans.append(cur[:])
                return
            for i in range(idx, len(nums)):
                if nums[i] + sum(cur) &lt;= target:
                    cur.append(nums[i])
                    dfs(i)
                    del cur[-1]
        dfs(0)
        return ans
</code></pre>
<p>五刷：高频, 面经, Quora, Amazon。需要排序的原因是为了避免结果里[2,3,2], [3,2,2]这类情况的发生，结果里只能取当前或比当前大的数。时间复杂度为O(n^k)，n是candidates的数量，k是target / min(candidates)或者用target来近似（假设min是1的话），这个上限比网上一些O(n!)的说法更低</p>
<h3 id="40-Combination-Sum-II-Medium"><a href="#40-Combination-Sum-II-Medium" class="headerlink" title="40. Combination Sum II (Medium)"></a><a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener">40. Combination Sum II (Medium)</a></h3><p>Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.<br>Each number in candidates may only be used once in the combination.<br>Note:<br>All numbers (including target) will be positive integers.<br>The solution set must not contain duplicate combinations.</p>
<pre><code>Example 1:
Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

Example 2:
Input: candidates = [2,5,2,1,2], target = 5,
A solution set is:
[
  [1,2,2],
  [5]
]
</code></pre><pre><code class="python">class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]:
        nums = sorted(candidates)
        ans = []
        cur = []
        used = [False for _ in range(len(nums))]
        def dfs(idx):
            nonlocal target
            if sum(cur) == target:
                ans.append(cur[:])
                return
            for i in range(idx, len(nums)):
                if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:
                    continue
                if sum(cur) + nums[i] &lt;= target:
                    cur.append(nums[i])
                    used[i] = True
                    dfs(i + 1)
                    used[i] = False
                    del cur[-1]
        dfs(0)
        return ans
</code></pre>
<p>写法2：</p>
<pre><code class="python">class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -&gt; List[List[int]]::
        nums = sorted(candidates)
        ans = []
        cur = []
        def dfs(idx):
            nonlocal target
            if sum(cur) == target:
                ans.append(cur[:])
                return
            for i in range(idx, len(nums)):
                if i &gt; idx and nums[i] == nums[i - 1]:
                    continue
                if sum(cur) + nums[i] &lt;= target:
                    cur.append(nums[i])
                    dfs(i + 1)
                    del cur[-1]
        dfs(0)
        return ans
</code></pre>
<p>六刷：高频, 面经, amazon。o(2^n) 注意：…<strong>if i &gt; idx</strong> and nums[i] == nums[i - 1]: continue…</p>
<h3 id="216-combination-sum-iii-medium"><a href="#216-combination-sum-iii-medium" class="headerlink" title="216. combination sum iii (medium)"></a><a href="https://leetcode.com/problems/combination-sum-iii/description/" target="_blank" rel="noopener">216. combination sum iii (medium)</a></h3><p>find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.<br>note:<br>all numbers will be positive integers.<br>the solution set must not contain duplicate combinations.</p>
<pre><code>example 1:
input: k = 3, n = 7
output: [[1,2,4]]

example 2:
input: k = 3, n = 9
output: [[1,2,6], [1,3,5], [2,3,4]]
</code></pre><pre><code class="python">class solution:
    def combinationsum3(self, k, n):
        ans = []
        cur = []
        def dfs(i):
            nonlocal k, n
            if len(cur) == k and sum(cur) == n:
                ans.append(cur[:])
                return
            for j in range(i, 10):
                if len(cur) &lt; k and sum(cur) + j &lt;= n:
                    cur.append(j)
                    dfs(j + 1)
                    del cur[-1]
        dfs(1)
        return ans
</code></pre>
<p>5刷：面经</p>
<h3 id="77-combinations-medium"><a href="#77-combinations-medium" class="headerlink" title="77. combinations (medium)"></a><a href="https://leetcode.com/problems/combinations/" target="_blank" rel="noopener">77. combinations (medium)</a></h3><p>given two integers n and k, return all possible combinations of k numbers out of 1 … n.</p>
<p>example:<br>input: n = 4, k = 2<br>output:<br>[<br>  [2,4],<br>  [3,4],<br>  [2,3],<br>  [1,2],<br>  [1,3],<br>  [1,4],<br>]</p>
<pre><code class="python">class solution:
    def combine(self, n: int, k: int) -&gt; list[list[int]]:
        ans = []
        cur = []
        def dfs(idx):
            if len(cur) == k:
                ans.append(cur[:])
                return
            for i in range(idx, n + 1):
                cur.append(i)
                dfs(i + 1)
                del cur[-1]
        dfs(1)
        return ans
</code></pre>
<p>三刷：面经：amazon</p>
<h3 id="131-palindrome-partitioning-medium"><a href="#131-palindrome-partitioning-medium" class="headerlink" title="131. palindrome partitioning (medium)"></a><a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="noopener">131. palindrome partitioning (medium)</a></h3><p>given a string s, partition s such that every substring of the partition is a palindrome.<br>return all possible palindrome partitioning of s.</p>
<p>example:<br>input: “aab”<br>output:<br>[<br>  [“aa”,”b”],<br>  [“a”,”a”,”b”]<br>]</p>
<pre><code class="python">class solution:
    def partition(self, s: str) -&gt; list[list[str]]:
        ans = []
        cur = []
        def dfs(idx):
            if idx == len(s):
                ans.append(cur[:])
                return
            for i in range(idx, len(s)):
                w = s[idx: i + 1]
                if w == w[::-1]:
                    cur.append(w)
                    dfs(i + 1)
                    del cur[-1]
        dfs(0)
        return ans
</code></pre>
<p>五刷：高频，o(n*(2^n))</p>
<h3 id="93-restore-ip-addresses-medium"><a href="#93-restore-ip-addresses-medium" class="headerlink" title="93. restore ip addresses (medium)"></a><a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener">93. restore ip addresses (medium)</a></h3><p>given a string containing only digits, restore it by returning all possible valid ip address combinations.</p>
<p>example:<br>input: “25525511135”<br>output: [“255.255.11.135”, “255.255.111.35”]</p>
<pre><code class="python">class solution:
    def restoreipaddresses(self, s: str) -&gt; list[str]:
        if len(s) &gt; 12:
            return []
        ans = []
        cur = []
        def dfs(idx):
            if idx == len(s) and len(cur) == 4:
                ans.append(&quot;.&quot;.join(cur))
                return
            if len(cur) &lt; 4:
                for i in range(1, 4):
                    if idx + i &lt;= len(s):
                        num = s[idx: idx + i]
                        if int(num) &lt;= 255 and num == str(int(num)):
                            cur.append(num)
                            dfs(idx + i)
                            del cur[-1]
        dfs(0)
        return ans     
</code></pre>
<p>九刷：高频。注意：查idx + i是否越界，查num里是否有前缀为0。时间复杂度是一件有趣的事情，正常情况下分割字符串是o(2^n)复杂度，但是ip地址是有限的，因此这个题有个常数的时间复杂度上限</p>
<h3 id="linc-680-split-string-easy"><a href="#linc-680-split-string-easy" class="headerlink" title="linc 680. split string (easy)"></a><a href="https://www.lintcode.com/problem/split-string/description" target="_blank" rel="noopener">linc 680. split string (easy)</a></h3><pre><code class="html">give a string, you can choose to split the string after one character or two adjacent characters, and make the string to be composed of only one character or two characters. output all possible results.

example
given the string &quot;123&quot;
return [[&quot;1&quot;,&quot;2&quot;,&quot;3&quot;],[&quot;12&quot;,&quot;3&quot;],[&quot;1&quot;,&quot;23&quot;]]
</code></pre>
<pre><code class="python">class solution:
    def splitstring(self, s):
        if len(s) == 0:
            return [[]]
        ans = []
        cur = []
        def dfs(idx):
            if idx == len(s):
                ans.append(cur[:])
                return
            for i in range(1, 3):
                if idx + i &lt;= len(s):
                    cur.append(s[idx:idx + i])
                    dfs(idx + i)
                    del cur[-1]
        dfs(0)
        return ans
</code></pre>
<p>四刷</p>
<h3 id="90-subsets-ii-medium"><a href="#90-subsets-ii-medium" class="headerlink" title="90. subsets ii (medium)"></a><a href="https://leetcode.com/problems/subsets-ii/description/" target="_blank" rel="noopener">90. subsets ii (medium)</a></h3><pre><code class="html">given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

note: the solution set must not contain duplicate subsets.

example:

input: [1,2,2]
output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
</code></pre>
<pre><code class="python">class solution:
    def subsetswithdup(self, nums: list[int]) -&gt; list[list[int]]:
        nums.sort()
        ans = []
        cur = []   
        used = [false for _ in range(len(nums))]
        def dfs(idx):
            ans.append(cur[:])
            for i in range(idx, len(nums)):
                if i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]:
                    continue
                cur.append(nums[i])
                used[i] = true
                dfs(i + 1)
                used[i] = false
                del cur[-1]

        dfs(0)
        return ans
</code></pre>
<p>无额外used数组空间：</p>
<pre><code class="python">class solution:
    def subsetswithdup(self, nums: list[int]) -&gt; list[list[int]]:
        nums.sort()
        ans = []
        cur = []        
        def dfs(idx):
            ans.append(cur[:])
            for i in range(idx, len(nums)):
                if i &gt; idx and nums[i] == nums[i - 1]:
                    continue
                cur.append(nums[i])
                dfs(i + 1)
                del cur[-1]

        dfs(0)
        return ans
</code></pre>
<p>六刷：高频，在47题：permutations ii中因为全排列没有idx这个参数，需要用到用额外空间的写法去重</p>
<h3 id="140-Word-Break-II-Hard"><a href="#140-Word-Break-II-Hard" class="headerlink" title="140. Word Break II (Hard)"></a><a href="https://leetcode.com/problems/word-break-ii/" target="_blank" rel="noopener">140. Word Break II (Hard)</a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.</p>
<p>Note:</p>
<p>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.<br>Example 1:</p>
<p>Input:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>Output:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]<br>Example 2:</p>
<p>Input:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>Output:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>Explanation: Note that you are allowed to reuse a dictionary word.<br>Example 3:</p>
<p>Input:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output:<br>[]</p>
<p>TLE:</p>
<pre><code class="python">class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&gt; List[str]:
        ans = []
        cur = []
        def dfs(idx):
            if idx == len(s):
                ans.append(&#39; &#39;.join(cur[:]))
            for i in range(idx, len(s)):
                w = s[idx:i + 1]
                if w in wordDict:
                    cur.append(w)
                    dfs(i + 1)
                    del cur[-1]      
        dfs(0)
        return ans
</code></pre>
<p>AC: dfs + memo</p>
<pre><code class="python">class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -&gt; List[str]:
        memo = {} 
        def dfs(s):
            if not s:
                return []
            if s in memo:
                return memo[s]
            res = []
            for w in wordDict:
                if s.startswith(w):
                    if w == s:
                        res.append(w)
                    else:
                        restW = dfs(s[len(w):])
                        for item in restW:
                            res.append(w + &#39; &#39; + item)
            memo[s] = res
            return res
        return dfs(s)
</code></pre>
<p>四刷：面经：Amazon。九章。TODO 时间空间复杂度</p>
<h2 id="Permutation-based-DFS-基于排列的深度优先搜索"><a href="#Permutation-based-DFS-基于排列的深度优先搜索" class="headerlink" title="Permutation based DFS - 基于排列的深度优先搜索"></a>Permutation based DFS - 基于排列的深度优先搜索</h2><h3 id="46-Permutations-Medium"><a href="#46-Permutations-Medium" class="headerlink" title="46. Permutations (Medium)"></a><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">46. Permutations (Medium)</a></h3><p>Given a collection of distinct integers, return all possible permutations.</p>
<p>Example:<br>Input: [1,2,3]<br>Output:<br>[<br>  [1,2,3],<br>  [1,3,2],<br>  [2,1,3],<br>  [2,3,1],<br>  [3,1,2],<br>  [3,2,1]<br>]</p>
<pre><code class="python">class Solution:
    def permute(self, nums):
        ans = []
        cur = []
        used = [False] * len(nums)
        def dfs():
            if len(cur) == len(nums):
                ans.append(cur[:])
                return
            for i in range(len(nums)):
                if not used[i]:
                    used[i] = True
                    cur.append(nums[i])
                    dfs()
                    del cur[-1]
                    used[i] = False
        dfs()
        return ans
</code></pre>
<p>九刷：高频, subset从idx开始往后扫，全排每一位都有可能放任意数字，因此要从第一位往后扫。这样就需要一个used的变量来记住哪一位已经被用过了</p>
<h3 id="47-Permutations-II-Medium"><a href="#47-Permutations-II-Medium" class="headerlink" title="47. Permutations II (Medium)"></a><a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="noopener">47. Permutations II (Medium)</a></h3><p>Given a collection of numbers that might contain duplicates, return all possible unique permutations.</p>
<p>Example:<br>Input: [1,1,2]<br>Output:<br>[<br>  [1,1,2],<br>  [1,2,1],<br>  [2,1,1]<br>]</p>
<pre><code class="python">class Solution:
    def permuteUnique(self, nums):
        if not nums:
            return []
        ans = []
        cur = []
        nums.sort()
        used = [False for _ in range(len(nums))]
        def dfs():
            if len(cur) == len(nums):
                ans.append(cur[:])
                return
            for i in range(len(nums)):
                if used[i] or (i &gt; 0 and nums[i] == nums[i - 1] and not used[i - 1]):
                    continue
                cur.append(nums[i])
                used[i] = True
                dfs()
                del cur[-1]
                used[i] = False
        dfs()
        return ans
</code></pre>
<p>八刷：高频，时间复杂度：O(n!)，关键：when a number has the same value as its previous, use this number only if previous is used</p>
<h3 id="22-Generate-Parentheses-Medium"><a href="#22-Generate-Parentheses-Medium" class="headerlink" title="22. Generate Parentheses (Medium)"></a><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="noopener">22. Generate Parentheses (Medium)</a></h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p>
<p>For example, given n = 3, a solution set is:<br>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p>
<pre><code class="python">class Solution:
    def generateParenthesis(self, n):
        ans = []
        cur = []
        def dfs(l, r):
            if l == r == n:
                ans.append(&#39;&#39;.join(cur))
                return
            if l &lt; n:
                cur.append(&#39;(&#39;)
                dfs(l + 1, r)
                del cur[-1]
            if r &lt; l:
                cur.append(&#39;)&#39;)
                dfs(l, r + 1)
                del cur[-1]
        dfs(0, 0)
        return ans
</code></pre>
<p>七刷：高频。TODO：时间复杂度分析</p>
<h3 id="51-N-Queens-Hard"><a href="#51-N-Queens-Hard" class="headerlink" title="51. N-Queens (Hard)"></a><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">51. N-Queens (Hard)</a></h3><pre><code class="html">The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other.
Given an integer n, return all distinct solutions to the n-queens puzzle.
Each solution contains a distinct board configuration of the n-queens&#39; placement, where &#39;Q&#39; and &#39;.&#39; both indicate a queen and an empty space respectively.

Example:

Input: 4
Output: [
 [&quot;.Q..&quot;,  // Solution 1
  &quot;...Q&quot;,
  &quot;Q...&quot;,
  &quot;..Q.&quot;],

 [&quot;..Q.&quot;,  // Solution 2
  &quot;Q...&quot;,
  &quot;...Q&quot;,
  &quot;.Q..&quot;]
]
Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above.
</code></pre>
<pre><code class="python">class Solution:
    def solveNQueens(self, n: int) -&gt; List[List[str]]:
        ans = []
        cur = []
        def dfs():
            if len(cur) == n:
                ans.append([&quot;.&quot; * i + &quot;Q&quot; + &quot;.&quot; * (n - i - 1) for i in cur])
                return
            for c in range(n):
                if c not in cur and legal(c):
                    cur.append(c)
                    dfs()
                    del cur[-1]
        def legal(nC):
            nR = len(cur)
            for r, c in enumerate(cur):
                if nR + nC == r + c or nR - nC == r - c:
                    return False
            return True
        dfs()
        return ans
</code></pre>
<p>四刷：高频。检查下一行的某列的合法性：举个栗子就能看出来，检查列就看此列是否已在cur中（皇后已在此列），检查/方向的对角线是坐标相加，检查\方向的对角线是坐标相减，行递增无需检查。时间：O(n^3)， 空间：O(n)</p>
<h2 id="Graph-based-DFS-基于图的深度优先搜索"><a href="#Graph-based-DFS-基于图的深度优先搜索" class="headerlink" title="Graph based DFS 基于图的深度优先搜索"></a>Graph based DFS 基于图的深度优先搜索</h2><h3 id="17-Letter-Combinations-of-a-Phone-Number-Medium"><a href="#17-Letter-Combinations-of-a-Phone-Number-Medium" class="headerlink" title="17. Letter Combinations of a Phone Number (Medium)"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number (Medium)</a></h3><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.<br>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br><img src="/images/leetcode_17_lett_1.png" alt="keypad example"><br>Example:<br>Input: “23”<br>Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].</p>
<p>Note:<br>Although the above answer is in lexicographical order, your answer could be in any order you want.</p>
<pre><code class="python">class Solution:
    def letterCombinations(self, digits: str) -&gt; List[str]:
        if not digits:
            return []
        kB = {&quot;2&quot;: &quot;abc&quot;, &quot;3&quot;: &quot;def&quot;, &quot;4&quot;: &quot;ghi&quot;, &quot;5&quot;: &quot;jkl&quot;, &quot;6&quot;: &quot;mno&quot;, &quot;7&quot;: &quot;pqrs&quot;, &quot;8&quot;: &quot;tuv&quot;, &quot;9&quot;: &quot;wxyz&quot;}
        ans = []
        cur = []
        def dfs(idx):
            if len(cur) == len(digits):
                ans.append(&quot;&quot;.join(cur))
                return
            for c in kB[digits[idx]]:
                cur.append(c)
                dfs(idx + 1)
                del cur[-1]
        dfs(0)
        return ans
</code></pre>
<p>五刷：高频</p>
<h3 id="79-Word-Search-Medium"><a href="#79-Word-Search-Medium" class="headerlink" title="79. Word Search (Medium)"></a><a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="noopener">79. Word Search (Medium)</a></h3><pre><code class="html">Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],
  [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],
  [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]
]

Given word = &quot;ABCCED&quot;, return true.
Given word = &quot;SEE&quot;, return true.
Given word = &quot;ABCB&quot;, return false.
</code></pre>
<pre><code class="python">class Solution:
    def exist(self, board: List[List[str]], word: str) -&gt; bool:
        ans = False
        m, n = len(board), len(board[0])
        def dfs(r, c, idx):
            nonlocal ans
            if idx == len(word):
                ans = True
                return
            if not ans and 0 &lt;= r &lt;= m - 1 and 0 &lt;= c &lt;= n - 1 and idx &lt;= len(word) - 1 and board[r][c] == word[idx]:
                tmp = board[r][c]
                board[r][c] = &#39;#&#39;
                for rD, cD in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                    dfs(r + rD, c + cD, idx + 1)
                board[r][c] = tmp
        for r in range(m):
            for c in range(n):
                dfs(r, c, 0)
        return ans
</code></pre>
<p>四刷：高频</p>
<h3 id="490-The-Maze-Medium-带锁"><a href="#490-The-Maze-Medium-带锁" class="headerlink" title="490. The Maze (Medium) 带锁"></a><a href="https://leetcode.com/problems/the-maze" target="_blank" rel="noopener">490. The Maze (Medium) 带锁</a></h3><p><a href="https://www.lintcode.com/problem/the-maze/description" target="_blank" rel="noopener">Lintcode 787. The Maze</a><br>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction.</p>
<p>Given the ball’s start position, the destination and the maze, determine whether the ball could stop at the destination.</p>
<p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.</p>
<p>Example 1</p>
<pre><code>Input 1: a maze represented by a 2D array
0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0
Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (4, 4)

Output: true
Explanation: One possible way is : left -&gt; down -&gt; left -&gt; down -&gt; right -&gt; down -&gt; right.
</code></pre><p><img src="https://leetcode.com/static/images/problemset/maze_1_example_1.png" alt="the maze example 1"></p>
<p>Example 2</p>
<pre><code>Input 1: a maze represented by a 2D array
0 0 1 0 0
0 0 0 0 0
0 0 0 1 0
1 1 0 1 1
0 0 0 0 0
Input 2: start coordinate (rowStart, colStart) = (0, 4)
Input 3: destination coordinate (rowDest, colDest) = (3, 2)

Output: false
Explanation: There is no way for the ball to stop at the destination.
</code></pre><p><img src="https://leetcode.com/static/images/problemset/maze_1_example_2.png" alt="the maze example 2"></p>
<p>Note:<br>1.There is only one ball and one destination in the maze.<br>2.Both the ball and the destination exist on an empty space, and they will not be at the same position initially.<br>3.The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.<br>4.The maze contains at least 2 empty spaces, and both the width and height of the maze won’t exceed 100.</p>
<pre><code class="python">class Solution(object):
    def hasPath(self, maze, start, destination):
        &quot;&quot;&quot;
        :type maze: List[List[int]]
        :type start: List[int]
        :type destination: List[int]
        :rtype: bool
        &quot;&quot;&quot;
        ans = False
        def dfs(r, c):
            nonlocal ans
            if [r, c] == destination:
                ans = True
                return
            maze[r][c] = -1
            for rd, cd in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nR, nC = r, c
                while 0 &lt;= nR + rd &lt;= len(maze) - 1 and 0 &lt;= nC + cd &lt;= len(maze[0]) - 1 and maze[nR + rd][nC + cd] != 1:
                    nR += rd
                    nC += cd
                if maze[nR][nC] != -1:
                    dfs(nR, nC)
        dfs(start[0], start[1])
        return ans
</code></pre>
<p>三刷：面经：Amazon。TODO: BFS</p>
<h3 id="417-Pacific-Atlantic-Water-Flow-Medium"><a href="#417-Pacific-Atlantic-Water-Flow-Medium" class="headerlink" title="417. Pacific Atlantic Water Flow (Medium)"></a><a href="https://leetcode.com/problems/pacific-atlantic-water-flow/" target="_blank" rel="noopener">417. Pacific Atlantic Water Flow (Medium)</a></h3><p>Given an m x n matrix of non-negative integers representing the height of each unit cell in a continent, the “Pacific ocean” touches the left and top edges of the matrix and the “Atlantic ocean” touches the right and bottom edges.<br>Water can only flow in four directions (up, down, left, or right) from a cell to another one with height equal or lower.<br>Find the list of grid coordinates where water can flow to both the Pacific and Atlantic ocean.</p>
<p>Note:<br>The order of returned grid coordinates does not matter.<br>Both m and n are less than 150.</p>
<pre><code>Example:
Given the following 5x5 matrix:
  Pacific ~   ~   ~   ~   ~
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * Atlantic
Return:
[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (positions with parentheses in above matrix).
</code></pre><pre><code class="python">class Solution:
    def pacificAtlantic(self, matrix: List[List[int]]) -&gt; List[List[int]]:
        if not matrix:
            return []
        m, n = len(matrix), len(matrix[0])
        reach_p = [[False for _ in range(n)] for _ in range(m)]
        reach_a = [[False for _ in range(n)] for _ in range(m)]
        def dfs(r, c, reach):
            reach[r][c] = True
            for rd, cd in [(-1, 0), (1, 0), (0, 1), (0, -1)]:
                nr, nc = r + rd, c + cd
                if 0 &lt;= nr &lt;= m - 1 and 0 &lt;= nc &lt;= n - 1 and matrix[nr][nc] &gt;= matrix[r][c] and not reach[nr][nc]:
                    dfs(nr, nc, reach)
        for r in range(m):
            dfs(r, 0, reach_p)
            dfs(r, n - 1, reach_a)
        for c in range(n):
            dfs(0, c, reach_p)
            dfs(m - 1, c, reach_a)
        return [[r, c] for r in range(m) for c in range(n) if reach_p[r][c] == True and reach_a[r][c] == True]
</code></pre>
<p>三刷：面经：Cruise Automation。dfs：从两个海接触的四条边上的点为起点往内陆灌，返回两个海都能灌到的点坐标 TODO bfs</p>
<h3 id="399-Evaluate-Division-Medium"><a href="#399-Evaluate-Division-Medium" class="headerlink" title="399. Evaluate Division (Medium)"></a><a href="https://leetcode.com/problems/evaluate-division/" target="_blank" rel="noopener">399. Evaluate Division (Medium)</a></h3><p>Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.</p>
<p>Example:<br>Given a / b = 2.0, b / c = 3.0.<br>queries are: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .<br>return [6.0, 0.5, -1.0, 1.0, -1.0 ].</p>
<p>The input is: vector&lt;pair&lt;string, string&gt;&gt; equations, vector<double>&amp; values, vector&lt;pair&lt;string, string&gt;&gt; queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return vector<double>.</p>
<p>According to the example above:<br>equations = [ [“a”, “b”], [“b”, “c”] ],<br>values = [2.0, 3.0],<br>queries = [ [“a”, “c”], [“b”, “a”], [“a”, “e”], [“a”, “a”], [“x”, “x”] ].</p>
<p>The input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.</p>
<p>DFS:</p>
<pre><code class="python">class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&gt; List[float]:
        ans = []
        from collections import defaultdict 
        pMap, vMap = defaultdict(list), defaultdict(list)
        for [s, e], val in zip(equations, values):
            pMap[s].append(e)
            pMap[e].append(s)
            vMap[(s, e)] = val
            vMap[(e, s)] = 1.0 / val
        def dfs(s, e, cur):
            nonlocal res
            if s not in pMap or e not in pMap:
                return
            if s == e:
                res = cur
                return
            for nS in pMap[s]:
                if nS not in visited:
                    visited.add(nS)
                    dfs(nS, e, cur * vMap[(s, nS)])
                    visited.remove(nS)
        for s, e in queries:
            visited = set()
            res = -1.0
            dfs(s, e, 1.0)
            ans.append(res)
        return ans
</code></pre>
<p>BFS:</p>
<pre><code class="python">class Solution:
    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -&gt; List[float]:
        from collections import defaultdict
        graph = defaultdict(list)
        for [s, e], val in zip(equations, values):
            graph[s].append((e, val))
            graph[e].append((s, 1.0 / val))
        def bfs(s, e):
            if s not in graph:
                return -1.0
            q = [(s, 1.0)]
            visited = set()
            while q:
                cur, product = q.pop(0)
                if cur == e:
                    return product
                visited.add(cur)
                for nS, val in graph[cur]:
                    if nS not in visited:
                        q.append((nS, val * product))
            return -1.0
        return [bfs(s, e) for s, e in queries]
</code></pre>
<p>2刷：面经：头条。Currency Calculator一种题，先build graph，再用BFS寻最短路径的乘积</p>
<h3 id="332-Reconstruct-Itinerary-Medium"><a href="#332-Reconstruct-Itinerary-Medium" class="headerlink" title="332. Reconstruct Itinerary (Medium)"></a><a href="https://leetcode.com/problems/reconstruct-itinerary/" target="_blank" rel="noopener">332. Reconstruct Itinerary (Medium)</a></h3><p>Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK.</p>
<p>Note:<br>If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].<br>All airports are represented by three capital letters (IATA code).<br>You may assume all tickets form at least one valid itinerary.</p>
<p>Example 1:<br>Input: [[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]<br>Output: [“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]</p>
<p>Example 2:<br>Input: [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]<br>Output: [“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]<br>Explanation: Another possible reconstruction is [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”].<br>             But it is larger in lexical order.</p>
<pre><code class="python">class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:
        from collections import defaultdict
        flights = defaultdict(list)
        for t in tickets:
            flights[t[0]].append(t[1])
        for k in flights:
            flights[k].sort()
        ans = [&quot;JFK&quot;]
        self.dfs(&quot;JFK&quot;, flights, ans, len(tickets))
        return ans
    def dfs(self, departure, flights, path, numTix):
        if departure not in flights:
            return
        arrival = flights[departure]
        for i, a in enumerate(arrival):
            path.append(a)
            del arrival[i]
            self.dfs(a, flights, path, numTix)
            if len(path) == numTix + 1:
                return
            arrival.insert(i, a)
            del path[-1]
</code></pre>
<p>一刷：这个if len(path) == numTix + 1必须在递归调用后面来查看是否已满足需求，即不剪枝 todo：没有100%的理解</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h2><h3 id="LinC-6-Merge-Two-Sorted-Arrays-Easy"><a href="#LinC-6-Merge-Two-Sorted-Arrays-Easy" class="headerlink" title="LinC 6. Merge Two Sorted Arrays (Easy)"></a><a href="https://www.lintcode.com/problem/merge-two-sorted-arrays/description" target="_blank" rel="noopener">LinC 6. Merge Two Sorted Arrays (Easy)</a></h3><pre><code class="html">Merge two given sorted integer array A and B into a new sorted integer array.

Example
A=[1,2,3,4]

B=[2,4,5,6]

return [1,2,2,3,4,4,5,6]

Challenge
How can you optimize your algorithm if one array is very large and the other is very small?
</code></pre>
<p>思路：热身题，直接做</p>
<pre><code class="python">class Solution:
    &quot;&quot;&quot;
    @param A: sorted integer array A
    @param B: sorted integer array B
    @return: A new sorted integer array
    &quot;&quot;&quot;
    def mergeSortedArray(self, A, B):
        # write your code here
        ans = []
        indexA = 0
        indexB = 0
        indexC = 0
        while indexC &lt; len(A) + len(B):
            if indexA == len(A) or indexB == len(B):
                if indexA == len(A):
                    ans.append(B[indexB])
                    indexB += 1
                else:
                    ans.append(A[indexA])
                    indexA += 1
            else:
                if A[indexA] &lt; B[indexB]:
                    ans.append(A[indexA])
                    indexA += 1
                else:
                    ans.append(B[indexB])
                    indexB += 1
            indexC += 1
        return ans
</code></pre>
<p>总结：非常值得刷的一道热身题， 需要考虑两个 array 越界的问题。看了下答案用三个 while 循环也可以。</p>
<h3 id="88-Merge-Sorted-Array-Easy"><a href="#88-Merge-Sorted-Array-Easy" class="headerlink" title="88. Merge Sorted Array (Easy)"></a><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">88. Merge Sorted Array (Easy)</a></h3><pre><code class="html">Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

Note:

The number of elements initialized in nums1 and nums2 are m and n respectively.
You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.
Example:

Input:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

Output: [1,2,2,3,5,6]
</code></pre>
<p>思路：直觉上想不太出来怎么不创建新的存储空间把小数组 merge 到大数组里。看了答案，如果 nums1 后面空着这么些空，就从后面开始填。哎，曾经是能自主想的出的。。。正着困难的话就反着试试</p>
<pre><code class="python">class Solution(object):
    def merge(self, nums1, m, nums2, n):
        &quot;&quot;&quot;
        :type nums1: List[int]
        :type m: int
        :type nums2: List[int]
        :type n: int
        :rtype: void Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        if len(nums2) == 0:
            return
        if len(nums1) == len(nums2):
            for i in range(len(nums2)):
                nums1[i] = nums2[i]
            return
        index1 = m - 1
        index2 = n - 1
        index3 = len(nums1) - 1
        while index3 &gt;= 0 and index2 &gt;= 0:
            if index1 &lt; 0:
                nums1[index3] = nums2[index2]
                index2 -= 1
            else:
                if nums1[index1] &lt; nums2[index2]:
                    nums1[index3] = nums2[index2]
                    index2 -= 1
                else:
                    nums1[index3] = nums1[index1]
                    index1 -= 1
            index3 -= 1
</code></pre>
<p>总结：虽然是 easy 题，要考虑情况：1.nums1 和 nums2 一样大的话需要逐个考过去；2.index2 如果走到最前面就可以结束了。注意题目的输入包含了 m 和 n 要利用好</p>
<p>高频：</p>
<pre><code class="python">class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify nums1 in-place instead.
        &quot;&quot;&quot;
        if m == 0:
            nums1[:] = nums2[:]
        i1 = m - 1
        i2 = n - 1
        im = m + n - 1
        while i1 &gt;= 0 and i2 &gt;= 0:
            if nums1[i1] &lt; nums2[i2]:
                nums1[im] = nums2[i2]
                i2 -= 1
            else:
                nums1[im] = nums1[i1]
                i1 -= 1
            im -= 1
        if i1 &lt; 0:
            nums1[:i2 + 1] = nums2[:i2 + 1]
</code></pre>
<p>总结：代码简化，也更好理解一些，算法还是原来的，从nums1后往前填��注意最后如果nums1都填完了要把nums2剩余的都天过去nums1[:i2 <strong>+ 1</strong>] = nums2[:i2 <strong>+ 1</strong>]</p>
<h3 id="73-Set-Matrix-Zeroes-Medium"><a href="#73-Set-Matrix-Zeroes-Medium" class="headerlink" title="73. Set Matrix Zeroes (Medium)"></a><a href="https://leetcode.com/problems/set-matrix-zeroes/" target="_blank" rel="noopener">73. Set Matrix Zeroes (Medium)</a></h3><pre><code class="html">Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.

Example 1:

Input:
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
Output:
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
Example 2:

Input:
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
Output:
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
Follow up:

A straight forward solution using O(mn) space is probably a bad idea.
A simple improvement uses O(m + n) space, but still not the best solution.
Could you devise a constant space solution?
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        r0 = set()
        c0 = set()

        for r in range(len(matrix)):
            for c in range(len(matrix[0])):
                if matrix[r][c] == 0:
                    r0.add(r)
                    c0.add(c)

        for r in r0:
            for c in range(len(matrix[0])):
                matrix[r][c] = 0

        for c in c0:
            for r in range(len(matrix)):
                matrix[r][c] = 0
</code></pre>
<p>总结：O(m+n)空间的解法<br>二刷：</p>
<pre><code class="python">class Solution:
    def setZeroes(self, matrix: List[List[int]]) -&gt; None:
        is1stRZ, is1stCZ = True if 0 in matrix[0] else False, True if 0 in list(zip(*matrix))[0] else False
        for i, r in enumerate(matrix):
            for j, c in enumerate(r):
                if i and j and c == 0:
                    matrix[i][0] = 0
                    matrix[0][j] = 0
        m, n = len(matrix), len(matrix[0])
        for i in range(1, m):
            if matrix[i][0] == 0:
                matrix[i] = [0] * n
        for j in range(1, n):
            if matrix[0][j] == 0:
                for i in range(1, m):
                    matrix[i][j] = 0
        if is1stRZ:
            matrix[0] = [0] * n
        if is1stCZ:
            for i in range(m):
                matrix[i][0] = 0
</code></pre>
<p>总结：O(1)空间</p>
<h3 id="56-Merge-Intervals-Medium"><a href="#56-Merge-Intervals-Medium" class="headerlink" title="56. Merge Intervals (Medium)"></a><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">56. Merge Intervals (Medium)</a></h3><pre><code class="html">Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:
        if not intervals:
            return []
        intervals.sort(key = lambda x: x[0])
        ans = []
        cur = intervals[0]
        for i in range(1, len(intervals)):
            if intervals[i][0] &lt;= cur[1]:
                cur[1] = max(intervals[i][1], cur[1])
            else:
                ans.append(cur[:])
                cur = intervals[i]
        ans.append(cur)
        return ans
</code></pre>
<p>面经：Cruise。…cur[1] = <strong>max(intervals[i][1], cur[1])</strong>…</p>
<h3 id="LinC-839-Merge-Two-Sorted-Interval-Lists-Easy"><a href="#LinC-839-Merge-Two-Sorted-Interval-Lists-Easy" class="headerlink" title="LinC 839. Merge Two Sorted Interval Lists (Easy)"></a><a href="https://www.lintcode.com/problem/merge-two-sorted-interval-lists/description" target="_blank" rel="noopener">LinC 839. Merge Two Sorted Interval Lists (Easy)</a></h3><pre><code class="html">Merge two sorted (ascending) lists of interval and return it as a new sorted list. The new sorted list should be made by splicing together the intervals of the two lists and sorted in ascending order.

The intervals in the given list do not overlap.
The intervals in different lists may overlap.
Example
Given list1 = [(1,2),(3,4)] and list2 = [(2,3),(5,6)], return [(1,4),(5,6)].
</code></pre>
<p>思路：思路跟上题 merge interval一样，可以不做</p>
<pre><code class="python">&quot;&quot;&quot;
Definition of Interval.
class Interval(object):
    def __init__(self, start, end):
        self.start = start
        self.end = end
&quot;&quot;&quot;
class Solution:
    &quot;&quot;&quot;
    @param list1: one of the given list
    @param list2: another list
    @return: the new sorted list of interval
    &quot;&quot;&quot;
    def mergeTwoInterval(self, list1, list2):
        # write your code here
        if not list1:
            return list2
        if not list2:
            return list1
        list3 = list1 + list2
        list3.sort(key=lambda x: x.start)
        ans = [list3[0]]
        for i in range(1, len(list3)):
            if list3[i].start &lt;= ans[-1].end:
                ans[-1].end = max(list3[i].end, ans[-1].end)
            else:
                ans.append(list3[i])
        return ans
</code></pre>
<p>二刷：删掉一刷代码，统一思路</p>
<h3 id="228-Summary-Ranges-Medium"><a href="#228-Summary-Ranges-Medium" class="headerlink" title="228. Summary Ranges (Medium)"></a><a href="https://leetcode.com/problems/summary-ranges/description/" target="_blank" rel="noopener">228. Summary Ranges (Medium)</a></h3><pre><code class="html">Given a sorted integer array without duplicates, return the summary of its ranges.

Example 1:

Input:  [0,1,2,4,5,7]
Output: [&quot;0-&gt;2&quot;,&quot;4-&gt;5&quot;,&quot;7&quot;]
Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.
Example 2:

Input:  [0,2,3,4,6,8,9]
Output: [&quot;0&quot;,&quot;2-&gt;4&quot;,&quot;6&quot;,&quot;8-&gt;9&quot;]
Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.
</code></pre>
<pre><code class="python"># 先写 O(n) 的再优化
class Solution:
    def summaryRanges(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: List[str]
        &quot;&quot;&quot;
        if not nums:
            return []
        ans, start = [], 0
        def addToRes(l, r):
            if l == r:
                ans.append(str(nums[l]))
            else:
                ans.append(f&quot;{str(nums[l])}-&gt;{str(nums[r])}&quot;)
        for i in range(len(nums) - 1):
            if nums[i] != nums[i + 1] - 1:
                addToRes(start, i)
                start = i + 1
        addToRes(start, len(nums) - 1)
        return ans
</code></pre>
<p>二刷：删掉了一刷的思路，代码和总结。 ..start = 0…def addToRes(l, r):…start = i + 1…</p>
<h3 id="67-Add-Binary-Easy"><a href="#67-Add-Binary-Easy" class="headerlink" title="67. Add Binary (Easy)"></a><a href="https://leetcode.com/problems/add-binary/" target="_blank" rel="noopener">67. Add Binary (Easy)</a></h3><pre><code class="html">Given two binary strings, return their sum (also a binary string).

The input strings are both non-empty and contains only characters 1 or 0.

Example 1:

Input: a = &quot;11&quot;, b = &quot;1&quot;
Output: &quot;100&quot;
Example 2:

Input: a = &quot;1010&quot;, b = &quot;1011&quot;
Output: &quot;10101&quot;
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def addBinary(self, a: str, b: str) -&gt; str:
        m = len(a)
        n = len(b)
        l = max(m, n)
        i = 1
        carry = 0
        ans = &quot;&quot;
        while i &lt;= l:
            if i &lt;= m and i &lt;= n:
                val = int(a[-i]) + int(b[-i]) + carry
            elif i &lt;= m:
                val = int(a[-i]) + carry
            elif i &lt;= n:
                val = int(b[-i]) + carry
            if val &gt; 1:
                carry = 1
            else:
                carry = 0
            ans = str(val % 2) + ans
            i += 1
        if carry == 1:
            ans = &quot;1&quot; + ans
        return ans
</code></pre>
<p>总结：…<strong>i = 1</strong>…while i <strong>&lt;=</strong> l:…if val &gt; 1: carry = 1; else: carry = 0; ans = str(val % 2) + ans; i += 1…</p>
<h3 id="12-Integer-to-Roman-Medium"><a href="#12-Integer-to-Roman-Medium" class="headerlink" title="12. Integer to Roman (Medium)"></a><a href="https://leetcode.com/problems/integer-to-roman/" target="_blank" rel="noopener">12. Integer to Roman (Medium)</a></h3><pre><code class="html">Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one&#39;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: 3
Output: &quot;III&quot;
Example 2:

Input: 4
Output: &quot;IV&quot;
Example 3:

Input: 9
Output: &quot;IX&quot;
Example 4:

Input: 58
Output: &quot;LVIII&quot;
Explanation: L = 50, V = 5, III = 3.
Example 5:

Input: 1994
Output: &quot;MCMXCIV&quot;
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def intToRoman(self, num: int) -&gt; str:
        n = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        l = [&quot;M&quot;, &quot;CM&quot;, &quot;D&quot;, &quot;CD&quot;, &quot;C&quot;, &quot;XC&quot;, &quot;L&quot;, &quot;XL&quot;, &quot;X&quot;, &quot;IX&quot;, &quot;V&quot;, &quot;IV&quot;, &quot;I&quot;]
        ans = &quot;&quot;
        for i, v in enumerate(n):
            if num == 0:
                return ans
            t = num // v
            ans += l[i] * t
            num %= v
        return ans
</code></pre>
<p>总结：有了n和l俩数组就是easy了</p>
<h3 id="43-Multiply-Strings-Medium"><a href="#43-Multiply-Strings-Medium" class="headerlink" title="43. Multiply Strings (Medium)"></a><a href="https://leetcode.com/problems/multiply-strings/" target="_blank" rel="noopener">43. Multiply Strings (Medium)</a></h3><pre><code class="html">Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.

Example 1:

Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;
Output: &quot;6&quot;
Example 2:

Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;
Output: &quot;56088&quot;
Note:

The length of both num1 and num2 is &lt; 110.
Both num1 and num2 contain only digits 0-9.
Both num1 and num2 do not contain any leading zero, except the number 0 itself.
You must not use any built-in BigInteger library or convert the inputs to integer directly.
</code></pre>
<pre><code class="python">class Solution:
    def multiply(self, num1: str, num2: str) -&gt; str:
        res = [0 for _ in range(len(num1) + len(num2))]
        num1 = num1[::-1]
        num2 = num2[::-1]
        for i in range(len(num1)):
            for j in range(len(num2)):
                res[i + j] += int(num1[i]) * int(num2[j])

        for i in range(len(res)):
            d = res[i] % 10
            c = res[i] // 10
            if i &lt; len(res) - 1:
                res[i + 1] += c
            res[i] = d

        res.reverse()
        while res[0] == 0 and len(res) &gt; 1:
            del res[0]
        return &quot;&quot;.join(str(i) for i in res)
</code></pre>
<p>高频：…for i in range(len(res)):…res[i] = d…<strong>while</strong> res[0] == 0 and len(res) &gt; 1:…</p>
<h3 id="128-Longest-Consecutive-Sequence-Medium"><a href="#128-Longest-Consecutive-Sequence-Medium" class="headerlink" title="128. Longest Consecutive Sequence (Medium)"></a><a href="https://leetcode.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. Longest Consecutive Sequence (Medium)</a></h3><pre><code class="html">Given an unsorted array of integers, find the length of the longest consecutive elements sequence.

Your algorithm should run in O(n) complexity.

Example:

Input: [100, 4, 200, 1, 3, 2]
Output: 4
Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.
</code></pre>
<pre><code class="python">class Solution:
    def longestConsecutive(self, nums: List[int]) -&gt; int:
        nums = set(nums)
        ans = 0
        for n in nums:
            if n - 1 not in nums:
                m = n + 1
                while m in nums:
                    m += 1
                ans = max(ans, m - n)
        return ans
</code></pre>
<p>高频：不明白为什么要作为高频题，除了惊叹于答案之神乎其技， 几乎学不到任何东西</p>
<h3 id="66-Plus-One-Easy"><a href="#66-Plus-One-Easy" class="headerlink" title="66. Plus One (Easy)"></a><a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">66. Plus One (Easy)</a></h3><pre><code class="html">Given a non-empty array of digits representing a non-negative integer, plus one to the integer.

The digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.

You may assume the integer does not contain any leading zero, except the number 0 itself.

Example 1:

Input: [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Example 2:

Input: [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
</code></pre>
<pre><code class="python">class Solution:
    def plusOne(self, digits: List[int]) -&gt; List[int]:
        digits.reverse()
        c = 0
        for i, d in enumerate(digits):
            if i == 0:
                d += 1
            else:
                d += c
            c = d // 10
            d = d % 10
            digits[i] = d
        if c &gt; 0:
            digits.append(1)
        return digits[::-1]
</code></pre>
<p>高频</p>
<h3 id="9-Palindrome-Number-Easy"><a href="#9-Palindrome-Number-Easy" class="headerlink" title="9. Palindrome Number (Easy)"></a><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="noopener">9. Palindrome Number (Easy)</a></h3><pre><code class="html">Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Example 1:

Input: 121
Output: true
Example 2:

Input: -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
Follow up:

Coud you solve it without converting the integer to a string?
</code></pre>
<pre><code class="python">class Solution:
    def isPalindrome(self, x: int) -&gt; bool:
        if x &lt; 0:
            return False
        ox = x
        nx = 0
        while x:
            t = x % 10
            nx = nx * 10 + t
            x //= 10
        return nx == ox
</code></pre>
<p>高频：…nx = nx * 10 + t…</p>
<h3 id="59-Spiral-Matrix-II-Medium"><a href="#59-Spiral-Matrix-II-Medium" class="headerlink" title="59. Spiral Matrix II (Medium)"></a><a href="https://leetcode.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">59. Spiral Matrix II (Medium)</a></h3><pre><code class="html">Given a positive integer n, generate a square matrix filled with elements from 1 to n2 in spiral order.

Example:

Input: 3
Output:
[
 [ 1, 2, 3 ],
 [ 8, 9, 4 ],
 [ 7, 6, 5 ]
]
</code></pre>
<pre><code class="python">class Solution:
    def generateMatrix(self, n: int) -&gt; List[List[int]]:
        ans = [[0] * n for _ in range(n)]
        mode, r, c, circle = 0, 0, 0, 0
        for i in range(1, n * n + 1):
            ans[r][c] = i
            if mode == 0:
                c += 1
                if c == n - 1 - circle:
                    mode = 1
            elif mode == 1:
                r += 1
                if r == n - 1 - circle:
                    mode = 2
            elif mode == 2:
                c -= 1
                if c == circle:
                    mode = 3
            else:
                r -= 1
                if r == circle + 1:
                    mode = 0
                    circle += 1
        return ans
</code></pre>
<p>高频：…if c == n - 1 - circle:…if r == n - 1 - circle:…if c == circle:…if r = circle + 1:…</p>
<h3 id="48-Rotate-Image-Medium"><a href="#48-Rotate-Image-Medium" class="headerlink" title="48. Rotate Image (Medium)"></a><a href="https://leetcode.com/problems/rotate-image/" target="_blank" rel="noopener">48. Rotate Image (Medium)</a></h3><pre><code class="html">You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
Note:
You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.

Example 1:
Given input matrix =
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

rotate the input matrix in-place such that it becomes:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
Example 2:

Given input matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
],

rotate the input matrix in-place such that it becomes:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
</code></pre>
<pre><code class="python">class Solution:
    def rotate(self, matrix: List[List[int]]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify matrix in-place instead.
        &quot;&quot;&quot;
        n = len(matrix)
        matrix.reverse()
        for r in range(n):
            for c in range(r, n):
                matrix[r][c], matrix[c][r] = matrix[c][r], matrix[r][c]
</code></pre>
<p>高频：需要懂得顺时针转就是上下翻转以后对角线翻转，逆时针转就是左右翻转以后对角线翻转。懂list(zip(*list))的话就是一行代码</p>
<h3 id="54-Spiral-Matrix-Medium"><a href="#54-Spiral-Matrix-Medium" class="headerlink" title="54. Spiral Matrix (Medium)"></a><a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">54. Spiral Matrix (Medium)</a></h3><pre><code class="html">Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.

Example 1:

Input:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]
Output: [1,2,3,6,9,8,7,4,5]
Example 2:

Input:
[
  [1, 2, 3, 4],
  [5, 6, 7, 8],
  [9,10,11,12]
]
Output: [1,2,3,4,8,12,11,10,9,5,6,7]
</code></pre>
<pre><code class="python">class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -&gt; List[int]:
        if len(matrix) == 0:
            return []
        mode, circle, r, c = 0, 0, 0, 0
        m, n = len(matrix), len(matrix[0])
        ans = []
        for _ in range(m * n):
            ans.append(matrix[r][c])
            if mode == 0:
                if c == n - 1 - circle:
                    mode = 1
                    r += 1
                else:
                    c += 1
            elif mode == 1:
                if r == m - 1 - circle:
                    mode = 2
                    c -= 1
                else:
                    r += 1
            elif mode == 2:
                if c == circle:
                    mode = 3
                    r -= 1
                else:
                    c -= 1
            elif mode == 3:
                if r == circle + 1:
                    mode = 0
                    circle += 1
                    c += 1
                else:
                    r -= 1
        return ans
</code></pre>
<p>高频：相比其他答案，更喜欢这个sprial matrix II用过的模板，不同之处是这里要先处理转向，用来应对[[1],[2]]这种输入</p>
<h3 id="68-Text-Justification-Hard"><a href="#68-Text-Justification-Hard" class="headerlink" title="68. Text Justification (Hard)"></a><a href="https://leetcode.com/problems/text-justification/" target="_blank" rel="noopener">68. Text Justification (Hard)</a></h3><pre><code class="html">Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.

You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces &#39; &#39; when necessary so that each line has exactly maxWidth characters.

Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.

For the last line of text, it should be left justified and no extra space is inserted between words.

Note:

A word is defined as a character sequence consisting of non-space characters only.
Each word&#39;s length is guaranteed to be greater than 0 and not exceed maxWidth.
The input array words contains at least one word.
Example 1:

Input:
words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]
maxWidth = 16
Output:
[
   &quot;This    is    an&quot;,
   &quot;example  of text&quot;,
   &quot;justification.  &quot;
]
Example 2:

Input:
words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]
maxWidth = 16
Output:
[
  &quot;What   must   be&quot;,
  &quot;acknowledgment  &quot;,
  &quot;shall be        &quot;
]
Explanation: Note that the last line is &quot;shall be    &quot; instead of &quot;shall     be&quot;,
             because the last line must be left-justified instead of fully-justified.
             Note that the second line is also left-justified becase it contains only one word.
Example 3:

Input:
words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;,
         &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]
maxWidth = 20
Output:
[
  &quot;Science  is  what we&quot;,
  &quot;understand      well&quot;,
  &quot;enough to explain to&quot;,
  &quot;a  computer.  Art is&quot;,
  &quot;everything  else  we&quot;,
  &quot;do                  &quot;
]
</code></pre>
<pre><code class="python">class Solution:
    def fullJustify(self, words: List[str], maxWidth: int) -&gt; List[str]:
        ans, line, letter_count = [], [], 0
        for w in words:
            if letter_count + len(w) + len(line) &gt; maxWidth:
                for i in range(maxWidth - letter_count):
                    line[i % (len(line) - 1 or 1)] += &#39; &#39;
                ans.append(&#39;&#39;.join(line))
                line = []
                letter_count = 0
            line += [w]
            letter_count += len(w)
        ans.append(&#39; &#39;.join(line).ljust(maxWidth))
        return ans
</code></pre>
<p>高频：需要知道很巧妙的round robin填空格的方法：…line[i % (len(line) - 1 or 1)] += ‘ ‘…，str.ljust(width[, fillchar])默认填空格</p>
<h3 id="36-Valid-Sudoku-Medium"><a href="#36-Valid-Sudoku-Medium" class="headerlink" title="36. Valid Sudoku (Medium)"></a><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">36. Valid Sudoku (Medium)</a></h3><p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:<br>Each row must contain the digits 1-9 without repetition.<br>Each column must contain the digits 1-9 without repetition.<br>Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.<br>A partially filled sudoku which is valid.<br>The Sudoku board could be partially filled, where empty cells are filled with the character ‘.’.</p>
<pre><code>Example 1:
Input:
[
  [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
Output: true

Example 2:
Input:
[
  [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;],
  [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;],
  [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;],
  [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;],
  [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;],
  [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]
]
Output: false
Explanation: Same as Example 1, except with the 5 in the top left corner being
    modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.
</code></pre><p>Note:<br>A Sudoku board (partially filled) could be valid but is not necessarily solvable.<br>Only the filled cells need to be validated according to the mentioned rules.<br>The given board contain only digits 1-9 and the character ‘.’.<br>The given board size is always 9x9.</p>
<pre><code class="python">class Solution:
    def isValidSudoku(self, board: List[List[str]]) -&gt; bool:
        #check every row
        for r in board:
            if not self.validate(r):
                return False
        #check every col
        for c in zip(*board):
            if not self.validate(list(c)):
                return False
        #check every 3x3
        for dr in [0, 3, 6]:
            for dc in [0, 3, 6]:
                flat = []
                for r in range(0, 3):
                    for c in range(0, 3):
                        flat.append(board[r + dr][c + dc])
                if not self.validate(flat):
                    return False
        return True
    def validate(self, r):
        visited = set()
        for c in r:
            if c != &quot;.&quot;:
                if c in visited:
                    return False
                else:
                    visited.add(c)
        return True
</code></pre>
<p>高频, 面经：维萨。*用来unpack二维数组，zip(*board)用来返回一个用每行同一列位置的元素拼成的新的tuple的iterator</p>
<h3 id="38-Count-and-Say-Easy"><a href="#38-Count-and-Say-Easy" class="headerlink" title="38. Count and Say (Easy)"></a><a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="noopener">38. Count and Say (Easy)</a></h3><pre><code class="html">The count-and-say sequence is the sequence of integers with the first five terms as following:

1.     1
2.     11
3.     21
4.     1211
5.     111221
1 is read off as &quot;one 1&quot; or 11.
11 is read off as &quot;two 1s&quot; or 21.
21 is read off as &quot;one 2, then one 1&quot; or 1211.

Given an integer n where 1 ≤ n ≤ 30, generate the nth term of the count-and-say sequence.
Note: Each term of the sequence of integers will be represented as a string.

Example 1:

Input: 1
Output: &quot;1&quot;
Example 2:

Input: 4
Output: &quot;1211&quot;
</code></pre>
<p>用itertools.groupby():</p>
<pre><code class="python">class Solution:
    def countAndSay(self, n: int) -&gt; str:
        ans = &quot;1&quot;
        for i in range(n - 1):
            t = &quot;&quot;
            for d, g in itertools.groupby(ans):
                cnt = len(list(g))
                t += str(cnt) + str(d)
            ans = t
        return ans
</code></pre>
<p>不用groupby:</p>
<pre><code class="python">class Solution:
    def countAndSay(self, n: int) -&gt; str:
        ans = &quot;1&quot;
        for i in range(n - 1):
            res = &quot;&quot;
            t = ans + &quot;#&quot;
            cnt = 1
            for i in range(len(t) - 1):
                if t[i] == t[i + 1]:
                    cnt += 1
                else:
                    res += str(cnt) + t[i]
                    cnt = 1
            ans = res
        return ans
</code></pre>
<p>高频：题目描述不是很清楚，用groupby：…for d, g in itertools.groupby():…。不用groupby：…res = “”; t = ans + “#”…</p>
<h3 id="14-Longest-Common-Prefix-Easy"><a href="#14-Longest-Common-Prefix-Easy" class="headerlink" title="14. Longest Common Prefix (Easy)"></a><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. Longest Common Prefix (Easy)</a></h3><pre><code class="html">Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string &quot;&quot;.

Example 1:

Input: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]
Output: &quot;fl&quot;
Example 2:

Input: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]
Output: &quot;&quot;
Explanation: There is no common prefix among the input strings.
Note:

All given inputs are in lowercase letters a-z.
</code></pre>
<pre><code class="python">class Solution:
    def longestCommonPrefix(self, strs: List[str]) -&gt; str:
        if not strs:
            return &quot;&quot;
        ans = strs[0]
        for i in range(1, len(strs)):
            if not ans:
                return &quot;&quot;
            else:
                j = 0
                while j &lt; len(ans) and j &lt; len(strs[i]) and ans[j] == strs[i][j]:
                    j += 1
                ans = ans[:j]
        return ans
</code></pre>
<p>高频：<br>面经：Quora。删掉了高频的总结，换成我自己想出来的解法。</p>
<h3 id="119-Pascal’s-Triangle-II-Easy"><a href="#119-Pascal’s-Triangle-II-Easy" class="headerlink" title="119. Pascal’s Triangle II (Easy)"></a><a href="https://leetcode.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">119. Pascal’s Triangle II (Easy)</a></h3><pre><code class="html">Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal&#39;s triangle.
Note that the row index starts from 0.
In Pascal&#39;s triangle, each number is the sum of the two numbers directly above it.

Example:
Input: 3
Output: [1,3,3,1]

Follow up:
Could you optimize your algorithm to use only O(k) extra space?
</code></pre>
<pre><code class="python">class Solution:
    def getRow(self, rowIndex: int) -&gt; List[int]:
        ans = [1]
        for i in range(rowIndex):
            ans = [x + y for x, y in zip(ans + [0], [0] + ans)]
        return ans
</code></pre>
<p>高频：很巧妙的…[x + y for x, y in zip(ans + [0], [0] + ans)]…</p>
<h3 id="6-ZigZag-Conversion-Medium"><a href="#6-ZigZag-Conversion-Medium" class="headerlink" title="6. ZigZag Conversion (Medium)"></a><a href="https://leetcode.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. ZigZag Conversion (Medium)</a></h3><pre><code class="html">The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

P   A   H   N
A P L S I I G
Y   I   R
And then read line by line: &quot;PAHNAPLSIIGYIR&quot;

Write the code that will take a string and make this conversion given a number of rows:

string convert(string s, int numRows);
Example 1:

Input: s = &quot;PAYPALISHIRING&quot;, numRows = 3
Output: &quot;PAHNAPLSIIGYIR&quot;
Example 2:

Input: s = &quot;PAYPALISHIRING&quot;, numRows = 4
Output: &quot;PINALSIGYAHRPI&quot;
Explanation:

P     I    N
A   L S  I G
Y A   H R
P     I
</code></pre>
<pre><code class="python">class Solution:
    def convert(self, s: str, numRows: int) -&gt; str:
        if numRows == 1:
            return s
        res = [&#39;&#39;] * numRows
        r, move = 0, 1
        for l in s:
            res[r] += l
            r += move
            if r == numRows - 1:
                move = -1
            elif r == 0:
                move = 1
        return &#39;&#39;.join(res)
</code></pre>
<p>高频：想太多反而写不出来，直接粗暴拼反而能拼出来，注意numRows为1时单独处理</p>
<h3 id="8-String-to-Integer-atoi-Medium"><a href="#8-String-to-Integer-atoi-Medium" class="headerlink" title="8. String to Integer (atoi) (Medium)"></a><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. String to Integer (atoi) (Medium)</a></h3><pre><code class="html">Implement atoi which converts a string to an integer.

The function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.

The string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.

If the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.

If no valid conversion could be performed, a zero value is returned.

Note:

Only the space character &#39; &#39; is considered as whitespace character.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. If the numerical value is out of the range of representable values, INT_MAX (231 − 1) or INT_MIN (−231) is returned.
Example 1:

Input: &quot;42&quot;
Output: 42
Example 2:

Input: &quot;   -42&quot;
Output: -42
Explanation: The first non-whitespace character is &#39;-&#39;, which is the minus sign.
             Then take as many numerical digits as possible, which gets 42.
Example 3:

Input: &quot;4193 with words&quot;
Output: 4193
Explanation: Conversion stops at digit &#39;3&#39; as the next character is not a numerical digit.
Example 4:

Input: &quot;words and 987&quot;
Output: 0
Explanation: The first non-whitespace character is &#39;w&#39;, which is not a numerical
             digit or a +/- sign. Therefore no valid conversion could be performed.
Example 5:

Input: &quot;-91283472332&quot;
Output: -2147483648
Explanation: The number &quot;-91283472332&quot; is out of the range of a 32-bit signed integer.
             Thefore INT_MIN (−231) is returned.
</code></pre>
<pre><code class="python">class Solution:
    def myAtoi(self, str: str) -&gt; int:
        return self.helper(str)
    def helper(self, s):
        s = s.strip()
        if not s:
            return 0
        valid = [str(i) for i in range(10)]
        signs = &#39;+-&#39;
        if s[0] not in valid and s[0] not in signs:
            return 0
        sign = 1
        if s[0] == &#39;-&#39;:
            sign = -1
        if s[0] in signs:
            s = s[1:]
        ans = &#39;&#39;
        for l in s:
            if l in valid:
                ans += l
                if sign == -1 and -int(ans) &lt; -pow(2, 31):
                    return -pow(2, 31)
                if sign == 1 and int(ans) &gt; pow(2, 31) - 1:
                    return pow(2, 31) - 1
            else:
                return sign * int(ans) if ans else 0
        return sign * int(ans) if ans else 0
</code></pre>
<p>高频：从例子之多就能看出来要考虑的case非常多。比的是细致</p>
<h3 id="57-Insert-Interval-Hard"><a href="#57-Insert-Interval-Hard" class="headerlink" title="57. Insert Interval (Hard)"></a><a href="https://leetcode.com/problems/insert-interval/description/" target="_blank" rel="noopener">57. Insert Interval (Hard)</a></h3><pre><code class="html">Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).

You may assume that the intervals were initially sorted according to their start times.

Example 1:

Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]
Example 2:

Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.
</code></pre>
<pre><code class="python">class Solution:
    def insert(self, intervals, newInterval):
        if not intervals:
            return [newInterval]
        ans = []
        i = 0
        while i &lt; len(intervals):
            if intervals[i][1] &lt; newInterval[0]:
                ans.append(intervals[i])
                i += 1
            else:
                break
        while i &lt; len(intervals) and intervals[i][0] &lt;= newInterval[1]:
            newInterval[0] = min(newInterval[0], intervals[i][0])
            newInterval[1] = max(newInterval[1], intervals[i][1])
            i += 1
        ans.append(newInterval)
        while i &lt; len(intervals):
            ans.append(intervals[i])
            i += 1
        return ans
</code></pre>
<p>高频：重点是知道先把，结束小于新开始的…if intervals[i][1] &lt; newInterval[0]:…加到ans里，然后过开始小于新结束的…if…and intervals[i][0] &lt;= newInterval[1]: …min…max…这个方法</p>
<h3 id="937-Reorder-Log-Files-Easy"><a href="#937-Reorder-Log-Files-Easy" class="headerlink" title="937. Reorder Log Files (Easy)"></a><a href="https://leetcode.com/problems/reorder-log-files/" target="_blank" rel="noopener">937. Reorder Log Files (Easy)</a></h3><pre><code class="html">You have an array of logs.  Each log is a space delimited string of words.

For each log, the first word in each log is an alphanumeric identifier.  Then, either:

Each word after the identifier will consist only of lowercase letters, or;
Each word after the identifier will consist only of digits.
We will call these two varieties of logs letter-logs and digit-logs.  It is guaranteed that each log has at least one word after its identifier.

Reorder the logs so that all of the letter-logs come before any digit-log.  The letter-logs are ordered lexicographically ignoring identifier, with the identifier used in case of ties.  The digit-logs should be put in their original order.

Return the final order of the logs.
Example 1:

Input: [&quot;a1 9 2 3 1&quot;,&quot;g1 act car&quot;,&quot;zo4 4 7&quot;,&quot;ab1 off key dog&quot;,&quot;a8 act zoo&quot;]
Output: [&quot;g1 act car&quot;,&quot;a8 act zoo&quot;,&quot;ab1 off key dog&quot;,&quot;a1 9 2 3 1&quot;,&quot;zo4 4 7&quot;]

Note:

0 &lt;= logs.length &lt;= 100
3 &lt;= logs[i].length &lt;= 100
logs[i] is guaranteed to have an identifier, and a word after the identifier.
</code></pre>
<pre><code class="python">class Solution:
    def reorderLogFiles(self, logs: List[str]) -&gt; List[str]:
        nums, letters = [], []
        for log in logs:
            words = log.split(&#39; &#39;)
            if words[1].isdigit():
                nums.append(log)
            else:
                letters.append(log)
        letters.sort(key = lambda x: x.split(&#39; &#39;)[0])
        letters.sort(key = lambda x: x.split(&#39; &#39;)[1:])
        return letters + nums
</code></pre>
<p>面经：Amazon，用key function，sort是stable</p>
<h3 id="189-Rotate-Array-Easy"><a href="#189-Rotate-Array-Easy" class="headerlink" title="189. Rotate Array (Easy)"></a><a href="https://leetcode.com/problems/rotate-array/" target="_blank" rel="noopener">189. Rotate Array (Easy)</a></h3><p>Given an array, rotate the array to the right by k steps, where k is non-negative.</p>
<pre><code>Example 1:
Input: [1,2,3,4,5,6,7] and k = 3
Output: [5,6,7,1,2,3,4]
Explanation:
rotate 1 steps to the right: [7,1,2,3,4,5,6]
rotate 2 steps to the right: [6,7,1,2,3,4,5]
rotate 3 steps to the right: [5,6,7,1,2,3,4]

Example 2:
Input: [-1,-100,3,99] and k = 2
Output: [3,99,-1,-100]
Explanation:
rotate 1 steps to the right: [99,-1,-100,3]
rotate 2 steps to the right: [3,99,-1,-100]
</code></pre><p>Note:<br>Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.<br>Could you do it in-place with O(1) extra space?</p>
<p>O(n) space:</p>
<pre><code class="python">class Solution:
    def rotate(self, nums: List[int], k: int) -&gt; None:
        n = len(nums)
        original = nums[:]
        for i in range(n):
            nums[(i + k) % n] = original[i]
</code></pre>
<p>O(1) space:</p>
<pre><code class="python">class Solution:
    def rotate(self, nums: List[int], k: int) -&gt; None:
        k = k % len(nums)
        if k == 0 or len(nums) == 1:
            return
        nums.reverse()
        self.reverse(nums, 0, k - 1)
        self.reverse(nums, k, len(nums) - 1)
    def reverse(self, nums, s, e):
        while s &lt; e:
            nums[s], nums[e] = nums[e], nums[s]
            s += 1
            e -= 1
</code></pre>
<p>面经：维萨. 向右走2：—&gt;–&gt; to –&gt;—&gt; 或者向左走2：&lt;–&lt;— to &lt;—&lt;–</p>
<h3 id="296-Best-Meeting-Point-Hard-带锁"><a href="#296-Best-Meeting-Point-Hard-带锁" class="headerlink" title="296. Best Meeting Point (Hard) 带锁"></a><a href="https://leetcode.com/problems/best-meeting-point" target="_blank" rel="noopener">296. Best Meeting Point (Hard) 带锁</a></h3><p><a href="https://www.lintcode.com/problem/best-meeting-point/description" target="_blank" rel="noopener">LinC 912. Best Meeting Point</a><br>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.</p>
<p>Example 1:<br>Input:<br>[[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]<br>Output:<br>6<br>Explanation:<br>The point <code>(0,2)</code> is an ideal meeting point, as the total travel distance of <code>2 + 2 + 2 = 6</code> is minimal. So return <code>6</code>.</p>
<p>Example 2:<br>Input:<br>[[1,1,0,0,1],[1,0,1,0,0],[0,0,1,0,1]]<br>Output:<br>14</p>
<pre><code class="python">class Solution:
    def minTotalDistance(self, grid):
        rows, cols = [], []
        for r in range(len(grid)):
            for c in range(len(grid[0])):
                if grid[r][c] == 1:
                    rows.append(r)
                    cols.append(c)
        rows.sort()
        cols.sort()
        ans = 0
        i, j = 0, len(rows) - 1
        while i &lt; j:
            ans += rows[j] - rows[i] + cols[j] - cols[i]
            i += 1
            j -= 1
        return ans
</code></pre>
<p>面经：维萨。关键是知道将行和列排序，然后从两边算距离的方法。</p>
<h2 id="Sliding-Window-滑动窗口"><a href="#Sliding-Window-滑动窗口" class="headerlink" title="Sliding Window 滑动窗口"></a>Sliding Window 滑动窗口</h2><h3 id="438-Find-All-Anagrams-in-a-String-Medium"><a href="#438-Find-All-Anagrams-in-a-String-Medium" class="headerlink" title="438. Find All Anagrams in a String (Medium)"></a><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">438. Find All Anagrams in a String (Medium)</a></h3><p>Given a string s and a non-empty string p, find all the start indices of p’s anagrams in s.<br>Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.<br>The order of output does not matter.</p>
<p>Example 1:<br>Input:<br>s: “cbaebabacd” p: “abc”<br>Output:<br>[0, 6]<br>Explanation:<br>The substring with start index = 0 is “cba”, which is an anagram of “abc”.<br>The substring with start index = 6 is “bac”, which is an anagram of “abc”.</p>
<p>Example 2:<br>Input:<br>s: “abab” p: “ab”<br>Output:<br>[0, 1, 2]<br>Explanation:<br>The substring with start index = 0 is “ab”, which is an anagram of “ab”.<br>The substring with start index = 1 is “ba”, which is an anagram of “ab”.<br>The substring with start index = 2 is “ab”, which is an anagram of “ab”.</p>
<pre><code class="python">class Solution:
    def findAnagrams(self, s: str, p: str) -&gt; List[int]:
        ans = []
        n, m = len(s), len(p)
        from collections import Counter
        pCounter = Counter(p)
        sCounter = Counter(s[:m - 1])
        for i in range(m - 1, n):
            si = i - m + 1
            sCounter[s[i]] += 1
            if pCounter == sCounter:
                ans.append(si)
            sCounter[s[si]] -= 1
            if sCounter[s[si]] == 0:
                del sCounter[s[si]]
        return ans
</code></pre>
<p>面经：Amazon。注意sCounter[s[si]] -= 1需要减相应字母的计数，否则会产生bug。todo：也用sliding window的模板改下代码</p>
<h3 id="3-Longest-Substring-Without-Repeating-Characters-Medium"><a href="#3-Longest-Substring-Without-Repeating-Characters-Medium" class="headerlink" title="3. Longest Substring Without Repeating Characters (Medium)"></a><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters (Medium)</a></h3><p>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Example 1:<br>Input: “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3.</p>
<p>Example 2:<br>Input: “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p>
<p>Example 3:<br>Input: “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.<br>             Note that the answer must be a substring, “pwke” is a subsequence and not a substring.</p>
<pre><code class="python">class Solution:
    def lengthOfLongestSubstring(self, s: str) -&gt; int:
        l, d = 0, {}
        ans = 0
        for i, c in enumerate(s):
            if c in d:
                l = max(l, d[c] + 1)
            d[c] = i
            ans = max(ans, i - l + 1)
        return ans
</code></pre>
<p>面经，二刷：Amazon。sliding window模板代码看不懂了。l和i两个指针，如果c重复了，就将l挪到上次出现的c后一位. l不能往回走，如abba，到最后a的时候l不能回到0+1的位置上去</p>
<h3 id="76-Minimum-Window-Substring-Hard"><a href="#76-Minimum-Window-Substring-Hard" class="headerlink" title="76. Minimum Window Substring (Hard)"></a><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">76. Minimum Window Substring (Hard)</a></h3><p>Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).</p>
<p>Example:<br>Input: S = “ADOBECODEBANC”, T = “ABC”<br>Output: “BANC”</p>
<p>Note:<br>If there is no such window in S that covers all characters in T, return the empty string “”.<br>If there is such window, you are guaranteed that there will always be only one unique minimum window in S.</p>
<pre><code class="python">class Solution:
    def minWindow(self, s: str, t: str) -&gt; str:
        from collections import Counter, defaultdict
        targetMap = Counter(t)
        window = defaultdict(int)
        l, r = 0, 0
        targetLen, formed = len(targetMap), 0
        ans = &quot;&quot;
        #search left to right
        while r &lt;= len(s) - 1:
            c = s[r]
            window[c] += 1
            if c in targetMap and window[c] == targetMap[c]:
                formed += 1
            #found a valid substring, contracts left
            while formed == targetLen:
                if not ans or r - l + 1 &lt; len(ans):
                    ans = s[l:r + 1]
                tempC = s[l]
                window[tempC] -= 1
                if tempC in targetMap and window[tempC] &lt; targetMap[tempC]:
                    formed -= 1
                l += 1
            r += 1
        return ans
</code></pre>
<p>面经, 二刷：Amazon。双指针sliding window，r前进，找到符合条件的substring以后收缩l寻找更短符合条件的substring</p>
<h3 id="1151-Minimum-Swaps-to-Group-All-1’s-Together-Medium-带锁"><a href="#1151-Minimum-Swaps-to-Group-All-1’s-Together-Medium-带锁" class="headerlink" title="1151    Minimum Swaps to Group All 1’s Together (Medium) 带锁"></a><a href="https://leetcode.com/problems/minimum-swaps-to-group-all-1s-together" target="_blank" rel="noopener">1151    Minimum Swaps to Group All 1’s Together (Medium) 带锁</a></h3><p><a href="https://www.geeksforgeeks.org/minimum-swaps-required-group-1s-together/" target="_blank" rel="noopener">geeks for geeks article</a><br>Given an array of 0’s and 1’s, we need to write a program to find the minimum number of swaps required to group all 1’s present in the array together.</p>
<p>Examples:<br>Input : arr[] = {1, 0, 1, 0, 1}<br>Output : 1<br>Explanation: Only 1 swap is required to<br>group all 1’s together. Swapping index 1<br>and 4 will give arr[] = {1, 1, 1, 0, 0}</p>
<p>Input : arr[] = {1, 0, 1, 0, 1, 1}<br>Output : 1</p>
<pre><code class="python">def minSwaps(arr):
    from collections import Counter
    counter = Counter(arr)
    targetLen = counter[1]
    counter = Counter(arr[0:targetLen])
    most1s = counter[1]
    for i in range(1, len(arr) - targetLen + 1):
        #because I already know how many 1s in previous subarray. Just add or subtract as I go
        if boxes[i - 1] == 1:
            counter[1] -= 1
        if boxes[i + targetLen - 1] == 1:
            counter[1] += 1
        if counter[1] &gt; most1s:
            most1s = counter[1]
    return targetLen - most1s
</code></pre>
<p>面经：Celo。算法的核心是：find the subarray of counter[1] length that has the most 1’s. Then just move the 1’s from elsewhere to fill the 0’s in this subarray</p>
<h3 id="1004-Max-Consecutive-Ones-III-medium"><a href="#1004-Max-Consecutive-Ones-III-medium" class="headerlink" title="1004. Max Consecutive Ones III medium"></a><a href="https://leetcode.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener">1004. Max Consecutive Ones III medium</a></h3><p>Given an array A of 0s and 1s, we may change up to K values from 0 to 1.<br>Return the length of the longest (contiguous) subarray that contains only 1s.</p>
<p>Example 1:<br>Input: A = [1,1,1,0,0,0,1,1,1,1,0], K = 2<br>Output: 6<br>Explanation:<br>[1,1,1,0,0,1,1,1,1,1,1]<br>Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</p>
<p>Example 2:<br>Input: A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3<br>Output: 10<br>Explanation:<br>[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]<br>Bolded numbers were flipped from 0 to 1.  The longest subarray is underlined.</p>
<p>Note:<br>1 &lt;= A.length &lt;= 20000<br>0 &lt;= K &lt;= A.length<br>A[i] is 0 or 1</p>
<pre><code class="python">class Solution:
    def longestOnes(self, A: List[int], K: int) -&gt; int:
        l = 0
        for r in range(len(A)):
            K -= 1 - A[r]
            if K &lt; 0:
                K += 1 - A[l]
                l += 1
        return r - l + 1
</code></pre>
<p>一刷：Facebook tag</p>
<h2 id="Linked-List-链表"><a href="#Linked-List-链表" class="headerlink" title="Linked List 链表"></a>Linked List 链表</h2><h3 id="83-Remove-Duplicates-from-Sorted-List-Easy"><a href="#83-Remove-Duplicates-from-Sorted-List-Easy" class="headerlink" title="83. Remove Duplicates from Sorted List (Easy)"></a><a href="83. Remove Duplicates from Sorted List">83. Remove Duplicates from Sorted List (Easy)</a></h3><p>Given a sorted linked list, delete all duplicates such that each element appear only once.</p>
<p>Example 1:<br>Input: 1-&gt;1-&gt;2<br>Output: 1-&gt;2</p>
<p>Example 2:<br>Input: 1-&gt;1-&gt;2-&gt;3-&gt;3<br>Output: 1-&gt;2-&gt;3</p>
<p>高频</p>
<pre><code class="python">class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        cur = head
        while cur and cur.next:
            if cur.val == cur.next.val:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return head
</code></pre>
<p>总结：…<strong>temp = head</strong>; while temp and temp.next: …temp.next = temp.next.next; else: temp = temp.next…</p>
<h3 id="82-Remove-Duplicates-from-Sorted-List-II-Medium"><a href="#82-Remove-Duplicates-from-Sorted-List-II-Medium" class="headerlink" title="82. Remove Duplicates from Sorted List II (Medium)"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/" target="_blank" rel="noopener">82. Remove Duplicates from Sorted List II (Medium)</a></h3><p>Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.</p>
<p>Example 1:<br>Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5<br>Output: 1-&gt;2-&gt;5</p>
<p>Example 2:<br>Input: 1-&gt;1-&gt;1-&gt;2-&gt;3<br>Output: 2-&gt;3</p>
<p>高频</p>
<pre><code class="python">class Solution:
    def deleteDuplicates(self, head: ListNode) -&gt; ListNode:
        dummy = cur = ListNode(0)
        dummy.next = head
        while cur:
            has_dupe = False
            while cur.next and cur.next.next and cur.next.val == cur.next.next.val:
                cur.next = cur.next.next
                has_dupe = True
            if has_dupe:
                cur.next = cur.next.next
            else:
                cur = cur.next
        return dummy.next
</code></pre>
<p>高频：…cur = dummy…has_dupe = False…cur.next = cur.next.next…</p>
<h3 id="21-Merge-Two-Sorted-Lists-Easy"><a href="#21-Merge-Two-Sorted-Lists-Easy" class="headerlink" title="21. Merge Two Sorted Lists (Easy)"></a><a href="https://leetcode.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. Merge Two Sorted Lists (Easy)</a></h3><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p>
<p>Example:<br>Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4<br>Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>
<pre><code class="python">class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        dummy = cur = ListNode(0)
        while l1 and l2:
            if l1.val &lt; l2.val:
                cur.next = l1
                cur = cur.next
                l1 = l1.next
            else:
                cur.next = l2
                cur = cur.next
                l2 = l2.next
        if l1:
            cur.next = l1
        if l2:
            cur.next = l2
        return dummy.next
</code></pre>
<p>高频：面经：Cruise。<br>三刷：手熟尔</p>
<h3 id="19-Remove-Nth-Node-From-End-of-List-Medium"><a href="#19-Remove-Nth-Node-From-End-of-List-Medium" class="headerlink" title="19. Remove Nth Node From End of List (Medium)"></a><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/" target="_blank" rel="noopener">19. Remove Nth Node From End of List (Medium)</a></h3><p>Given a linked list, remove the n-th node from the end of list and return its head.</p>
<p>Example:<br>Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.<br>After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.</p>
<p>Note:<br>Given n will always be valid.</p>
<p>Follow up:<br>Could you do this in one pass?</p>
<pre><code class="python">class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -&gt; ListNode:
        dummy = ListNode(0)
        dummy.next = head
        fast = slow = dummy
        while n:
            n -= 1
            fast = fast.next
        while fast and fast.next:
            fast = fast.next
            slow = slow.next
        slow.next = slow.next.next
        return dummy.next
</code></pre>
<p>高频：dummy = ListNode(0)…fast = slow = dummy…slow.next = slow.next.next…</p>
<h3 id="2-Add-Two-Numbers-Medium"><a href="#2-Add-Two-Numbers-Medium" class="headerlink" title="2. Add Two Numbers (Medium)"></a><a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. Add Two Numbers (Medium)</a></h3><pre><code class="html">You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example:

Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
Explanation: 342 + 465 = 807.
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&gt; ListNode:
        return self.n2l(self.l2n(l1) + self.l2n(l2))

    def l2n(self, root):
        num = &quot;&quot;
        while root:
            num = str(root.val) + num
            root = root.next
        return int(num)

    def n2l(self, num):
        num = str(num)
        head = None
        for d in num:
            if not head:
                head = ListNode(int(d))
            else:
                old_head = head
                head = ListNode(int(d))
                head.next = old_head
        return head
</code></pre>
<p>总结：写l2n和n2l两个函数</p>
<h3 id="86-Partition-List-Medium"><a href="#86-Partition-List-Medium" class="headerlink" title="86. Partition List (Medium)"></a><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">86. Partition List (Medium)</a></h3><p>Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.<br>You should preserve the original relative order of the nodes in each of the two partitions.</p>
<p>Example:<br>Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3<br>Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</p>
<pre><code class="python">class Solution:
    def partition(self, head: ListNode, x: int) -&gt; ListNode:
        loHead = loDummy = ListNode(0)
        hiHead = hiDummy = ListNode(0)
        while head:
            if head.val &lt; x:
                loHead.next = head
                loHead = loHead.next
            else:
                hiHead.next = head
                hiHead = hiHead.next
            head = head.next
        loHead.next = hiDummy.next
        hiHead.next = None
        return loDummy.next
</code></pre>
<p>高频, 五刷：两个dummy，两个worker</p>
<h3 id="141-Linked-List-Cycle-Easy"><a href="#141-Linked-List-Cycle-Easy" class="headerlink" title="141. Linked List Cycle (Easy)"></a><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">141. Linked List Cycle (Easy)</a></h3><p>Given a linked list, determine if it has a cycle in it.<br>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.</p>
<p>Example 1:<br>Input: head = [3,2,0,-4], pos = 1<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Linked List Cycle example1"></p>
<p>Example 2:<br>Input: head = [1,2], pos = 0<br>Output: true<br>Explanation: There is a cycle in the linked list, where tail connects to the first node.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="Linked List Cycle example2"></p>
<p>Example 3:<br>Input: head = [1], pos = -1<br>Output: false<br>Explanation: There is no cycle in the linked list.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="Linked List Cycle example3"></p>
<p>Follow up:<br>Can you solve it without using extra space?</p>
<pre><code class="python">class Solution(object):
    def hasCycle(self, head):
        if not head:
            return False
        s = f = head
        while f.next and f.next.next:
            s = s.next
            f = f.next.next
            if s == f:
                return True
        return False
</code></pre>
<p>二刷，面经：维萨。</p>
<h3 id="142-Linked-List-Cycle-II-Medium"><a href="#142-Linked-List-Cycle-II-Medium" class="headerlink" title="142. Linked List Cycle II (Medium)"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">142. Linked List Cycle II (Medium)</a></h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.<br>To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.<br>Note: Do not modify the linked list.</p>
<p>Example 1:<br>Input: head = [3,2,0,-4], pos = 1<br>Output: tail connects to node index 1<br>Explanation: There is a cycle in the linked list, where tail connects to the second node.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="Linked List Cycle II example1"></p>
<p>Example 2:<br>Input: head = [1,2], pos = 0<br>Output: tail connects to node index 0<br>Explanation: There is a cycle in the linked list, where tail connects to the first node.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test2.png" alt="Linked List Cycle II example2"></p>
<p>Example 3:<br>Input: head = [1], pos = -1<br>Output: no cycle<br>Explanation: There is no cycle in the linked list.<br><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist_test3.png" alt="Linked List Cycle II example3"></p>
<pre><code class="python">class Solution(object):
    def detectCycle(self, head):
        if not head or not head.next:
            return
        s = f = head
        loop = False
        while f.next and f.next.next:
            s = s.next
            f = f.next.next
            if s == f:
                loop = True
                break
        if not loop:
            return
        s = head
        while s != f:
            s = s.next
            f = f.next
        return s
</code></pre>
<p>面经：维萨。关键知识点是1.相遇点是慢指针在环里的 <strong>第一圈</strong>。是快指针在环里的第n圈。2. 慢指针走了x+y, 快指针走了 <strong>2(x + y)</strong> 3. 快指针这个 <strong>距离又等同于 x + y + nr</strong> 4. x = nr - y 4. <strong>由下图可见， nr - y = z</strong> 5. z 和 x 是相等的。 6. 因此可以head与快或慢同时前进，相遇即是B点。</p>
<pre><code>    x            y
A ------ B --------+
         |         |
       z |         |
         +----C----+
* 环的长度为 r
* C: 快慢指针相遇点
</code></pre><h3 id="206-Reverse-Linked-List-Easy"><a href="#206-Reverse-Linked-List-Easy" class="headerlink" title="206. Reverse Linked List (Easy)"></a><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. Reverse Linked List (Easy)</a></h3><p>Reverse a singly linked list.</p>
<p>Example:<br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>Follow up:<br>A linked list can be reversed either iteratively or recursively. Could you implement both?<br>遍历：</p>
<pre><code class="python">class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        pre = None
        cur = head
        while cur:
            nextHead = cur.next
            cur.next = pre
            pre = cur
            cur = nextHead
        return pre
</code></pre>
<p>递归：</p>
<pre><code class="python">class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        if not head:
            return head
        if head and not head.next:
            return head
        savedListHead = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return savedListHead
</code></pre>
<p>递归：</p>
<pre><code class="python">class Solution:
    def reverseList(self, head: ListNode) -&gt; ListNode:
        return self.helper(head, None)
    def helper(self, head, pre):
        if not head:
            return pre
        nextHead = head.next
        head.next = pre
        return self.helper(nextHead, head)
</code></pre>
<p>高频, 四刷：遍历：pre = None…nextHead = head.next…递归：增加了<a href="https://www.youtube.com/watch?v=O0By4Zq0OFc" target="_blank" rel="noopener">这个油管视频的递归方法</a>。savedListHead是base case，然后最后层层传回去。…return f(nextHead, head)…</p>
<h3 id="160-Intersection-of-Two-Linked-Lists-Easy"><a href="#160-Intersection-of-Two-Linked-Lists-Easy" class="headerlink" title="160. Intersection of Two Linked Lists (Easy)"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">160. Intersection of Two Linked Lists (Easy)</a></h3><p>Write a program to find the node at which the intersection of two singly linked lists begins.<br>For example, the following two linked lists:</p>
<pre><code>A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗
B:     b1 → b2 → b3
</code></pre><p>begin to intersect at node c1.</p>
<p>Notes:<br>If the two linked lists have no intersection at all, return null.<br>The linked lists must retain their original structure after the function returns.<br>You may assume there are no cycles anywhere in the entire linked structure.<br>Your code should preferably run in O(n) time and use only O(1) memory.</p>
<pre><code class="python">class Solution(object):
    def getIntersectionNode(self, headA, headB):
        savedHeadA, savedHeadB = headA, headB
        if headA == None or headB == None:
            return None
        lenA, lenB = 1, 1
        while headA.next != None:
            headA = headA.next
            lenA += 1
        while headB.next != None:
            headB = headB.next
            lenB += 1
        if lenA &gt; lenB:
            diff = lenA - lenB
            for x in xrange(diff):
                savedHeadA = savedHeadA.next
        else:
            diff = lenB - lenA
            for x in xrange(diff):
                savedHeadB = savedHeadB.next
        while savedHeadA != None:
            if savedHeadA == savedHeadB:
                return savedHeadA
            else:
                savedHeadA = savedHeadA.next
                savedHeadB = savedHeadB.next
        return None
</code></pre>
<p>思路：统计两条链走到头的长度，lenA 和 lenB, 然后让长的那条先走两者的差值，然后一起走，返回相遇的那点。或者将A的尾巴连到B的开头，找环的入口<br>总结：1.注意空输入（不能假设 headA 或 B 有 next）2.注意 headA headB 是一个节点 i.e. 合体的情况</p>
<h3 id="24-Swap-Nodes-in-Pairs-Medium"><a href="#24-Swap-Nodes-in-Pairs-Medium" class="headerlink" title="24. Swap Nodes in Pairs (Medium)"></a><a href="https://leetcode.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. Swap Nodes in Pairs (Medium)</a></h3><p>Given a linked list, swap every two adjacent nodes and return its head.<br>You may not modify the values in the list’s nodes, only nodes itself may be changed.</p>
<p>Example:<br>Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3.</p>
<p>高频</p>
<pre><code class="python">class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        dummy = cur = ListNode(0)
        while head and head.next:
            a, b = head, head.next
            head = b.next
            cur.next = b
            b.next = a
            cur = a
            cur.next = None
        if head:
            cur.next = head
        return dummy.next
</code></pre>
<p>递归</p>
<pre><code class="python">class Solution:
    def swapPairs(self, head: ListNode) -&gt; ListNode:
        if not head or not head.next:
            return head
        neighbor = head.next
        frontier = neighbor.next
        neighbor.next = head
        head.next = self.swapPairs(frontier)
        return neighbor
</code></pre>
<p>总结：a, b, 挪head，连接 cur.next，b的next到a，挪cur到a，切掉cur-&gt;。todo：理解递归答案</p>
<h3 id="61-Rotate-List-Medium"><a href="#61-Rotate-List-Medium" class="headerlink" title="61. Rotate List (Medium)"></a><a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="noopener">61. Rotate List (Medium)</a></h3><p>Given a linked list, rotate the list to the right by k places, where k is non-negative.</p>
<p>Example 1:<br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2<br>Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL<br>rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL</p>
<p>Example 2:<br>Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4<br>Output: 2-&gt;0-&gt;1-&gt;NULL<br>Explanation:<br>rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL<br>rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL<br>rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL<br>rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL</p>
<p>高频</p>
<pre><code class="python">class Solution:
    def rotateRight(self, head: ListNode, k: int) -&gt; ListNode:
        if not head:
            return head
        dummy = ListNode(0)
        dummy.next = head
        f = dummy
        l = 0
        while f and f.next:
            f = f.next
            l += 1
        s = dummy
        k %= l
        for _ in range(l - k):
            s = s.next
        f.next = dummy.next
        dummy.next = s.next
        s.next = None
        return dummy.next
</code></pre>
<p>高频，二刷：链长l，k %= l, 将第l - k位置的以后的放链表前面：s走l - k步，f.next接到dummy.next上，dummy.next接到s.next; s.next = None</p>
<h3 id="146-LRU-Cache-Medium"><a href="#146-LRU-Cache-Medium" class="headerlink" title="146. LRU Cache (Medium)"></a><a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="noopener">146. LRU Cache (Medium)</a></h3><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p>
<p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.<br>The cache is initialized with a positive capacity.</p>
<p>Follow up:<br>Could you do both operations in O(1) time complexity?</p>
<pre><code>Example:
LRUCache cache = new LRUCache( 2 /* capacity */ );
cache.put(1, 1);
cache.put(2, 2);
cache.get(1);       // returns 1
cache.put(3, 3);    // evicts key 2
cache.get(2);       // returns -1 (not found)
cache.put(4, 4);    // evicts key 1
cache.get(1);       // returns -1 (not found)
cache.get(3);       // returns 3
cache.get(4);       // returns 4
</code></pre><pre><code class="python">class Node:
    def __init__(self, k, v):
        self.key = k
        self.val = v
        self.prev = None
        self.next = None

class LRUCache:

    def __init__(self, capacity: int):
        self.capacity = capacity
        self.mapping = {}
        self.head, self.tail = Node(0, 0), Node(0, 0)
        self.head.next = self.tail
        self.tail.prev = self.head

    def get(self, key: int) -&gt; int:
        if key not in self.mapping:
            return -1
        n = self.mapping[key]
        self._remove(n)
        self._append(n)
        return n.val

    def put(self, key: int, value: int) -&gt; None:
        n = Node(key, value)
        if key in self.mapping:
            self._remove(self.mapping[key])
        self.mapping[key] = n
        self._append(n)
        if len(self.mapping) &gt; self.capacity:
            t = self.head.next
            del self.mapping[t.key]
            self._remove(t)

    def _remove(self, node):
        node.next.prev = node.prev
        node.prev.next = node.next

    def _append(self, node):
        self.tail.prev.next = node
        node.prev = self.tail.prev
        node.next = self.tail
        self.tail.prev = node
</code></pre>
<p>高频, 二刷：dict的k为k，v为链表的节点n。注意put的时候要先把旧的重复key对从双链表中删除。或者使用OrderedDict这个数据结构，支持随机+头部删除(mapping.popitem(last = False))和顺序append</p>
<h3 id="234-Palindrome-Linked-List-Easy"><a href="#234-Palindrome-Linked-List-Easy" class="headerlink" title="234. Palindrome Linked List (Easy)"></a><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. Palindrome Linked List (Easy)</a></h3><pre><code class="html">Given a singly linked list, determine if it is a palindrome.

Example 1:

Input: 1-&gt;2
Output: false
Example 2:

Input: 1-&gt;2-&gt;2-&gt;1
Output: true
Follow up:
Could you do it in O(n) time and O(1) space?
</code></pre>
<pre><code class="python">class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        if not head or not head.next:
            return True
        s = f = head
        midHead = None
        while f and f.next:
            f = f.next.next
            nextHead = s.next
            s.next = midHead
            midHead = s
            s = nextHead
        if f:
            s = s.next
        while s:
            if midHead.val != s.val:
                return False
            else:
                s = s.next
                midHead = midHead.next
        return True
</code></pre>
<p>高频, 二刷：慢指针边走边反转，当链表是奇数个时需要s跳过中间节点再s,midhead同时前进：…if f: s = s.next…</p>
<h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h2><h3 id="20-Valid-Parentheses-Easy"><a href="#20-Valid-Parentheses-Easy" class="headerlink" title="20. Valid Parentheses (Easy)"></a><a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">20. Valid Parentheses (Easy)</a></h3><pre><code class="html">Given a string containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Note that an empty string is also considered valid.

Example 1:

Input: &quot;()&quot;
Output: true
Example 2:

Input: &quot;()[]{}&quot;
Output: true
Example 3:

Input: &quot;(]&quot;
Output: false
Example 4:

Input: &quot;([)]&quot;
Output: false
Example 5:

Input: &quot;{[]}&quot;
Output: true
</code></pre>
<pre><code class="python">class Solution:
    def isValid(self, s: str) -&gt; bool:
        l = &#39;({[&#39;
        stack = []
        for c in s:
            if c in l:
                stack.append(c)
            else:
                if not stack:
                    return False
                t = stack.pop()
                if t == &#39;(&#39; and c != &#39;)&#39;:
                    return False
                if t == &#39;{&#39; and c != &#39;}&#39;:
                    return False
                if t == &#39;[&#39; and c != &#39;]&#39;:
                    return False
        if stack:
            return False
        return True
</code></pre>
<p>高频：注意在出栈前检验栈是否为空，走完以后检查栈是否为空</p>
<h3 id="71-Simplify-Path-Medium"><a href="#71-Simplify-Path-Medium" class="headerlink" title="71. Simplify Path (Medium)"></a><a href="https://leetcode.com/problems/simplify-path/" target="_blank" rel="noopener">71. Simplify Path (Medium)</a></h3><pre><code class="html">Given an absolute path for a file (Unix-style), simplify it. Or in other words, convert it to the canonical path.

In a UNIX-style file system, a period . refers to the current directory. Furthermore, a double period .. moves the directory up a level. For more information, see: Absolute path vs relative path in Linux/Unix

Note that the returned canonical path must always begin with a slash /, and there must be only a single slash / between two directory names. The last directory name (if it exists) must not end with a trailing /. Also, the canonical path must be the shortest string representing the absolute path.

Example 1:

Input: &quot;/home/&quot;
Output: &quot;/home&quot;
Explanation: Note that there is no trailing slash after the last directory name.
Example 2:

Input: &quot;/../&quot;
Output: &quot;/&quot;
Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.
Example 3:

Input: &quot;/home//foo/&quot;
Output: &quot;/home/foo&quot;
Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one.
Example 4:

Input: &quot;/a/./b/../../c/&quot;
Output: &quot;/c&quot;
Example 5:

Input: &quot;/a/../../b/../c//.//&quot;
Output: &quot;/c&quot;
Example 6:

Input: &quot;/a//b////c/d//././/..&quot;
Output: &quot;/a/b/c&quot;
</code></pre>
<pre><code class="python">class Solution:
    def simplifyPath(self, path: str) -&gt; str:
        t = path.split(&#39;/&#39;)
        s = []
        for p in t:
            if p and p != &#39;.&#39;:
                if p == &#39;..&#39;:
                    if s:
                        s.pop()
                else:
                    s.append(p)
        if not s:
            return &#39;/&#39;
        else:
            return &#39;/&#39; + &#39;/&#39;.join(s)
</code></pre>
<p>高频：注意split(‘/‘)是’/‘的会变成数组里一个空的元素</p>
<h3 id="150-Evaluate-Reverse-Polish-Notation-Medium"><a href="#150-Evaluate-Reverse-Polish-Notation-Medium" class="headerlink" title="150. Evaluate Reverse Polish Notation (Medium)"></a><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. Evaluate Reverse Polish Notation (Medium)</a></h3><pre><code class="html">Evaluate the value of an arithmetic expression in Reverse Polish Notation.

Valid operators are +, -, *, /. Each operand may be an integer or another expression.

Note:

Division between two integers should truncate toward zero.
The given RPN expression is always valid. That means the expression would always evaluate to a result and there won&#39;t be any divide by zero operation.
Example 1:

Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]
Output: 9
Explanation: ((2 + 1) * 3) = 9
Example 2:

Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]
Output: 6
Explanation: (4 + (13 / 5)) = 6
Example 3:

Input: [&quot;10&quot;, &quot;6&quot;, &quot;9&quot;, &quot;3&quot;, &quot;+&quot;, &quot;-11&quot;, &quot;*&quot;, &quot;/&quot;, &quot;*&quot;, &quot;17&quot;, &quot;+&quot;, &quot;5&quot;, &quot;+&quot;]
Output: 22
Explanation:
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
</code></pre>
<pre><code class="python">class Solution:
    def evalRPN(self, tokens: List[str]) -&gt; int:
        operators = &quot;+-*/&quot;
        s = []
        for op in tokens:
            if op not in operators:
                s.append(int(op))
            else:
                b = s.pop()
                a = s.pop()
                if op == &quot;+&quot;:
                    res = a + b
                elif op == &quot;-&quot;:
                    res = a - b
                elif op == &#39;*&#39;:
                    res = a * b
                elif op == &quot;/&quot;:
                    if a * b &lt; 0 and a % b != 0:
                        res = a // b + 1
                    else:
                        res = a // b
                s.append(res)
        return s[0]
</code></pre>
<p>高频：需要注意leetcode里-1//20为0，而python里为-1，-21//20python里为-2。需要单独处理一下</p>
<h3 id="155-Min-Stack-Easy"><a href="#155-Min-Stack-Easy" class="headerlink" title="155. Min Stack (Easy)"></a><a href="https://leetcode.com/problems/min-stack/" target="_blank" rel="noopener">155. Min Stack (Easy)</a></h3><pre><code class="html">Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
getMin() -- Retrieve the minimum element in the stack.


Example:

MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --&gt; Returns -3.
minStack.pop();
minStack.top();      --&gt; Returns 0.
minStack.getMin();   --&gt; Returns -2.
</code></pre>
<pre><code class="python">class MinStack:

    def __init__(self):
        &quot;&quot;&quot;
        initialize your data structure here.
        &quot;&quot;&quot;
        self.stack = []

    def push(self, x: int) -&gt; None:
        curMin = self.getMin() if self.stack else sys.maxsize
        if x &lt; curMin:
            curMin = x
        self.stack.append((x, curMin))

    def pop(self) -&gt; None:
        self.stack.pop()

    def top(self) -&gt; int:
        return self.stack[-1][0]

    def getMin(self) -&gt; int:
        if self.stack:
            return self.stack[-1][1]
</code></pre>
<p>高频：一个stack就用tuple，两个stack就相当于第二个stack来维持curMin</p>
<h3 id="224-Basic-Calculator-Hard"><a href="#224-Basic-Calculator-Hard" class="headerlink" title="224. Basic Calculator (Hard)"></a><a href="https://leetcode.com/problems/basic-calculator/" target="_blank" rel="noopener">224. Basic Calculator (Hard)</a></h3><p>Implement a basic calculator to evaluate a simple expression string.<br>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p>
<p>Example 1:<br>Input: “1 + 1”<br>Output: 2<br>Example 2:</p>
<p>Input: “ 2-1 + 2 “<br>Output: 3<br>Example 3:</p>
<p>Input: “(1+(4+5+2)-3)+(6+8)”<br>Output: 23<br>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p>
<pre><code class="python">class Solution:
    def calculate(self, s: str) -&gt; int:
        num, ans = 0, 0
        sign = 1
        stack = []
        for c in s:
            if c.isdigit():
                num = num * 10 + int(c)
            elif c in &quot;+-&quot;:
                ans += sign * num
                num = 0
                sign = 1 if c == &quot;+&quot; else -1
            elif c == &quot;(&quot;:
                stack.append(ans)
                stack.append(sign)
                ans = 0
                sign = 1
            elif c == &quot;)&quot;:
                ans += sign * num
                ans *= stack.pop()
                ans += stack.pop()
                num = 0
        return ans + sign * num
</code></pre>
<p>面经：Cruise …num = 0…ans = 0; sign = 1…num = 0…</p>
<h3 id="227-Basic-Calculator-II-Medium"><a href="#227-Basic-Calculator-II-Medium" class="headerlink" title="227. Basic Calculator II (Medium)"></a><a href="https://leetcode.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. Basic Calculator II (Medium)</a></h3><p>Implement a basic calculator to evaluate a simple expression string.<br>The expression string contains only non-negative integers, +, -, * , / operators and empty spaces . The integer division should truncate toward zero.</p>
<p>Example 1:<br>Input: “3+2*2”<br>Output: 7<br>Example 2:</p>
<p>Input: “ 3/2 “<br>Output: 1<br>Example 3:</p>
<p>Input: “ 3+5 / 2 “<br>Output: 5</p>
<p>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p>
<pre><code class="python">class Solution:
    def calculate(self, s: str) -&gt; int:
        if not s:
            return 0
        num = 0
        operator = &quot;+&quot;
        stack = []
        for i in range(len(s)):
            if s[i].isdigit():
                num = num * 10 + int(s[i])
            if (not s[i].isdigit() and s[i] != &quot; &quot;) or i == len(s) - 1:
                if operator == &quot;+&quot;:
                    stack.append(num)
                elif operator == &quot;-&quot;:
                    stack.append(-num)
                elif operator == &quot;*&quot;:
                    stack.append(stack.pop() * num)
                elif operator == &quot;/&quot;:
                    stack.append(int(stack.pop() / num))
                num = 0
                operator = s[i]
        return sum(stack)
</code></pre>
<p>面经：Cruise。符号或操作符均是在最后变化。因为要处理最后一个字符的问题，所以要么两个if，要么得在s后面跟一个“+”</p>
<h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2><h3 id="LinC-642-Moving-Average-from-Data-Stream-Easy"><a href="#LinC-642-Moving-Average-from-Data-Stream-Easy" class="headerlink" title="LinC 642. Moving Average from Data Stream (Easy)"></a><a href="https://www.lintcode.com/problem/moving-average-from-data-stream/description" target="_blank" rel="noopener">LinC 642. Moving Average from Data Stream (Easy)</a></h3><pre><code class="html">Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.

Example
MovingAverage m = new MovingAverage(3);
m.next(1) = 1 // return 1.00000
m.next(10) = (1 + 10) / 2 // return 5.50000
m.next(3) = (1 + 10 + 3) / 3 // return 4.66667
m.next(5) = (10 + 3 + 5) / 3 // return 6.00000
</code></pre>
<p>思路：建个 window size 的队列，返回队列的平均值</p>
<pre><code class="python">class MovingAverage:
    q = collections.deque()
    sum = 0
    maxLen = 0
    &quot;&quot;&quot;
    @param: size: An integer
    &quot;&quot;&quot;
    def __init__(self, size):
        # do intialization if necessary
        self.maxLen = size
    &quot;&quot;&quot;
    @param: val: An integer
    @return:
    &quot;&quot;&quot;
    def next(self, val):
        # write your code here
        self.q.append(val)
        self.sum += val
        if len(self.q) &gt; self.maxLen:
            temp = self.q.popleft()
            self.sum -= temp
        avg = self.sum / len(self.q)
        return avg

# Your MovingAverage object will be instantiated and called as such:
# obj = MovingAverage(size)
# param = obj.next(val)
</code></pre>
<p>总结：注意 class 变量要加 self，另外 sum 不要每次都 loop 一遍算， 直接放到 class 变量里，每次只增 and / or 减一次。</p>
<h2 id="Hash-哈希表"><a href="#Hash-哈希表" class="headerlink" title="Hash 哈希表"></a>Hash 哈希表</h2><h3 id="290-Word-Pattern-Easy"><a href="#290-Word-Pattern-Easy" class="headerlink" title="290. Word Pattern (Easy)"></a><a href="https://leetcode.com/problems/word-pattern/description/" target="_blank" rel="noopener">290. Word Pattern (Easy)</a></h3><pre><code class="html">Given a pattern and a string str, find if str follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

Example 1:

Input: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;
Output: true
Example 2:

Input:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;
Output: false
Example 3:

Input: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;
Output: false
Example 4:

Input: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;
Output: false
Notes:
You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.
</code></pre>
<p>思路：关键在于懂得建立 pattern 里每个字母和 str 里每个 word 的映射。</p>
<pre><code class="python">class Solution(object):
    def wordPattern(self, pattern, str):
        &quot;&quot;&quot;
        :type pattern: str
        :type str: str
        :rtype: bool
        &quot;&quot;&quot;
        words = str.split(&#39; &#39;)
        if len(words) != len(pattern):
            return False
        mapping = {}
        for i, char in enumerate(pattern):
            if char in mapping:
                if mapping[char] != words[i]:
                    return False
            else:
                if words[i] in mapping.values():
                    return False
                mapping[char] = words[i]
        return True
</code></pre>
<p>总结：注意需要用 enumerate， 因为要同时遍历 pattern 和 str. 很好的哈希表热身题。Word Pattern II 的 str 里没有空格了，不能直接 split，难度直接推到 Hard。目前刷题的水平先跳过吧 :(</p>
<h3 id="387-First-Unique-Character-in-a-String-Easy"><a href="#387-First-Unique-Character-in-a-String-Easy" class="headerlink" title="387. First Unique Character in a String (Easy)"></a><a href="https://leetcode.com/problems/first-unique-character-in-a-string/description/" target="_blank" rel="noopener">387. First Unique Character in a String (Easy)</a></h3><pre><code class="html">Given a string, find the first non-repeating character in it and return it&#39;s index. If it doesn&#39;t exist, return -1.

Examples:

s = &quot;leetcode&quot;
return 0.

s = &quot;loveleetcode&quot;,
return 2.
Note: You may assume the string contain only lowercase letters.
</code></pre>
<p>思路：过两遍，第一遍数出现多少次， 第二遍把第一个为 1 的 index 返回</p>
<pre><code class="python">class Solution(object):
    def firstUniqChar(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        if len(s) == 0:
            return -1
        if len(s) == 1:
            return 0
        dict = {}
        for char in s:
            if char not in dict:
                dict[char] = 1
            else:
                dict[char] += 1
        for index, char in enumerate(s):
            if dict[char] == 1:
                return index
        return -1
</code></pre>
<p>总结：基本题，注意 dict entry 初始化为 1 的情况</p>
<h3 id="409-Longest-Palindrome-Easy"><a href="#409-Longest-Palindrome-Easy" class="headerlink" title="409. Longest Palindrome (Easy)"></a><a href="https://leetcode.com/problems/longest-palindrome/description/" target="_blank" rel="noopener">409. Longest Palindrome (Easy)</a></h3><p>Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.<br>This is case sensitive, for example “Aa” is not considered a palindrome here.</p>
<p>Note:<br>Assume the length of given string will not exceed 1,010.</p>
<p>Example:<br>Input:<br>“abccccdd”<br>Output:<br>7</p>
<p>Explanation:<br>One longest palindrome that can be built is “dccaccd”, whose length is 7.</p>
<pre><code class="python">class Solution(object):
    def longestPalindrome(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        ans = 0
        from collections import Counter
        counter = Counter(s)
        for c, v in counter.items():
            if v % 2 == 0 or ans % 2 == 0:
                ans += v
            else:
                ans += v - 1
        return ans
</code></pre>
<p>面经：Amazon。去掉了一刷二刷的hashmap和dp解法。就用简单好懂的解法吧</p>
<h3 id="380-Insert-Delete-GetRandom-O-1-Medium"><a href="#380-Insert-Delete-GetRandom-O-1-Medium" class="headerlink" title="380. Insert Delete GetRandom O(1) (Medium)"></a><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/" target="_blank" rel="noopener">380. Insert Delete GetRandom O(1) (Medium)</a></h3><pre><code class="html">Design a data structure that supports all following operations in average O(1) time.

insert(val): Inserts an item val to the set if not already present.
remove(val): Removes an item val from the set if present.
getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.
Example:

// Init an empty set.
RandomizedSet randomSet = new RandomizedSet();

// Inserts 1 to the set. Returns true as 1 was inserted successfully.
randomSet.insert(1);

// Returns false as 2 does not exist in the set.
randomSet.remove(2);

// Inserts 2 to the set, returns true. Set now contains [1,2].
randomSet.insert(2);

// getRandom should return either 1 or 2 randomly.
randomSet.getRandom();

// Removes 1 from the set, returns true. Set now contains [2].
randomSet.remove(1);

// 2 was already in the set, so return false.
randomSet.insert(2);

// Since 2 is the only number in the set, getRandom always return 2.
randomSet.getRandom();
</code></pre>
<p>思路：看答案知道需要用 list 和 dictionary，因为要满足 O(1), 因为仅有 list 的 in 操作不能满足 O(1)</p>
<pre><code class="python">class RandomizedSet(object):

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.list = []
        self.dict = {}

    def insert(self, val):
        &quot;&quot;&quot;
        Inserts a value to the set. Returns true if the set did not already contain the specified element.
        :type val: int
        :rtype: bool
        &quot;&quot;&quot;
        if val in self.dict:
            return False
        else:
            self.list.append(val)
            self.dict[val] = len(self.list) - 1
            return True

    def remove(self, val):
        &quot;&quot;&quot;
        Removes a value from the set. Returns true if the set contained the specified element.
        :type val: int
        :rtype: bool
        &quot;&quot;&quot;
        if val in self.dict:
            index, lastVal = self.dict[val], self.list[len(self.list) - 1]
            self.list[index], self.dict[lastVal] = lastVal, index
            self.list.pop()
            self.dict.pop(val)
            return True
        else:
            return False

    def getRandom(self):
        &quot;&quot;&quot;
        Get a random element from the set.
        :rtype: int
        &quot;&quot;&quot;
        return self.list[random.randint(0, len(self.list) - 1)]


# Your RandomizedSet object will be instantiated and called as such:
# obj = RandomizedSet()
# param_1 = obj.insert(val)
# param_2 = obj.remove(val)
# param_3 = obj.getRandom()
</code></pre>
<p>总结：可能是用 python 的原因，搞明白问什么了一次过</p>
<h3 id="LinC-960-First-Unique-Number-in-a-Stream-II-Medium"><a href="#LinC-960-First-Unique-Number-in-a-Stream-II-Medium" class="headerlink" title="LinC 960. First Unique Number in a Stream II (Medium)"></a><a href="960. First Unique Number in a Stream II">LinC 960. First Unique Number in a Stream II (Medium)</a></h3><pre><code class="html">Description
We need to implement a data structure named DataStream. There are two methods required to be implemented:

void add(number) // add a new number
int firstUnique() // return first unique number
You can assume that there must be at least one unique number in the stream when calling the firstUnique.

Example
add(1)
add(2)
firstUnique() =&gt; 1
add(1)
firstUnique() =&gt; 2
</code></pre>
<p>思路：维持一个 deque / queue，碰到相同的就 popleft 出去</p>
<pre><code class="python">class DataStream:

    def __init__():
        # do intialization if necessary
        self.q = collections.deque()
        self.dict = {}
    &quot;&quot;&quot;
    @param num: next number in stream
    @return: nothing
    &quot;&quot;&quot;
    def add(self, num):
        # write your code here
        if num in self.dict:
            self.dict[num] += 1
        else:
            self.dict[num] = 1
            self.q.append(num)
    &quot;&quot;&quot;
    @return: the first unique number in stream
    &quot;&quot;&quot;
    def firstUnique(self):
        # write your code here
        while len(self.q) &gt; 0 and self.dict[self.q[0]] &gt; 1:
                self.q.popleft()
        return self.q[0]
</code></pre>
<p>总结：1.popleft 要在 firstUnique 里面，不然有些 testcase 过不了；2.注意 popleft 的条件要用 while， 用 for 会出错</p>
<h3 id="49-Group-Anagrams-Medium"><a href="#49-Group-Anagrams-Medium" class="headerlink" title="49. Group Anagrams (Medium)"></a><a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">49. Group Anagrams (Medium)</a></h3><pre><code class="html">Given an array of strings, group anagrams together.

Example:

Input: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],
Output:
[
  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],
  [&quot;nat&quot;,&quot;tan&quot;],
  [&quot;bat&quot;]
]
Note:

All inputs will be in lowercase.
The order of your output does not matter.
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def groupAnagrams(self, strs: List[str]) -&gt; List[List[str]]:
        d = collections.defaultdict(list)
        for s in strs:
            tmps = &quot;&quot;.join(sorted(s))
            d[tmps].append(s)
        return list(d.values())
</code></pre>
<p>总结：sorted(s)返回一个char list，“”.join(list)将这个list拼回字符串。list(d.values())可返回defaultdict的值</p>
<h2 id="Heap-Priority-Queue"><a href="#Heap-Priority-Queue" class="headerlink" title="Heap (Priority Queue)"></a>Heap (Priority Queue)</h2><h3 id="264-Ugly-Number-II-Medium"><a href="#264-Ugly-Number-II-Medium" class="headerlink" title="264. Ugly Number II (Medium)"></a><a href="https://leetcode.com/problems/ugly-number-ii/description/" target="_blank" rel="noopener">264. Ugly Number II (Medium)</a></h3><pre><code class="html">Write a program to find the n-th ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.

Example:

Input: n = 10
Output: 12
Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.
Note:

1 is typically treated as an ugly number.
n does not exceed 1690.
</code></pre>
<p>思路：九章的 python 答案可以 work，但是实在是不好理解。写个好理解一点的版本。heapq 和 hashMap, 从 heapq 中取 n - 1 次（第一个数为 1），每取一次将原始 ugly numbers 2, 3, 5 过一遍</p>
<pre><code class="python">class Solution(object):
    def nthUglyNumber(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        primes = [2, 3, 5]
        q = [2, 3, 5]
        hashMap = {}
        for i in range(3):
            hashMap[q[i]] = True
        import heapq
        heapq.heapify(q)
        ans = 1
        for i in range(n - 1):
            ans = heapq.heappop(q)
            for j in range(3):
                new_val = ans * primes[j]
                if new_val not in hashMap:
                    heapq.heappush(q, new_val)
                    hashMap[new_val] = True
        return ans
</code></pre>
<p>总结：可以 AC，也可以理解，good enough<br>二刷：其实是道dp题，用set和heapq也能过，但是时间上没有优势</p>
<h3 id="973-K-Closest-Points-to-Origin-Medium"><a href="#973-K-Closest-Points-to-Origin-Medium" class="headerlink" title="973. K Closest Points to Origin (Medium)"></a><a href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">973. K Closest Points to Origin (Medium)</a></h3><p>We have a list of points on the plane.  Find the K closest points to the origin (0, 0).<br>(Here, the distance between two points on a plane is the Euclidean distance.)<br>You may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)</p>
<p>Example 1:<br>Input: points = [[1,3],[-2,2]], K = 1<br>Output: [[-2,2]]<br>Explanation:<br>The distance between (1, 3) and the origin is sqrt(10).<br>The distance between (-2, 2) and the origin is sqrt(8).<br>Since sqrt(8) &lt; sqrt(10), (-2, 2) is closer to the origin.<br>We only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].</p>
<p>Example 2:<br>Input: points = [[3,3],[5,-1],[-2,4]], K = 2<br>Output: [[3,3],[-2,4]]<br>(The answer [[-2,4],[3,3]] would also be accepted.)</p>
<p>Note:<br>1 &lt;= K &lt;= points.length &lt;= 10000<br>-10000 &lt; points[i][0] &lt; 10000<br>-10000 &lt; points[i][1] &lt; 10000</p>
<pre><code class="python">class Solution:
    def kClosest(self, points: List[List[int]], K: int) -&gt; List[List[int]]:
        arr = [[p[0] ** 2 + p[1] ** 2, p] for p in points]
        arr.sort(key = lambda x: x[0])
        return [i[1] for i in arr[:K]]
</code></pre>
<p>面经：Amazon。删掉一刷的思路和总结。简化代码，非常欣慰</p>
<h3 id="LinC-545-Top-k-Largest-Numbers-II-Medium"><a href="#LinC-545-Top-k-Largest-Numbers-II-Medium" class="headerlink" title="LinC 545. Top k Largest Numbers II (Medium)"></a><a href="https://www.lintcode.com/problem/top-k-largest-numbers-ii/description" target="_blank" rel="noopener">LinC 545. Top k Largest Numbers II (Medium)</a></h3><pre><code class="html">Implement a data structure, provide two interfaces:
add(number). Add a new number in the data structure.
topk(). Return the top k largest numbers in this data structure. k is given when we create the data structure.

Example
s = new Solution(3);
&gt;&gt; create a new data structure.
s.add(3)
s.add(10)
s.topk()
&gt;&gt; return [10, 3]
s.add(1000)
s.add(-99)
s.topk()
&gt;&gt; return [1000, 10, 3]
s.add(4)
s.topk()
&gt;&gt; return [1000, 10, 4]
s.add(100)
s.topk()
&gt;&gt; return [1000, 100, 10]
</code></pre>
<p>思路：看着是非常直观的 min heap 问题。。。</p>
<pre><code class="python">class Solution:
    &quot;&quot;&quot;
    @param: k: An integer
    &quot;&quot;&quot;
    def __init__(self, k):
        # do intialization if necessary
        self.k = k
        self.q = []
    &quot;&quot;&quot;
    @param: num: Number to be added
    @return: nothing
    &quot;&quot;&quot;
    def add(self, num):
        # write your code here
        import heapq
        heapq.heappush(self.q, num)
        if len(self.q) &gt; self.k:
            heapq.heappop(self.q)
    &quot;&quot;&quot;
    @return: Top k element
    &quot;&quot;&quot;
    def topk(self):
        # write your code here
        return sorted(self.q, reverse = True)
</code></pre>
<p>总结：一句 sorted(self.q, reverse = True) 完爆。。。哎， python 的 buit-in function 返回一个 sorted new list…学习了。</p>
<h3 id="LinC-486-Merge-K-Sorted-Arrays-Medium"><a href="#LinC-486-Merge-K-Sorted-Arrays-Medium" class="headerlink" title="LinC 486. Merge K Sorted Arrays (Medium)"></a><a href="https://www.lintcode.com/problem/merge-k-sorted-arrays/description" target="_blank" rel="noopener">LinC 486. Merge K Sorted Arrays (Medium)</a></h3><pre><code class="html">Given k sorted integer arrays, merge them into one sorted array.

Example
Given 3 sorted arrays:

[
  [1, 3, 5, 7],
  [2, 4, 6],
  [0, 8, 9, 10, 11]
]
return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].

Challenge
Do it in O(N log k).

N is the total number of integers.
k is the number of arrays.
</code></pre>
<p>思路：看答案，用 heap 屌爆了。加了链接到上面 heap 的部分</p>
<pre><code class="python">class Solution:
    &quot;&quot;&quot;
    @param arrays: k sorted integer arrays
    @return: a sorted array
    &quot;&quot;&quot;
    def mergekSortedArrays(self, arrays):
        # write your code here
        import heapq
        q = []
        for level, array in enumerate(arrays):
            if len(array) == 0:
                continue
            heapq.heappush(q, (array[0], level, 0))
        ans = []
        while q:
            cur, level, index = heapq.heappop(q)
            ans.append(cur)
            if index + 1 &lt; len(arrays[level]):
                heapq.heappush(q, (arrays[level][index + 1], level, index + 1))
        return ans
</code></pre>
<p>总结：只能说 python 的 heapq 屌爆了</p>
<h3 id="23-Merge-k-Sorted-Lists-Hard"><a href="#23-Merge-k-Sorted-Lists-Hard" class="headerlink" title="23. Merge k Sorted Lists (Hard)"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">23. Merge k Sorted Lists (Hard)</a></h3><p>Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.</p>
<pre><code>Example:
Input:
[
  1-&gt;4-&gt;5,
  1-&gt;3-&gt;4,
  2-&gt;6
]
Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6
</code></pre><p>PriorityQueue:</p>
<pre><code class="python">class Solution:
    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:
        dummy = cur = ListNode(0)
        h = []
        import heapq
        for i, n in enumerate(lists):
            if n:
                heapq.heappush(h, (n.val, i, n))
        while h:
            v, i, n = heapq.heappop(h)
            cur.next = n
            cur = cur.next
            if n.next:
                heapq.heappush(h, (n.next.val, i, n.next))
        return dummy.next
</code></pre>
<p>分治：</p>
<pre><code class="python">class Solution:
    def mergeKLists(self, lists: List[ListNode]) -&gt; ListNode:
        if not lists:
            return None
        n = len(lists)
        if n == 1:
            return lists[0]
        mid = n // 2
        l = self.mergeKLists(lists[:mid])
        r = self.mergeKLists(lists[mid:])
        def merge(l, r):
            dummy = cur = ListNode(0)
            while l and r:
                if l.val &lt; r.val:
                    cur.next = l
                    l = l.next
                else:
                    cur.next = r
                    r = r.next
                cur = cur.next
            cur.next = l if not r else r
            return dummy.next
        return merge(l, r)
</code></pre>
<p>三种方法，都需要练习. 方法一:使用 PriorityQueue 方法二:类似归并排序的分治算法 方法三:自底向上的两两归并算法. 时间复杂度均为 O(NlogK) Strong Hire: 能够用至少2种方法进行实现，代码无大 BUG<br>高频：如果不能加<strong>lt</strong>()，就用(n.val, i, n)tuple防v.val重复的。<br>todo 把缺的第三种方法补了</p>
<h3 id="295-Find-Median-from-Data-Stream-Hard"><a href="#295-Find-Median-from-Data-Stream-Hard" class="headerlink" title="295. Find Median from Data Stream (Hard)"></a><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">295. Find Median from Data Stream (Hard)</a></h3><p>Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.</p>
<p>For example,<br>[2,3,4], the median is 3<br>[2,3], the median is (2 + 3) / 2 = 2.5</p>
<p>Design a data structure that supports the following two operations:<br>void addNum(int num) - Add a integer number from the data stream to the data structure.<br>double findMedian() - Return the median of all elements so far.</p>
<p>Example:<br>addNum(1)<br>addNum(2)<br>findMedian() -&gt; 1.5<br>addNum(3)<br>findMedian() -&gt; 2</p>
<p>Follow up:<br>If all integer numbers from the stream are between 0 and 100, how would you optimize it?<br>If 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?</p>
<pre><code class="python">class MedianFinder:
    import heapq
    def __init__(self):
        self.upper = []
        self.lower = []

    def addNum(self, num: int) -&gt; None:
        if len(self.upper) == len(self.lower):
            heapq.heappush(self.upper, -heapq.heappushpop(self.lower, -num))
        else:
            heapq.heappush(self.lower, -heapq.heappushpop(self.upper, num))

    def findMedian(self) -&gt; float:
        if len(self.upper) == len(self.lower):
            return self.upper[0] * 0.5 - self.lower[0] * 0.5
        else:
            return float(self.upper[0])
</code></pre>
<p>面经：Amazon，maxheap + minheap，lower要用负数来模拟maxheap。 注意:…heapq.heappushpop(lower, <strong>-num</strong>)…</p>
<h3 id="743-Network-Delay-Time-Medium"><a href="#743-Network-Delay-Time-Medium" class="headerlink" title="743. Network Delay Time (Medium)"></a><a href="https://leetcode.com/problems/network-delay-time/" target="_blank" rel="noopener">743. Network Delay Time (Medium)</a></h3><p>There are N network nodes, labelled 1 to N.<br>Given times, a list of travel times as directed edges times[i] = (u, v, w), where u is the source node, v is the target node, and w is the time it takes for a signal to travel from source to target.<br>Now, we send a signal from a certain node K. How long will it take for all nodes to receive the signal? If it is impossible, return -1.<br><img src="https://i.imgur.com/e6P0mDW.png" alt="network example"><br>Example 1:<br>Input: times = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2<br>Output: 2<br>Note:<br>N will be in the range [1, 100].<br>K will be in the range [1, N].<br>The length of times will be in the range [1, 6000].<br>All edges times[i] = (u, v, w) will have 1 &lt;= u, v &lt;= N and 0 &lt;= w &lt;= 100.</p>
<pre><code class="python">class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -&gt; int:
        graph = collections.defaultdict(dict)
        for u, v, w in times:
            graph[u - 1][v - 1] = w
        distances = [sys.maxsize] * N
        distances[K - 1] = 0
        pq = [(0, K - 1)]
        seen = set()
        while pq:
            dist, v1 = heapq.heappop(pq)
            if v1 not in seen:
                seen.add(v1)
                for v2 in graph[v1]:
                    if v2 not in seen:
                        prev = distances[v2]
                        cur = dist + graph[v1][v2]
                        if cur &lt; prev:
                            distances[v2] = cur
                            heapq.heappush(pq, (cur, v2))
        ans = max(distances)
        return -1 if ans == sys.maxsize else ans
</code></pre>
<p>面经：练习某家小公司的OA，Dijkstra Graph 最短路径，Dijkstra有很多变种问题，不同写法。</p>
<h3 id="787-Cheapest-Flights-Within-K-Stops-Medium"><a href="#787-Cheapest-Flights-Within-K-Stops-Medium" class="headerlink" title="787. Cheapest Flights Within K Stops (Medium)"></a><a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/" target="_blank" rel="noopener">787. Cheapest Flights Within K Stops (Medium)</a></h3><pre><code class="html">There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.

Now given all the cities and flights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.

Example 1:
Input:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 1
Output: 200
Explanation:
The graph looks like this:

The cheapest price from city 0 to city 2 with at most 1 stop costs 200, as marked red in the picture.
Example 2:
Input:
n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]
src = 0, dst = 2, k = 0
Output: 500
Explanation:
The graph looks like this:

The cheapest price from city 0 to city 2 with at most 0 stop costs 500, as marked blue in the picture.
Note:

The number of nodes n will be in range [1, 100], with nodes labeled from 0 to n - 1.
The size of flights will be in range [0, n * (n - 1) / 2].
The format of each flight will be (src, dst, price).
The price of each flight will be in the range [1, 10000].
k is in the range of [0, n - 1].
There will not be any duplicated flights or self cycles.
</code></pre>
<pre><code class="python">class Solution:
    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -&gt; int:
        graph = collections.defaultdict(dict)
        for u, v, w in flights:
            graph[u][v] = w
        costs = [sys.maxsize] * n
        costs[src] = 0
        pq = [(0,  src, 0)]
        while pq:
            import heapq
            cost, v1, stop = heapq.heappop(pq)
            if stop - 1 &lt;= K:
                if v1 == dst:
                    return cost
                for v2 in graph[v1]:
                    pre = costs[v2]
                    cur = cost + graph[v1][v2]
                    if cur &lt; pre:
                        heapq.heappush(pq, (cur, v2, stop + 1))
        return -1
</code></pre>
<p>面经：与上题不同之处是这里问的不是全局最优，而是符合条件的最优，同一个点可能需要重复访问才能找到符合条件的最优，因此无需seen这个set</p>
<h3 id="855-Exam-Room-Medium"><a href="#855-Exam-Room-Medium" class="headerlink" title="855. Exam Room (Medium)"></a><a href="https://leetcode.com/problems/exam-room/" target="_blank" rel="noopener">855. Exam Room (Medium)</a></h3><p>In an exam room, there are N seats in a single row, numbered 0, 1, 2, …, N-1.<br>When a student enters the room, they must sit in the seat that maximizes the distance to the closest person.  If there are multiple such seats, they sit in the seat with the lowest number.  (Also, if no one is in the room, then the student sits at seat number 0.)<br>Return a class ExamRoom(int N) that exposes two functions: ExamRoom.seat() returning an int representing what seat the student sat in, and ExamRoom.leave(int p) representing that the student in seat number p now leaves the room.  It is guaranteed that any calls to ExamRoom.leave(p) have a student sitting in seat p.</p>
<p>Example 1:<br>Input: [“ExamRoom”,”seat”,”seat”,”seat”,”seat”,”leave”,”seat”], [[10],[],[],[],[],[4],[]]<br>Output: [null,0,9,4,2,null,5]<br>Explanation:<br>ExamRoom(10) -&gt; null<br>seat() -&gt; 0, no one is in the room, then the student sits at seat number 0.<br>seat() -&gt; 9, the student sits at the last seat number 9.<br>seat() -&gt; 4, the student sits at the last seat number 4.<br>seat() -&gt; 2, the student sits at the last seat number 2.<br>leave(4) -&gt; null<br>seat() -&gt; 5, the student sits at the last seat number 5.</p>
<p>Note:<br>1 &lt;= N &lt;= 10^9<br>ExamRoom.seat() and ExamRoom.leave() will be called at most 10^4 times across all test cases.<br>Calls to ExamRoom.leave(p) are guaranteed to have a student currently sitting in seat number p.</p>
<pre><code class="python">class ExamRoom:
    import heapq
    def __init__(self, N: int):
        self.N = N
        self.L = []

    def seat(self) -&gt; int:
        if not self.L:
            res = 0
        else:
            d, res = self.L[0], 0
            for x, y in zip(self.L, self.L[1:]):
                if (y - x) // 2 &gt; d:
                    d = (y - x) // 2
                    res = x + (y - x) // 2
            if self.N - 1 - self.L[-1] &gt; d:
                res = self.N - 1
        bisect.insort(self.L, res)
        return res

    def leave(self, p: int) -&gt; None:
        self.L.remove(p)
</code></pre>
<p>面经： Cruise。正常思路是得用PriorityQueue。但是corner case写不出来，讨论区答案里java用个特殊的数据结构搭配pq，加上一个trick，不适合模板解题。…if <strong>y - x // 2</strong> &gt; d:…if <strong>self.N - 1 - self.L[-1]</strong> &gt; d: res = self.N - 1…bisect.<strong>insort</strong>(…)…</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h3 id="208-Implement-Trie-Prefix-Tree-Medium"><a href="#208-Implement-Trie-Prefix-Tree-Medium" class="headerlink" title="208. Implement Trie (Prefix Tree) (Medium)"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree) (Medium)</a></h3><pre><code class="html">Implement a trie with insert, search, and startsWith methods.

Example:

Trie trie = new Trie();

trie.insert(&quot;apple&quot;);
trie.search(&quot;apple&quot;);   // returns true
trie.search(&quot;app&quot;);     // returns false
trie.startsWith(&quot;app&quot;); // returns true
trie.insert(&quot;app&quot;);
trie.search(&quot;app&quot;);     // returns true
Note:

You may assume that all inputs are consist of lowercase letters a-z.
All inputs are guaranteed to be non-empty strings.
</code></pre>
<p>思路：没啥思路，看答案</p>
<pre><code class="python">class TrieNode:
    # Initialize your data structure here.
    def __init__(self):
        self.word=False
        self.children={}

class Trie:

    def __init__(self):
        self.root = TrieNode()

    # @param {string} word
    # @return {void}
    # Inserts a word into the trie.
    def insert(self, word):
        node=self.root
        for i in word:
            if i not in node.children:
                node.children[i]=TrieNode()
            node=node.children[i]
        node.word=True

    # @param {string} word
    # @return {boolean}
    # Returns if the word is in the trie.
    def search(self, word):
        node=self.root
        for i in word:
            if i not in node.children:
                return False
            node=node.children[i]
        return node.word

    # @param {string} prefix
    # @return {boolean}
    # Returns if there is any word in the trie
    # that starts with the given prefix.
    def startsWith(self, prefix):
        node=self.root
        for i in prefix:
            if i not in node.children:
                return False
            node=node.children[i]
        return True

    # Your Trie object will be instantiated and called as such:
    # obj = Trie()
    # obj.insert(word)
    # param_2 = obj.search(word)
    # param_3 = obj.startsWith(prefix)
</code></pre>
<p>总结：1.需要加 TrieNode 2. Leetcode 的 python3 找不到 class 是个 bug</p>
<h3 id="211-Add-and-Search-Word-Data-structure-design-Medium"><a href="#211-Add-and-Search-Word-Data-structure-design-Medium" class="headerlink" title="211. Add and Search Word - Data structure design (Medium)"></a><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/" target="_blank" rel="noopener">211. Add and Search Word - Data structure design (Medium)</a></h3><p>Design a data structure that supports the following two operations:</p>
<p>void addWord(word)<br>bool search(word)<br>search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter.</p>
<p>Example:</p>
<p>addWord(“bad”)<br>addWord(“dad”)<br>addWord(“mad”)<br>search(“pad”) -&gt; false<br>search(“bad”) -&gt; true<br>search(“.ad”) -&gt; true<br>search(“b..”) -&gt; true<br>Note:<br>You may assume that all words are consist of lowercase letters a-z.</p>
<pre><code class="python">class TrieNode:
    def __init__(self):
        self.end = False
        self.children = {}

class WordDictionary:
    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.root = TrieNode()

    def addWord(self, word: str) -&gt; None:
        &quot;&quot;&quot;
        Adds a word into the data structure.
        &quot;&quot;&quot;
        root = self.root
        for c in word:
            if c not in root.children:
                root.children[c] = TrieNode()
            root = root.children[c]
        root.end = True

    def search(self, word: str) -&gt; bool:
        &quot;&quot;&quot;
        Returns if the word is in the data structure. A word could contain the dot character &#39;.&#39; to represent any one letter.
        &quot;&quot;&quot;
        self.ans = False
        self.helper(self.root, word)
        return self.ans
    def helper(self, root, word):
        if not word:
            if root.end:
                self.ans = True
            return
        if word[0] == &quot;.&quot;:
            for v in root.children.values():
                self.helper(v, word[1:])
        else:
            if word[0] not in root.children:
                return
            self.helper(root.children[word[0]], word[1:])
</code></pre>
<p>面经：Celo。insert:…root.end = True…</p>
<h2 id="Union-Find-MST"><a href="#Union-Find-MST" class="headerlink" title="Union Find / MST"></a>Union Find / MST</h2><h3 id="LinC-629-Minimum-Spanning-Tree-Hard"><a href="#LinC-629-Minimum-Spanning-Tree-Hard" class="headerlink" title="LinC 629. Minimum Spanning Tree (Hard)"></a><a href="https://www.lintcode.com/problem/minimum-spanning-tree/description" target="_blank" rel="noopener">LinC 629. Minimum Spanning Tree (Hard)</a></h3><p>Given a list of Connections, which is the Connection class (the city name at both ends of the edge and a cost between them), find edges that can connect all the cities and spend the least amount.<br>Return the connects if can connect all the cities, otherwise return empty list.</p>
<p>Example<br>Example 1:</p>
<p>Input:<br>[“Acity”,”Bcity”,1]<br>[“Acity”,”Ccity”,2]<br>[“Bcity”,”Ccity”,3]<br>Output:<br>[“Acity”,”Bcity”,1]<br>[“Acity”,”Ccity”,2]<br>Example 2:</p>
<p>Input:<br>[“Acity”,”Bcity”,2]<br>[“Bcity”,”Dcity”,5]<br>[“Acity”,”Dcity”,4]<br>[“Ccity”,”Ecity”,1]<br>Output:<br>[]</p>
<p>Explanation:<br>No way<br>Notice<br>Return the connections sorted by the cost, or sorted city1 name if their cost is same, or sorted city2 if their city1 name is also same.</p>
<pre><code class="python">&#39;&#39;&#39;
Definition for a Connection
class Connection:

    def __init__(self, city1, city2, cost):
        self.city1, self.city2, self.cost = city1, city2, cost
&#39;&#39;&#39;
class Union:
    def __init__(self, n):
        self.size = n
        self.graph = {}
        for i in range(n):
            self.graph[i] = i

    def query(self, v1, v2):
        return self.find(v1) == self.find(v2)

    def find(self, v):
        if self.graph[v] == v:
            return v
        self.graph[v] = self.find(self.graph[v])
        return self.graph[v]

    def connect(self, v1, v2):
        root_a = self.find(v1)
        root_b = self.find(v2)
        if root_a != root_b:
            self.size -= 1
            self.graph[root_a] = self.graph[root_b]

    def all_connected(self):
        return self.size == 1

class Solution:
    # @param {Connection[]} connections given a list of connections
    # include two cities and cost
    # @return {Connection[]} a list of connections from results
    def lowestCost(self, connections):
        # Write your code here
        connections.sort(key = lambda x: x.city2)
        connections.sort(key = lambda x: x.city1)
        connections.sort(key = lambda x: x.cost)
        citymap = {}
        cnt = 0
        ans = []
        for c in connections:
            if c.city1 not in citymap:
                citymap[c.city1] = cnt
                cnt += 1
            if c.city2 not in citymap:
                citymap[c.city2] = cnt
                cnt += 1
        union = Union(cnt)
        for c in connections:
            c1 = citymap[c.city1]
            c2 = citymap[c.city2]

            if not union.query(c1, c2):
                union.connect(c1, c2)
                ans.append(c)
        return ans if union.all_connected() else []
</code></pre>
<p>面经：Amazon。</p>
<h1 id="DP-Dynamic-Programming-动态规划"><a href="#DP-Dynamic-Programming-动态规划" class="headerlink" title="DP Dynamic Programming 动态规划"></a>DP Dynamic Programming 动态规划</h1><h3 id="70-Climbing-Stairs-Easy"><a href="#70-Climbing-Stairs-Easy" class="headerlink" title="70. Climbing Stairs (Easy)"></a><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">70. Climbing Stairs (Easy)</a></h3><pre><code class="html">You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Note: Given n will be a positive integer.

Example 1:

Input: 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
Example 2:

Input: 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
</code></pre>
<p>思路：f[n] 是为 n 时的方案数，f[1] 是为 1 时的方案数 = 1。<strong>那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的</strong>，所以递推公式非常容易的就得出了：f[n] = f[n - 1] + f[n - 2]</p>
<pre><code class="python">class Solution:
    def climbStairs(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: int
        &quot;&quot;&quot;
        if n &lt;= 2:
            return n
        f = [0] * (n + 1)
        f[1] = 1
        f[2] = 2
        for i in range(3, n + 1):
            f[i] = f[i - 1] + f[i - 2]
        return f[n]
</code></pre>
<p>总结：和三年前比没有变化，呵呵呵<br>高频：没有太多优化空间，背：爬到第n层的方法要么是从第n-1层1步上来的，要不就是从n-2层2步上来的</p>
<h3 id="120-Triangle-Medium"><a href="#120-Triangle-Medium" class="headerlink" title="120. Triangle (Medium)"></a><a href="https://leetcode.com/problems/triangle/description/" target="_blank" rel="noopener">120. Triangle (Medium)</a></h3><pre><code class="html">Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

For example, given the following triangle

[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).

Note:

Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.
</code></pre>
<p>思路：看了 top down 的 DP， 还是比较好理解的。f 代表到达 row 和 col 位置的最小 sum，f[i][j] 和 f[i - 1][j - 1] 的关系是：f[i][j] = mins(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]. 规划的目标是最后一行中的最小值。；DP 以外还有三种解法，DFS：Traverse， DFS：Divide and Conquer， DFS：Divide and Conquer 加 memorization</p>
<pre><code class="python">class Solution:
    def minimumTotal(self, triangle):
        &quot;&quot;&quot;
        :type triangle: List[List[int]]
        :rtype: int
        &quot;&quot;&quot;
        if len(triangle) == 0:
            return 0
        if len(triangle) == 1:
            return triangle[0][0]
        f = []
        f.append([triangle[0][0]])
        n = len(triangle)
        for i in range(1, n):
            f.append([0] * (i + 1))
        for i in range(1, n):
            f[i][0] = f[i - 1][0] + triangle[i][0]
            f[i][i] = f[i - 1][i - 1] + triangle[i][i]
        for row in range(2, n):
            for col in range(1, row):
                f[row][col] = min(f[row - 1][col - 1], f[row - 1][col]) + triangle[row][col]
        ans = f[n - 1][0]
        for i in range(1, n):
            ans = min(ans, f[n - 1][i])
        return ans
</code></pre>
<p>高频：</p>
<pre><code class="python">class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:
        n = len(triangle)
        f = [[0] * (i + 1) for i in range(n)]
        f[0][0] = triangle[0][0]
        for i in range(1, n):
            for j in range(i + 1):
                if j == 0:
                    f[i][0] = f[i - 1][0] + triangle[i][j]
                elif j == i:
                    f[i][j] = f[i - 1][j - 1] + triangle[i][j]
                else:
                    f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]
        return min(f[n - 1])
</code></pre>
<p>bottom up:</p>
<pre><code class="python">class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:
        n = len(triangle)
        if n == 1:
            return triangle[0][0]
        f = [[0] * (i + 1) for i in range(n)]
        f[n - 1] = triangle[-1][:]
        for r in range(n - 2, -1, -1):
            for c in range(r + 1):
                f[r][c] = min(f[r + 1][c], f[r + 1][c + 1]) + triangle[r][c]
        return f[0][0]
</code></pre>
<p>总结：填充 f 每行第一个和最后一个的时候别忘了 + triangle[i][0] 和 triangle[i][i]<br>高频：注意topdown：下一层f[i][j]的时候要根据j的情况来分类判断f的值如何获得， 一刷的时候提前把三角的两条边先初始化了，循环的时候不循环那些元素。也是个好办法。代码稍微长一点。bottomup：代码简单很多。还可以进一步将空间降为O(n)，因为之前算出来的f[r + 1][]都没用</p>
<h3 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock (Easy)</a></h3><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.<br>Note that you cannot sell a stock before you buy one.</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 5<br>Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.<br>             Not 7-1 = 6, as selling price needs to be larger than buying price.</p>
<p>Example 2:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<p>DP：</p>
<pre><code class="python">class Solution:
    def maxProfit(self, prices):
        if not prices:
            return 0
        n = len(prices)
        dp = [0] * n
        low = prices[0]
        for i in range(1, n):
            if prices[i] &lt;= prices[i - 1]:
                dp[i] = dp[i - 1]
                low = min(prices[i], lowest)
            else:
                dp[i] = max(dp[i - 1], prices[i] - low)
        return dp[-1]
</code></pre>
<p>greedy:</p>
<pre><code class="python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        if not prices:
            return 0
        low = prices[0]
        p = 0
        for i in range(1, len(prices)):
            p = max(p, prices[i] - low)
            low = min(low, prices[i])
        return p
</code></pre>
<p>高频，三刷</p>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy" class="headerlink" title="122. Best Time to Buy and Sell Stock II (Easy)"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. Best Time to Buy and Sell Stock II (Easy)</a></h3><p>Say you have an array for which the ith element is the price of a given stock on day i.<br>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).<br>Note: You may not engage in multiple transactions at the same time (i.e., you must sell the stock before you buy again).</p>
<p>Example 1:<br>Input: [7,1,5,3,6,4]<br>Output: 7<br>Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.<br>             Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.</p>
<p>Example 2:<br>Input: [1,2,3,4,5]<br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>             Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are<br>             engaging multiple transactions at the same time. You must sell before buying again.<br>Example 3:<br>Input: [7,6,4,3,1]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.</p>
<pre><code class="python">class Solution:
    def maxProfit(self, prices: List[int]) -&gt; int:
        if not prices:
            return 0
        n = len(prices)
        dp = [0] * n
        for i in range(1, n):
            if prices[i] &gt; prices[i - 1]:
                dp[i] = dp[i - 1] + prices[i] - prices[i - 1]
            else:
                dp[i] = dp[i - 1]
        return dp[-1]
</code></pre>
<p>高频，二刷：可以无限买卖=可以抓住所有价格上升的机会，可优化为O(1)空间的算法，因为不在乎中间利润，中间利润累加上去返回</p>
<h3 id="91-Decode-Ways-Medium"><a href="#91-Decode-Ways-Medium" class="headerlink" title="91. Decode Ways (Medium)"></a><a href="https://leetcode.com/problems/decode-ways/" target="_blank" rel="noopener">91. Decode Ways (Medium)</a></h3><pre><code class="html">A message containing letters from A-Z is being encoded to numbers using the following mapping:

&#39;A&#39; -&gt; 1
&#39;B&#39; -&gt; 2
...
&#39;Z&#39; -&gt; 26
Given a non-empty string containing only digits, determine the total number of ways to decode it.

Example 1:

Input: &quot;12&quot;
Output: 2
Explanation: It could be decoded as &quot;AB&quot; (1 2) or &quot;L&quot; (12).
Example 2:

Input: &quot;226&quot;
Output: 3
Explanation: It could be decoded as &quot;BZ&quot; (2 26), &quot;VF&quot; (22 6), or &quot;BBF&quot; (2 2 6).
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def numDecodings(self, s: str) -&gt; int:
        if s[0] == &quot;0&quot;:
            return 0
        n = len(s)
        f = [0] * (n + 1)
        f[0] = f[1] = 1
        for i in range(2, n + 1):
            one = int(s[i - 1: i])
            two = int(s[i - 2: i])
            if one &gt; 0:
                f[i] += f[i - 1]
            if 10 &lt;= two &lt;= 26:
                f[i] += f[i - 2]
        return f[n]
</code></pre>
<p>总结：f[n]为第n个数的方案数，0个字1个方案，1个字1个方案，…if 10 &lt;= two &lt;= 26:…防止误判“05”， “06”等情况</p>
<h3 id="62-Unique-Paths-Medium"><a href="#62-Unique-Paths-Medium" class="headerlink" title="62. Unique Paths (Medium)"></a><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">62. Unique Paths (Medium)</a></h3><pre><code class="html">A robot is located at the top-left corner of a m x n grid (marked &#39;Start&#39; in the diagram below).

The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked &#39;Finish&#39; in the diagram below).

How many possible unique paths are there?

Above is a 7 x 3 grid. How many possible unique paths are there?

Note: m and n will be at most 100.

Example 1:

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -&gt; Right -&gt; Down
2. Right -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Right
Example 2:

Input: m = 7, n = 3
Output: 28
</code></pre>
<pre><code class="python">class Solution:
    def uniquePaths(self, m: int, n: int) -&gt; int:
        if m == 1 or n == 1:
            return 1
        f = [[1 for _ in range(m + 1)] for _ in range(n + 1)]
        for r in range(2, n + 1):
            for c in range(2, m + 1):
                f[r][c] = f[r - 1][c] + f[r][c - 1]
        return f[n][m]
</code></pre>
<p>高频</p>
<h3 id="53-Maximum-Subarray-Easy"><a href="#53-Maximum-Subarray-Easy" class="headerlink" title="53. Maximum Subarray (Easy)"></a><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">53. Maximum Subarray (Easy)</a></h3><pre><code class="html">Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.
</code></pre>
<pre><code class="python">class Solution:
    def maxSubArray(self, nums: List[int]) -&gt; int:
        dp = [0] * len(nums)
        dp[0] = nums[0]
        for i in range(1, len(nums)):
            if dp[i - 1] &lt; 0:
                dp[i] = nums[i]
            else:
                dp[i] = dp[i - 1] + nums[i]
        return max(dp)
</code></pre>
<p>高频，面经：维萨…if <strong>dp[i - 1]</strong> &lt; 0:…</p>
<h3 id="63-Unique-Paths-II-Medium"><a href="#63-Unique-Paths-II-Medium" class="headerlink" title="63. Unique Paths II (Medium)"></a><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">63. Unique Paths II (Medium)</a></h3><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>Now consider if some obstacles are added to the grids. How many unique paths would there be?<br>An obstacle and empty space is marked as 1 and 0 respectively in the grid.<br>Note: m and n will be at most 100.</p>
<p>Example 1:<br>Input:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>Output: 2<br>Explanation:<br>There is one obstacle in the middle of the 3x3 grid above.<br>There are two ways to reach the bottom-right corner:</p>
<ol>
<li>Right -&gt; Right -&gt; Down -&gt; Down</li>
<li>Down -&gt; Down -&gt; Right -&gt; Right</li>
</ol>
<p>space O(mxn):</p>
<pre><code class="python">class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:
      m, n = len(obstacleGrid), len(obstacleGrid[0])
      dp = [[0] * n for _ in range(m)]
      obs = False
      for i, v in enumerate(obstacleGrid[0]):
          if v == 1:
              obs = True
          if obs:
              dp[0][i] = 0
          else:
              dp[0][i] = 1
      obs = False
      for i in range(m):
          if obstacleGrid[i][0] == 1:
              obs = True
          if obs:
              dp[i][0] = 0
          else:
              dp[i][0] = 1
      for r in range(1, m):
          for c in range(1, n):
              if obstacleGrid[r][c] == 1:
                  dp[r][c] = 0
              else:
                  dp[r][c] = dp[r - 1][c] + dp[r][c - 1]
      return dp[m - 1][n - 1]
</code></pre>
<p>space: O(n):</p>
<pre><code class="python">class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -&gt; int:
        m, n = len(obstacleGrid), len(obstacleGrid[0])
        dp = [0] * n
        dp[0] = 1 if obstacleGrid[0][0] == 0 else 0
        obs = False
        for i in range(1, n):
            if obstacleGrid[0][i] == 1:
                obs = True
            if obs:
                dp[i] = 0
            else:
                dp[i] = dp[i - 1]
        for r in range(1, m):
            dp[0] = dp[0] if obstacleGrid[r][0] == 0 else 0
            for c in range(1, n):
                if obstacleGrid[r][c] == 1:
                    dp[c] = 0
                else:
                    dp[c] = dp[c - 1] + dp[c]
        return dp[n - 1]
</code></pre>
<p>高频<br>面经：Celo, todo: space: O(1)</p>
<h3 id="64-Minimum-Path-Sum-Medium"><a href="#64-Minimum-Path-Sum-Medium" class="headerlink" title="64. Minimum Path Sum (Medium)"></a><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">64. Minimum Path Sum (Medium)</a></h3><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p>
<p>Note: You can only move either down or right at any point in time.</p>
<p>Example:</p>
<p>Input:<br>[<br>  [1,3,1],<br>  [1,5,1],<br>  [4,2,1]<br>]<br>Output: 7<br>Explanation: Because the path 1→3→1→1→1 minimizes the sum.<br>空间O(m*n):</p>
<pre><code class="python">class Solution:
    def minPathSum(self, grid: List[List[int]]) -&gt; int:
        rl = len(grid)
        cl = len(grid[0])
        f = [[0 for _ in range(cl)] for _ in range(rl)]
        f[0][0] = grid[0][0]
        for r in range(1, rl):
            f[r][0] = f[r - 1][0] + grid[r][0]
        for c in range(1, cl):
            f[0][c] = f[0][c - 1] + grid[0][c]
        for r in range(1, rl):
            for c in range(1, cl):
                f[r][c] = min(f[r - 1][c], f[r][c - 1]) + grid[r][c]
        return f[rl - 1][cl - 1]
</code></pre>
<p>空间O(n):</p>
<pre><code class="python">class Solution:
    def minPathSum(self, grid: List[List[int]]) -&gt; int:
        m, n = len(grid), len(grid[0])
        dp = [0] * n
        dp[0] = grid[0][0]
        for c in range(1, n):
            dp[c] = dp[c - 1] + grid[0][c]
        for r in range(1, m):
            dp[0] += grid[r][0]
            for c in range(1, n):
                dp[c] = min(dp[c], dp[c - 1]) + grid[r][c]
        return dp[-1]
</code></pre>
<p>高频：优化空间可以将二维数组f压缩为一维，因为答案不关心中间值<br>面经：Amazon。优化空间</p>
<h3 id="72-Edit-Distance-Hard"><a href="#72-Edit-Distance-Hard" class="headerlink" title="72. Edit Distance (Hard)"></a><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">72. Edit Distance (Hard)</a></h3><pre><code class="html">Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.

You have the following 3 operations permitted on a word:

Insert a character
Delete a character
Replace a character
Example 1:

Input: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;
Output: 3
Explanation:
horse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)
rorse -&gt; rose (remove &#39;r&#39;)
rose -&gt; ros (remove &#39;e&#39;)
Example 2:

Input: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;
Output: 5
Explanation:
intention -&gt; inention (remove &#39;t&#39;)
inention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)
enention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)
exention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)
exection -&gt; execution (insert &#39;u&#39;)
</code></pre>
<pre><code class="python">
</code></pre>
<p>高频：f 为从 m 的前 i 个变到 n 的前 j 个字符串所需的最少步骤, 第前 i 个字符串 == word1[i - 1]…if word1[i - 1] == word2[j - 1]: f[i][j] = f[i - 1][j - 1]…else: f[i][j] = min(f[i - 1][j - 1], f[i - 1][j], f[i][j - 1]) + 1</p>
<h3 id="132-Palindrome-Partitioning-II-Hard"><a href="#132-Palindrome-Partitioning-II-Hard" class="headerlink" title="132. Palindrome Partitioning II (Hard)"></a><a href="https://leetcode.com/problems/palindrome-partitioning-ii/" target="_blank" rel="noopener">132. Palindrome Partitioning II (Hard)</a></h3><pre><code class="html">Given a string s, partition s such that every substring of the partition is a palindrome.

Return the minimum cuts needed for a palindrome partitioning of s.

Example:

Input: &quot;aab&quot;
Output: 1
Explanation: The palindrome partitioning [&quot;aa&quot;,&quot;b&quot;] could be produced using 1 cut.
</code></pre>
<pre><code class="python">class Solution:
    def minCut(self, s: str) -&gt; int:
        n = len(s)
        f = [0 for _ in range(n)]
        p = [[False for _ in range(n + 1)] for _ in range(n + 1)]
        for i in range(n):
            f[i] = i
            for j in range(i + 1):
                if s[i] == s[j] and (i - j &lt; 2 or p[j + 1][i - 1]):
                    p[j][i] = True
                    f[i] = 0 if j == 0 else min(f[i], f[j - 1] + 1)
        return f[n - 1]
</code></pre>
<p>高频：f为从0到i(i从0到n-1)字符串的mincut数。p为从j到i是否是回文，因为j（从0到i，i从0到n-1）可能到j+1，因此p […in range(n <strong>+ 1</strong>)]。…for j in range(i + 1):…and (i - j &lt; 2 <strong>or</strong> p[j + 1][i - 1])…</p>
<h3 id="5-Longest-Palindromic-Substring-Medium"><a href="#5-Longest-Palindromic-Substring-Medium" class="headerlink" title="5. Longest Palindromic Substring (Medium)"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. Longest Palindromic Substring (Medium)</a></h3><pre><code class="html">Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.

Example 1:

Input: &quot;babad&quot;
Output: &quot;bab&quot;
Note: &quot;aba&quot; is also a valid answer.
Example 2:

Input: &quot;cbbd&quot;
Output: &quot;bb&quot;
</code></pre>
<p>暴力：</p>
<pre><code class="python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        ans = &quot;&quot;
        def palAroundI(l, r):
            while l &gt;= 0 and r &lt; len(s) and s[l] == s[r]:
                l -= 1
                r += 1
            return s[l + 1 : r]
        for i in range(len(s)):
            t = palAroundI(i, i)
            if len(t) &gt; len(ans):
                ans = t
            t = palAroundI(i, i + 1)
            if len(t) &gt; len(ans):
                ans = t
        return ans
</code></pre>
<p>dp：</p>
<pre><code class="python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        ans = &quot;&quot;
        n = len(s)
        f = [[False] * n for _ in range(n)]
        for j in range(n):
            for i in range(j + 1):
                if s[i] == s[j] and (j - i &lt;= 2 or f[i + 1][j - 1]):
                    f[i][j] = True
                if f[i][j] and len(ans) &lt; j - i + 1:
                    ans = s[i:j + 1]
        return ans
</code></pre>
<p>高频：暴力：…def palAroundI(l, r):…return s[l + 1, r]…。dp: f为从i到j是否为回文串，…for j in range(n): for i in range(j <strong>+ 1</strong>):…</p>
<h3 id="55-Jump-Game-Medium"><a href="#55-Jump-Game-Medium" class="headerlink" title="55. Jump Game (Medium)"></a><a href="https://leetcode.com/problems/jump-game/" target="_blank" rel="noopener">55. Jump Game (Medium)</a></h3><pre><code class="html">Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

Example 1:

Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
Example 2:

Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.
</code></pre>
<p>dp:</p>
<pre><code class="python">class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        f = [0 for _ in range(len(nums))]
        f[0] = nums[0]
        for i in range(1, len(nums)):
            f[i] = max(f[i - 1], nums[i - 1]) - 1
            if f[i] &lt; 0:
                return False
        return True
</code></pre>
<p>greedy:</p>
<pre><code class="python">class Solution:
    def canJump(self, nums: List[int]) -&gt; bool:
        reach = 0
        for i, n in enumerate(nums):
            if reach &gt;= len(nums) - 1:
                return True
            if i &gt; reach:
                return False
            reach = max(reach, i + n)
</code></pre>
<p>高频：dp: f为当前位置的剩余步数 f[i] = max(f[i - 1], nums[i - 1]) - 1。greedy：reach为从0点能到的最远距离</p>
<h3 id="96-Unique-Binary-Search-Trees-Medium"><a href="#96-Unique-Binary-Search-Trees-Medium" class="headerlink" title="96. Unique Binary Search Trees (Medium)"></a><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">96. Unique Binary Search Trees (Medium)</a></h3><pre><code class="html">Given n, how many structurally unique BST&#39;s (binary search trees) that store values 1 ... n?

Example:

Input: 3
Output: 5
Explanation:
Given n = 3, there are a total of 5 unique BST&#39;s:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</code></pre>
<pre><code class="python">class Solution:
    def numTrees(self, n: int) -&gt; int:
        f = [0] * (n + 1)
        f[0] = f[1] = 1
        for i in range(2, n + 1):
            for j in range(1, i + 1):
                f[i] += f[j - 1] * f[i - j]
        return f[n]
</code></pre>
<p>高频：关键是要知道f推导公式：g[i, n]代表以i为root的bst，f[n] = g[1, n] + g[2, n] +…+ g[n, n], g[i, n] = f[i - 1] * f[n - i]。以i为root的左边是i - 1个数，右边是n - i个数，具体数值对于f方案数并不是那么重要。</p>
<h3 id="95-Unique-Binary-Search-Trees-II-Medium"><a href="#95-Unique-Binary-Search-Trees-II-Medium" class="headerlink" title="95. Unique Binary Search Trees II (Medium)"></a><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">95. Unique Binary Search Trees II (Medium)</a></h3><pre><code class="html">Given an integer n, generate all structurally unique BST&#39;s (binary search trees) that store values 1 ... n.

Example:

Input: 3
Output:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
Explanation:
The above output corresponds to the 5 unique BST&#39;s shown below:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
</code></pre>
<pre><code class="python">class Solution:
    def generateTrees(self, n: int) -&gt; List[TreeNode]:
        if n == 0:
            return []
        def gen(s, e):
            if s &gt; e: return [None]
            res = []
            for i in range(s, e + 1):
                for l in gen(s, i - 1):
                    for r in gen(i + 1, e):
                        root = TreeNode(i)
                        root.left = l
                        root.right = r
                        res.append(root)
            return res
        return gen(1, n)
</code></pre>
<p>高频：看着像非主流dp题。…def gen(s, e):…res = []…for l in gen(s, i <strong>- 1</strong>):…return gen(1, n)</p>
<h3 id="198-House-Robber-Easy"><a href="#198-House-Robber-Easy" class="headerlink" title="198. House Robber (Easy)"></a><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">198. House Robber (Easy)</a></h3><pre><code class="html">You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.

Example 1:

Input: [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
             Total amount you can rob = 1 + 3 = 4.
Example 2:

Input: [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
             Total amount you can rob = 2 + 9 + 1 = 12.
</code></pre>
<pre><code class="python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        n = len(nums)
        if n == 0:
            return 0
        if n == 1:
            return nums[0]
        f = [0] * n
        f[0] = nums[0]
        f[1] = max(nums[0], nums[1])
        for i in range(2, n):
            f[i] = max(f[i - 2] + nums[i], f[i - 1])
        return f[n - 1]
</code></pre>
<p>高频：f[i]有两个决定， 一个是抢，或不抢当前的房，取max即可<br>面经：Quora。</p>
<h3 id="213-House-Robber-II-Medium"><a href="#213-House-Robber-II-Medium" class="headerlink" title="213. House Robber II (Medium)"></a><a href="https://leetcode.com/problems/house-robber-ii/" target="_blank" rel="noopener">213. House Robber II (Medium)</a></h3><p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night.<br>Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police.</p>
<p>Example 1:<br>Input: [2,3,2]<br>Output: 3<br>Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2),<br>             because they are adjacent houses.<br>Example 2:<br>Input: [1,2,3,1]<br>Output: 4<br>Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).<br>             Total amount you can rob = 1 + 3 = 4.</p>
<pre><code class="python">class Solution:
    def rob(self, nums: List[int]) -&gt; int:
        n = len(nums)
        if n == 0:
            return 0
        if n == 1:
            return nums[0]
        if n == 2:
            return max(nums[0], nums[1])
        dp1 = [0] * n
        dp2 = [0] * n
        dp1[0] = nums[0]
        dp2[0] = 0
        dp1[1] = dp1[0]
        dp2[1] = nums[1]
        for i in range(2, n - 1):
            dp1[i] = max(dp1[i - 1], dp1[i - 2] + nums[i])
            dp2[i] = max(dp2[i - 1], dp2[i - 2] + nums[i])
        return max(dp1[n - 2], max(dp2[n - 2], dp2[n - 3] + nums[n - 1]))
</code></pre>
<p>面经：Quora。</p>
<h3 id="10-Regular-Expression-Matching-Hard"><a href="#10-Regular-Expression-Matching-Hard" class="headerlink" title="10. Regular Expression Matching (Hard)"></a><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10. Regular Expression Matching (Hard)</a></h3><pre><code class="html">Given an input string (s) and a pattern (p), implement regular expression matching with support for &#39;.&#39; and &#39;*&#39;.

&#39;.&#39; Matches any single character.
&#39;*&#39; Matches zero or more of the preceding element.
The matching should cover the entire input string (not partial).

Note:

s could be empty and contains only lowercase letters a-z.
p could be empty and contains only lowercase letters a-z, and characters like . or *.
Example 1:

Input:
s = &quot;aa&quot;
p = &quot;a&quot;
Output: false
Explanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.
Example 2:

Input:
s = &quot;aa&quot;
p = &quot;a*&quot;
Output: true
Explanation: &#39;*&#39; means zero or more of the precedeng element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.
Example 3:

Input:
s = &quot;ab&quot;
p = &quot;.*&quot;
Output: true
Explanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.
Example 4:

Input:
s = &quot;aab&quot;
p = &quot;c*a*b&quot;
Output: true
Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;.
Example 5:

Input:
s = &quot;mississippi&quot;
p = &quot;mis*is*p*.&quot;
Output: false
</code></pre>
<p>DP：</p>
<pre><code class="python">class Solution:
    def isMatch(self, s: str, p: str) -&gt; bool:
        ls, lp = len(s), len(p)
        f = [[False] * (lp + 1) for _ in range(ls + 1)]
        f[0][0] = True
        for j in range(1, lp):
            if p[j] == &#39;*&#39;:
                f[0][j + 1] = f[0][j - 1]
        for i in range(ls):
            for j in range(lp):
                if p[j] == &#39;.&#39; or s[i] == p[j]:
                    f[i + 1][j + 1] = f[i][j]
                if p[j] == &#39;*&#39;:
                    if s[i] != p[j - 1] and p[j - 1] != &#39;.&#39;:
                        f[i + 1][j + 1] = f[i + 1][j - 1]
                    else:
                        f[i + 1][j + 1] =  f[i][j + 1] or f[i + 1][j] or f[i + 1][j - 1]
        return f[-1][-1]
</code></pre>
<p>Backtracking：</p>
<pre><code class="python">class Solution:
    def isMatch(self, s: str, p: str) -&gt; bool:
        if not p:
            return not s
        first_matched = len(s) &gt; 0 and (s[0] == p[0] or p[0] == &#39;.&#39;)
        if len(p) &gt; 1 and p[1] == &#39;*&#39;:
            return self.isMatch(s, p[2:]) or (first_matched and self.isMatch(s[1:], p))
        else:
            return first_matched and self.isMatch(s[1:], p[1:])
</code></pre>
<p>高频：dp:怎么写都不是很直观，目前采用range和p[],s[]取值简化写。当前p的字符位’.’或者和s当前字符相等即前进。’*‘分两种情况：1.p前一位不是’.’与当前s字符也不等，a<em> counts as empty 2.等或者是’.(\</em>)’，a<em> counts as multiple a / a</em> counts as single a / a<em> counts as empty。时间空间复杂度均为O(ls</em>lp)<br>backtracking: 关键要用s = “aab” p = “c<em>a</em>b”来记住如果有*，要么忽略这部分p，要么删掉第一个匹配的字符这个算法。…if not p:…firt_matched = len(s) &gt; 0 and (s[0]…)…时间空间复杂度：<a href="https://leetcode.com/problems/regular-expression-matching/solution/" target="_blank" rel="noopener">leetcode solution</a>里有，较复杂</p>
<h3 id="44-Wildcard-Matching-Hard"><a href="#44-Wildcard-Matching-Hard" class="headerlink" title="44. Wildcard Matching (Hard)"></a><a href="https://leetcode.com/problems/wildcard-matching/" target="_blank" rel="noopener">44. Wildcard Matching (Hard)</a></h3><p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘<em>‘.<br>‘?’ Matches any single character.<br>‘</em>‘ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>
<p>Note:<br>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like ? or * .</p>
<p>Example 1:<br>Input:<br>s = “aa”<br>p = “a”<br>Output: false<br>Explanation: “a” does not match the entire string “aa”.</p>
<p>Example 2:<br>Input:<br>s = “aa”<br>p = “<em>“<br>Output: true<br>Explanation: ‘</em>‘ matches any sequence.</p>
<p>Example 3:<br>Input:<br>s = “cb”<br>p = “?a”<br>Output: false<br>Explanation: ‘?’ matches ‘c’, but the second letter is ‘a’, which does not match ‘b’.</p>
<p>Example 4:<br>Input:<br>s = “adceb”<br>p = “<em>a</em>b”<br>Output: true<br>Explanation: The first ‘<em>‘ matches the empty sequence, while the second ‘</em> ‘ matches the substring “dce”.</p>
<p>Example 5:<br>Input:<br>s = “acdcb”<br>p = “a*c?b”<br>Output: false</p>
<pre><code class="python">class Solution:
    def isMatch(self, s: str, p: str) -&gt; bool:
        ls, lp = len(s), len(p)
        dp = [[False] * (lp + 1) for _ in range(ls + 1)]
        dp[0][0] = True
        for j in range(lp):
            if p[j] == &#39;*&#39;:
                dp[0][j + 1] = dp[0][j]
        for i in range(ls):
            for j in range(lp):
                if s[i] == p[j] or p[j] == &#39;?&#39;:
                    dp[i + 1][j + 1] = dp[i][j]
                elif p[j] == &#39;*&#39;:
                    dp[i + 1][j + 1] = dp[i][j + 1] or dp[i + 1][j]
        return dp[-1][-1]
</code></pre>
<p>高频：和上题统一的模板，当j位置的p是’?’ 或者和i位置���s相等时，均前进…f[i + 1][j + 1] = f[i][j],当j位置是’*‘时，两种情况，<em> count as multiple char / </em> count as single char …f[i + 1][j + 1] = f[i][j + 1] or f[i + 1][j]…<br>面经：Quora。</p>
<h3 id="139-Word-Break-Medium"><a href="#139-Word-Break-Medium" class="headerlink" title="139. Word Break (Medium)"></a><a href="https://leetcode.com/problems/word-break/" target="_blank" rel="noopener">139. Word Break (Medium)</a></h3><p>Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</p>
<p>Note:<br>The same word in the dictionary may be reused multiple times in the segmentation.<br>You may assume the dictionary does not contain duplicate words.</p>
<p>Example 1:<br>Input: s = “leetcode”, wordDict = [“leet”, “code”]<br>Output: true<br>Explanation: Return true because “leetcode” can be segmented as “leet code”.</p>
<p>Example 2:<br>Input: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>Output: true<br>Explanation: Return true because “applepenapple” can be segmented as “apple pen apple”.<br>             Note that you are allowed to reuse a dictionary word.<br>Example 3:<br>Input: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>Output: false<br>从当前位置往前找：</p>
<pre><code class="python">class Solution(object):
    def wordBreak(self, s, wordDict):
        dp = [False] * (len(s) + 1)
        dp[0] = True
        for i, c in enumerate(s):
            j = i
            while j &gt;= 0:
                if s[j:i + 1] in wordDict and dp[j]:
                    dp[i + 1] = True
                    break
                j -= 1
        return dp[-1]
</code></pre>
<p>面经：Amazon，维萨。删掉了之前的解法，这个解法更适合现场想</p>
<h3 id="377-Combination-Sum-IV-Medium"><a href="#377-Combination-Sum-IV-Medium" class="headerlink" title="377. Combination Sum IV (Medium)"></a><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">377. Combination Sum IV (Medium)</a></h3><p>Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.</p>
<p>Example:<br>nums = [1, 2, 3]<br>target = 4</p>
<p>The possible combination ways are:<br>(1, 1, 1, 1)<br>(1, 1, 2)<br>(1, 2, 1)<br>(1, 3)<br>(2, 1, 1)<br>(2, 2)<br>(3, 1)</p>
<p>Note that different sequences are counted as different combinations.<br>Therefore the output is 7.</p>
<p>Follow up:<br>What if negative numbers are allowed in the given array?<br>How does it change the problem?<br>What limitation we need to add to the question to allow negative numbers?<br>memo[4] = memo[4 - 1] + memo[4 - 3] + memo[4 - 1]的方法：</p>
<pre><code class="python">class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        memo = [-1] * (target + 1)
        memo[0] = 1
        return self.helper(nums, target, memo)
    def helper(self, nums, target, memo):
        if memo[target] != -1:
            return memo[target]
        cnt = 0
        for i in range(len(nums)):
            if target &gt;= nums[i]:
                cnt += self.helper(nums, target - nums[i], memo)
        memo[target] = cnt
        return cnt
</code></pre>
<p>稍微DFS一点的模板：</p>
<pre><code class="python">class Solution:
    def combinationSum4(self, nums: List[int], target: int) -&gt; int:
        return self.dfs(nums, target, {})
    def dfs(self, nums, target, memo):
        if target == 0:
            return 1
        if target in memo:
            return memo[target]
        res = 0
        for i in range(len(nums)):
            if target &gt;= nums[i]:
                res += self.dfs(nums, target - nums[i], memo)
        memo[target] = res
        return res
</code></pre>
<p>面经：Amazon。</p>
<h3 id="152-Maximum-Product-Subarray-Medium"><a href="#152-Maximum-Product-Subarray-Medium" class="headerlink" title="152. Maximum Product Subarray (Medium)"></a><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">152. Maximum Product Subarray (Medium)</a></h3><p>Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>Example 1:<br>Input: [2,3,-2,4]<br>Output: 6<br>Explanation: [2,3] has the largest product 6.</p>
<p>Example 2:<br>Input: [-2,0,-1]<br>Output: 0<br>Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</p>
<pre><code class="python">class Solution(object):
    def maxProduct(self, nums):
        dpMin = [0] * len(nums)
        dpMax = [0] * len(nums)
        ans = dpMin[0] = dpMax[0] = nums[0]
        for i in range(1, len(nums)):
            dpMin[i] = min(min(dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i]), nums[i])
            dpMax[i] = max(max(dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i]), nums[i])
            ans = max(ans, dpMax[i])
        return ans
</code></pre>
<p>O(1)空间：</p>
<pre><code class="python">class Solution(object):
    def maxProduct(self, nums):
        ans = preMin = preMax = nums[0]
        for v in nums[1:]:
            dpMin = min(preMin * v, preMax * v, v)
            dpMax = max(preMin * v, preMax * v, v)
            preMin, preMax = dpMin, dpMax
            ans = max(ans, dpMax)
        return ans
</code></pre>
<p>面经： 维萨。核心是要保存当前最大和最小值，因为最小值随时可能乘出最大值。 优化是用O(1)空间， 因为仅需要中途算出来的最大值</p>
<h3 id="516-Longest-Palindromic-Subsequence-Medium"><a href="#516-Longest-Palindromic-Subsequence-Medium" class="headerlink" title="516. Longest Palindromic Subsequence (Medium)"></a><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">516. Longest Palindromic Subsequence (Medium)</a></h3><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:<br>Input:<br>“bbbab”<br>Output:<br>4<br>One possible longest palindromic subsequence is “bbbb”.</p>
<p>Example 2:<br>Input:<br>“cbbd”<br>Output:<br>2<br>One possible longest palindromic subsequence is “bb”.</p>
<p>brute force recursion O(2^n) worst case TLE:</p>
<pre><code class="python">class Solution:
    def longestPalindromeSubseq(self, s: str) -&gt; int:
        return self.helper(0, len(s) - 1, s)
    def helper(self, l, r, s):
        if l == r:
            return 1
        if l &gt; r:
            return 0
        return 2 + self.helper(l + 1, r - 1, s) if s[l] == s[r] else max(self.helper(l + 1, r, s), self.helper(l, r - 1, s))
</code></pre>
<p>add memo time complexity to O(n^2):</p>
<pre><code class="python">class Solution:
    def longestPalindromeSubseq(self, s: str) -&gt; int:
        return self.helper(0, len(s) - 1, s, {})
    def helper(self, l, r, s, memo):
        if l == r:
            return 1
        if l &gt; r:
            return 0
        if (l, r) in memo:
            return memo[(l, r)]
        memo[(l, r)] = 2 + self.helper(l + 1, r - 1, s, memo) if s[l] == s[r] else max(self.helper(l + 1, r, s, memo), self.helper(l, r - 1, s, memo))
        return memo[(l, r)]
</code></pre>
<p>dp:</p>
<pre><code class="python">class Solution:
    def longestPalindromeSubseq(self, s: str) -&gt; int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]
        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])
        return dp[0][-1]
</code></pre>
<p>面经：维萨<br>Subsequence is not substring. Every sub string is a sub sequence<br>e.g. leetcode<br>Both substring and subsequence leet, code<br>Sub sequence ltcode, eecode, ecode, ltde // and not substring<br>dp：从 i 到 j， dp[i][i] = 1, i从最后一个开始，j从i+1开始，构建斜上半个dpmatrix, 如果s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</p>
<h3 id="300-Longest-Increasing-Subsequence-Medium"><a href="#300-Longest-Increasing-Subsequence-Medium" class="headerlink" title="300. Longest Increasing Subsequence (Medium)"></a><a href="https://leetcode.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. Longest Increasing Subsequence (Medium)</a></h3><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p>
<p>Example:<br>Input: [10,9,2,5,3,7,101,18]<br>Output: 4<br>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.<br>Note:</p>
<p>There may be more than one LIS combination, it is only necessary for you to return the length.<br>Your algorithm should run in O(n2) complexity.<br>Follow up: Could you improve it to O(n log n) time complexity?</p>
<p>Bruteforce O(2^n), TLE:</p>
<pre><code class="python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        return self.helper(nums, -sys.maxsize, 0)
    def helper(self, nums, prev, idx):
        if idx == len(nums):
            return 0
        take = 0
        if prev &lt; nums[idx]:
            take = 1 + self.helper(nums, nums[idx], idx + 1)
        notake = self.helper(nums, prev, idx + 1)
        return max(take, notake)
</code></pre>
<p>DP: O(n^2):</p>
<pre><code class="python">class Solution:
    def lengthOfLIS(self, nums: List[int]) -&gt; int:
        if not nums:
            return 0
        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(0, i):
                if nums[i] &gt; nums[j]:
                    dp[i] = max(dp[i], dp[j] + 1)
        return max(dp)
</code></pre>
<p>面经：Amazon。<a href="https://www.youtube.com/watch?v=fV-TF4OvZpk" target="_blank" rel="noopener">这个youtube视频讲的不错</a></p>
<h3 id="1143-Longest-Common-Subsequence-Medium"><a href="#1143-Longest-Common-Subsequence-Medium" class="headerlink" title="1143. Longest Common Subsequence (Medium)"></a><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">1143. Longest Common Subsequence (Medium)</a></h3><p>Given two strings text1 and text2, return the length of their longest common subsequence.<br>A subsequence of a string is a new string generated from the original string with some characters(can be none) deleted without changing the relative order of the remaining characters. (eg, “ace” is a subsequence of “abcde” while “aec” is not). A common subsequence of two strings is a subsequence that is common to both strings.<br>If there is no common subsequence, return 0.</p>
<p>Example 1:<br>Input: text1 = “abcde”, text2 = “ace”<br>Output: 3<br>Explanation: The longest common subsequence is “ace” and its length is 3.</p>
<p>Example 2:<br>Input: text1 = “abc”, text2 = “abc”<br>Output: 3<br>Explanation: The longest common subsequence is “abc” and its length is 3.</p>
<p>Example 3:<br>Input: text1 = “abc”, text2 = “def”<br>Output: 0<br>Explanation: There is no such common subsequence, so the result is 0.</p>
<p>Constraints:<br>1 &lt;= text1.length &lt;= 1000<br>1 &lt;= text2.length &lt;= 1000<br>The input strings consist of lowercase English characters only.</p>
<pre><code class="python">class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -&gt; int:
        m, n = len(text1), len(text2)
        dp = [[0] * (n + 1) for _ in range(m + 1)]
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if text1[i - 1] == text2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1] + 1
                else:
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
        return dp[-1][-1]
</code></pre>
<p>一刷：<a href="https://www.cnblogs.com/sunll9201/p/9996161.html" target="_blank" rel="noopener">系列题讲解还有可以输出具体LCS的代码</a></p>
<h3 id="1027-Longest-Arithmetic-Sequence-Medium"><a href="#1027-Longest-Arithmetic-Sequence-Medium" class="headerlink" title="1027. Longest Arithmetic Sequence (Medium)"></a><a href="https://leetcode.com/problems/longest-arithmetic-sequence/" target="_blank" rel="noopener">1027. Longest Arithmetic Sequence (Medium)</a></h3><p>Given an array A of integers, return the length of the longest arithmetic subsequence in A.<br>Recall that a subsequence of A is a list A[i_1], A[i_2], …, A[i_k] with 0 &lt;= i_1 &lt; i_2 &lt; … &lt; i_k &lt;= A.length - 1, and that a sequence B is arithmetic if B[i+1] - B[i] are all the same value (for 0 &lt;= i &lt; B.length - 1).</p>
<p>Example 1:<br>Input: [3,6,9,12]<br>Output: 4<br>Explanation:<br>The whole array is an arithmetic sequence with steps of length = 3.</p>
<p>Example 2:<br>Input: [9,4,7,2,10]<br>Output: 3<br>Explanation:<br>The longest arithmetic subsequence is [4,7,10].</p>
<p>Example 3:<br>Input: [20,1,15,3,10,5,8]<br>Output: 4<br>Explanation:<br>The longest arithmetic subsequence is [20,15,10,5].</p>
<p>Note:<br>2 &lt;= A.length &lt;= 2000<br>0 &lt;= A[i] &lt;= 10000</p>
<pre><code class="python">class Solution:
    def longestArithSeqLength(self, A: List[int]) -&gt; int:
        dp = {}
        for i in range(len(A) - 1):
            for j in range(i + 1, len(A)):
                dp[j, A[j] - A[i]] = dp.get((i, A[j] - A[i]), 1) + 1
        return max(dp.values())
</code></pre>
<p>一刷：Facebook tag</p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="322-Coin-Change-Medium"><a href="#322-Coin-Change-Medium" class="headerlink" title="322. Coin Change (Medium)"></a><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">322. Coin Change (Medium)</a></h3><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p>
<p>Example 1:<br>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1</p>
<p>Example 2:<br>Input: coins = [2], amount = 3<br>Output: -1</p>
<p>Note:<br>You may assume that you have an infinite number of each kind of coin.</p>
<pre><code class="python">class Solution:
    def coinChange(self, coins: List[int], amount: int) -&gt; int:
        MAX = float(&quot;inf&quot;)
        dp = [MAX] * (amount + 1)
        dp[0] = 0
        for i in range(1, amount + 1):
            dp[i] = min([dp[i - coin] if i - coin &gt;= 0 else MAX for coin in coins]) + 1
        return dp[-1] if dp[-1] != MAX else -1
</code></pre>
<p>面经: Cruise。sys.maxsize和float(‘inf’)是有区别的，前者可以被+1，后者+1还是inf<br>面经：维萨</p>
<h3 id="474-Ones-and-Zeroes-Medium"><a href="#474-Ones-and-Zeroes-Medium" class="headerlink" title="474. Ones and Zeroes (Medium)"></a><a href="https://leetcode.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. Ones and Zeroes (Medium)</a></h3><p>In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.<br>For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.<br>Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.<br>Note:<br>The given numbers of 0s and 1s will both not exceed 100<br>The size of given string array won’t exceed 600.</p>
<p>Example 1:<br>Input: Array = {“10”, “0001”, “111001”, “1”, “0”}, m = 5, n = 3<br>Output: 4<br>Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0”</p>
<p>Example 2:<br>Input: Array = {“10”, “0”, “1”}, m = 1, n = 1<br>Output: 2<br>Explanation: You could form “10”, but then you’d have nothing left. Better form “0” and “1”.<br>Bruteforce:</p>
<pre><code class="python">class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int:
            return self.helper(strs, m, n, 0, collections.defaultdict(dict))
        def helper(self, strs, m, n, idx, memo):
            if m in memo and n in memo[m] and idx in memo[m][n]:
                return memo[m][n][idx]
            memo.setdefault(m, {}).setdefault(n, {})[idx] = 0
            for i in range(idx, len(strs)):
                zeros, ones = strs[i].count(&#39;0&#39;), strs[i].count(&#39;1&#39;)
                if zeros &lt;= m and ones &lt;= n:
                    memo[m][n][idx] = max(memo[m][n][idx], self.helper(strs, m - zeros, n - ones, i + 1, memo) + 1)
            return memo[m][n][idx]
</code></pre>
<p>DP:</p>
<pre><code class="python">class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -&gt; int:
        dp = [[[0] * (n + 1) for _ in range(m + 1)] for _ in range(len(strs) + 1)]
        for i in range(1, len(strs) + 1):
            zeros, ones = strs[i - 1].count(&#39;0&#39;), strs[i - 1].count(&#39;1&#39;)
            for j in range(m + 1):
                for k in range(n + 1):
                    if j &gt;= zeros and k &gt;= ones:
                        dp[i][j][k] = max(dp[i - 1][j][k], dp[i - 1][j - zeros][k - ones] + 1)
                    else:
                        dp[i][j][k] = dp[i - 1][j][k]
        return dp[-1][-1][-1]
</code></pre>
<p>面经：Cruise。可惜两种方法都过不了python3的oj</p>
<h3 id="416-Partition-Equal-Subset-Sum-Medium"><a href="#416-Partition-Equal-Subset-Sum-Medium" class="headerlink" title="416. Partition Equal Subset Sum (Medium)"></a><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">416. Partition Equal Subset Sum (Medium)</a></h3><p>Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.</p>
<p>Note:<br>Each of the array element will not exceed 100.<br>The array size will not exceed 200.</p>
<p>Example 1:<br>Input: [1, 5, 11, 5]<br>Output: true<br>Explanation: The array can be partitioned as [1, 5, 5] and [11].</p>
<p>Example 2:<br>Input: [1, 2, 3, 5]<br>Output: false<br>Explanation: The array cannot be partitioned into equal sum subsets.</p>
<pre><code class="python">class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        target = sum(nums)
        if target % 2 != 0:
            return False
        target //= 2
        if max(nums) &gt; target:
            return False
        dp = [[False] * (target + 1) for _ in range(len(nums) + 1)]
        dp[0][0] = True
        for i in range(1, len(nums) + 1):
            dp[i][0] = True
        for j in range(1, target + 1):
            dp[0][j] = False
        for i in range(1, len(nums) + 1):
            for j in range(1, target + 1):
                dp[i][j] = dp[i - 1][j]
                if j &gt;= nums[i - 1]:
                    dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]
        return dp[-1][-1]
</code></pre>
<p>面经：Cruise。dp为从前i个序列中是否能有组成和为j的组合，要么用i - 1，要么不用i - 1，用的话那么取决于dp[i - 1][j - nums[i -1]]</p>
<h1 id="Recursion-递归-Backtracking"><a href="#Recursion-递归-Backtracking" class="headerlink" title="Recursion 递归 / Backtracking"></a>Recursion 递归 / Backtracking</h1><h3 id="13-Roman-to-Integer-Easy"><a href="#13-Roman-to-Integer-Easy" class="headerlink" title="13. Roman to Integer (Easy)"></a><a href="https://leetcode.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. Roman to Integer (Easy)</a></h3><pre><code class="html">Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, two is written as II in Roman numeral, just two one&#39;s added together. Twelve is written as, XII, which is simply X + II. The number twenty seven is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9.
X can be placed before L (50) and C (100) to make 40 and 90.
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer. Input is guaranteed to be within the range from 1 to 3999.

Example 1:

Input: &quot;III&quot;
Output: 3
Example 2:

Input: &quot;IV&quot;
Output: 4
Example 3:

Input: &quot;IX&quot;
Output: 9
Example 4:

Input: &quot;LVIII&quot;
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 5:

Input: &quot;MCMXCIV&quot;
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def romanToInt(self, s: str) -&gt; int:
        mapping = {
            &#39;M&#39;: 1000,
            &#39;D&#39;: 500,
            &#39;C&#39;: 100,
            &#39;L&#39;: 50,
            &#39;X&#39;: 10,
            &#39;V&#39;: 5,
            &#39;I&#39;: 1,
        }
        if not s:
            return 0
        if len(s) == 1:
            return mapping[s]
        first, second, rest = s[0], s[1], s[2:]
        if mapping[first] &lt; mapping[second]:
            return mapping[second] - mapping[first] + self.romanToInt(rest)
        else:
            return mapping[first] + self.romanToInt(second + rest)
</code></pre>
<p>总结：…else: return <strong>mapping[first] + self.romanToInt(second + rest)</strong></p>
<h3 id="50-Pow-x-n-Medium"><a href="#50-Pow-x-n-Medium" class="headerlink" title="50. Pow(x, n) (Medium)"></a><a href="https://leetcode.com/problems/powx-n/description/" target="_blank" rel="noopener">50. Pow(x, n) (Medium)</a></h3><pre><code class="html">Implement pow(x, n), which calculates x raised to the power n (xn).

Example 1:

Input: 2.00000, 10
Output: 1024.00000
Example 2:

Input: 2.10000, 3
Output: 9.26100
Example 3:

Input: 2.00000, -2
Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
Note:

-100.0 &lt; x &lt; 100.0
n is a 32-bit signed integer, within the range [−231, 231 − 1]
</code></pre>
<pre><code class="python">class Solution:
    def myPow(self, x: float, n: int) -&gt; float:
        return self.helper(x, n) if n &gt; 0 else 1/self.helper(x, -n)
    def helper(self, x, n):
        if n == 0:
            return 1
        res = self.helper(x, n//2)
        return res * res if n % 2 == 0 else x * res * res
</code></pre>
<p>总结：有固定写法套路的题目， 不值得做。<br>高频：稍微精简了一点，为高频而刷</p>
<h3 id="4-Median-of-Two-Sorted-Arrays-Hard"><a href="#4-Median-of-Two-Sorted-Arrays-Hard" class="headerlink" title="4. Median of Two Sorted Arrays (Hard)"></a><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">4. Median of Two Sorted Arrays (Hard)</a></h3><pre><code class="html">There are two sorted arrays nums1 and nums2 of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume nums1 and nums2 cannot be both empty.

Example 1:

nums1 = [1, 3]
nums2 = [2]

The median is 2.0
Example 2:

nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
</code></pre>
<pre><code class="python">class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -&gt; float:
        if not nums1 and not nums2:
            return 0
        m, n = len(nums1), len(nums2)
        def findK(a, b, k):
            if not a:
                return b[k]
            if not b:
                return a[k]
            ai, bi = len(a) // 2, len(b) // 2
            am, bm = a[ai], b[bi]
            if k &gt; ai + bi:
                if am &lt; bm:
                    return findK(a[ai + 1:], b, k - ai - 1)
                else:
                    return findK(a, b[bi + 1:], k - bi - 1)
            else:
                if am &gt; bm:
                    return findK(a[:ai], b, k)
                else:
                    return findK(a, b[:bi], k)
        if (m + n) % 2 == 0:
            return findK(nums1, nums2, (m + n) // 2) * 0.5 + findK(nums1, nums2, (m + n) //2 - 1) * 0.5
        else:
            return findK(nums1, nums2, (m + n) // 2)
</code></pre>
<p>高频：总长度是奇偶数分开做，…def findK(a, b, k):…if…:…return findK(a[ai + 1:], b, k - ai - 1)…</p>
<h1 id="Bit-Manipulation"><a href="#Bit-Manipulation" class="headerlink" title="Bit Manipulation"></a>Bit Manipulation</h1><h3 id="231-Power-of-Two-Easy"><a href="#231-Power-of-Two-Easy" class="headerlink" title="231. Power of Two (Easy)"></a><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="noopener">231. Power of Two (Easy)</a></h3><pre><code class="html">Given an integer, write a function to determine if it is a power of two.

Example 1:

Input: 1
Output: true
Explanation: 2^0 = 1
Example 2:

Input: 16
Output: true
Explanation: 2^4 = 16
Example 3:

Input: 218
Output: false
</code></pre>
<p>思路：既然是 bit manipulation 的题，肯定是变成 bits 操作，稍微看一下 2 的倍数都是 1 后面全是 0。怎么用 python 检查这个比较没思路。。。</p>
<pre><code class="python">class Solution:
    def isPowerOfTwo(self, n):
        &quot;&quot;&quot;
        :type n: int
        :rtype: bool
        &quot;&quot;&quot;
        if n == 1:
            return True
        return bin(n)[2:] == &#39;1&#39;.ljust(len(bin(n)) - 2, &#39;0&#39;)
</code></pre>
<p>总结：看了三年前比较屌的 trick 是 return n &amp; n - 1, 当然 bin 这种土办法也 OK 的。</p>
<h3 id="29-Divide-Two-Integers-Medium"><a href="#29-Divide-Two-Integers-Medium" class="headerlink" title="29. Divide Two Integers (Medium)"></a><a href="https://leetcode.com/problems/divide-two-integers/description/" target="_blank" rel="noopener">29. Divide Two Integers (Medium)</a></h3><pre><code class="html">Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.

Return the quotient after dividing dividend by divisor.

The integer division should truncate toward zero.

Example 1:

Input: dividend = 10, divisor = 3
Output: 3
Example 2:

Input: dividend = 7, divisor = -3
Output: -2
Note:

Both dividend and divisor will be 32-bit signed integers.
The divisor will never be 0.
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 231 − 1 when the division result overflows.
</code></pre>
<pre><code class="python">class Solution:
    def divide(self, dividend: int, divisor: int) -&gt; int:
        positive = (dividend &lt; 0) is (divisor &lt; 0)
        dividend, divisor = abs(dividend), abs(divisor)
        ans = 0
        while dividend &gt;= divisor:
            t, p = divisor, 1
            while dividend &gt;= t:
                dividend -= t
                ans += p
                t &lt;&lt;= 1
                p &lt;&lt;= 1
        if not positive:
            ans = -ans
        if not (-pow(2, 31) &lt;= ans &lt;= pow(2, 31) - 1):
            return pow(2, 31) - 1
        return ans
</code></pre>
<p>高频：…while dividend &gt;= divisor: …while dividend &gt;= t: dividend -= t; ans += p; t &lt;&lt;= 1; p &lt;&lt;= 1…</p>
<h3 id="89-Gray-Code-Medium"><a href="#89-Gray-Code-Medium" class="headerlink" title="89. Gray Code (Medium)"></a><a href="https://leetcode.com/problems/gray-code/" target="_blank" rel="noopener">89. Gray Code (Medium)</a></h3><pre><code class="html">The gray code is a binary numeral system where two successive values differ in only one bit.

Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.

Example 1:

Input: 2
Output: [0,1,3,2]
Explanation:
00 - 0
01 - 1
11 - 3
10 - 2

For a given n, a gray code sequence may not be uniquely defined.
For example, [0,2,3,1] is also a valid gray code sequence.

00 - 0
10 - 2
11 - 3
01 - 1
Example 2:

Input: 0
Output: [0]
Explanation: We define the gray code sequence to begin with 0.
             A gray code sequence of n has size = 2n, which for n = 0 the size is 20 = 1.
             Therefore, for n = 0 the gray code sequence is [0].
</code></pre>
<pre><code class="python">class Solution:
    def grayCode(self, n: int) -&gt; List[int]:
        ans = [0]
        for i in range(n):
            ans += [x + pow(2, i) for x in reversed(ans)]
        return ans
</code></pre>
<p>高频：这道题无面试意义，考点在于知道格雷码的<a href="https://www.cnblogs.com/grandyang/p/4315649.html" target="_blank" rel="noopener">镜像性质</a></p>
<h1 id="Regular-Expression"><a href="#Regular-Expression" class="headerlink" title="Regular Expression"></a>Regular Expression</h1><h3 id="65-Valid-Number-Hard"><a href="#65-Valid-Number-Hard" class="headerlink" title="65. Valid Number (Hard)"></a><a href="https://leetcode.com/problems/valid-number/" target="_blank" rel="noopener">65. Valid Number (Hard)</a></h3><p>Validate if a given string can be interpreted as a decimal number.</p>
<pre><code>Some examples:
&quot;0&quot; =&gt; true
&quot; 0.1 &quot; =&gt; true
&quot;abc&quot; =&gt; false
&quot;1 a&quot; =&gt; false
&quot;2e10&quot; =&gt; true
&quot; -90e3   &quot; =&gt; true
&quot; 1e&quot; =&gt; false
&quot;e3&quot; =&gt; false
&quot; 6e-1&quot; =&gt; true
&quot; 99e2.5 &quot; =&gt; false
&quot;53.5e93&quot; =&gt; true
&quot; --6 &quot; =&gt; false
&quot;-+3&quot; =&gt; false
&quot;95a54e53&quot; =&gt; false
</code></pre><p>Note: It is intended for the problem statement to be ambiguous. You should gather all requirements up front before implementing one. However, here is a list of characters that can be in a valid decimal number:<br>Numbers 0-9<br>Exponent - “e”<br>Positive/negative sign - “+”/“-“<br>Decimal point - “.”<br>Of course, the context of these characters also matters in the input.</p>
<pre><code class="python">class Solution:
    def isNumber(self, s: str) -&gt; bool:
        pattern = r&#39;^[+-]?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(e[+-]?[0-9]+)?$&#39;
        return re.match(pattern, s.strip()) != None
</code></pre>
<p>高频：学习了^, [], ?, +, *, |, $的用法</p>
<h1 id="Multi-threading-多线程"><a href="#Multi-threading-多线程" class="headerlink" title="Multi-threading 多线程"></a>Multi-threading 多线程</h1><h3 id="1114-Print-in-Order-Easy"><a href="#1114-Print-in-Order-Easy" class="headerlink" title="1114. Print in Order (Easy)"></a><a href="https://leetcode.com/problems/print-in-order/" target="_blank" rel="noopener">1114. Print in Order (Easy)</a></h3><p>Suppose we have a class:</p>
<pre><code>public class Foo {
  public void first() { print(&quot;first&quot;); }
  public void second() { print(&quot;second&quot;); }
  public void third() { print(&quot;third&quot;); }
}
</code></pre><p>The same instance of Foo will be passed to three different threads. Thread A will call first(), thread B will call second(), and thread C will call third(). Design a mechanism and modify the program to ensure that second() is executed after first(), and third() is executed after second().</p>
<pre><code>Example 1:
Input: [1,2,3]
Output: &quot;firstsecondthird&quot;
Explanation: There are three threads being fired asynchronously. The input [1,2,3] means thread A calls first(), thread B calls second(), and thread C calls third(). &quot;firstsecondthird&quot; is the correct output.

Example 2:
Input: [1,3,2]
Output: &quot;firstsecondthird&quot;
Explanation: The input [1,3,2] means thread A calls first(), thread B calls third(), and thread C calls second(). &quot;firstsecondthird&quot; is the correct output.
</code></pre><p>Note:<br>We do not know how the threads will be scheduled in the operating system, even though the numbers in the input seems to imply the ordering. The input format you see is mainly to ensure our tests’ comprehensiveness.</p>
<pre><code class="python">class Foo:
    def __init__(self):
        import threading
        self.barrier1 = threading.Barrier(2)
        self.barrier2 = threading.Barrier(2)

    def first(self, printFirst: &#39;Callable[[], None]&#39;) -&gt; None:
        printFirst()
        self.barrier1.wait()

    def second(self, printSecond: &#39;Callable[[], None]&#39;) -&gt; None:
        self.barrier1.wait()
        printSecond()
        self.barrier2.wait()

    def third(self, printThird: &#39;Callable[[], None]&#39;) -&gt; None:
        self.barrier2.wait()
        printThird()
</code></pre>
<p>一刷：Lock, Event, Semaphore或Condition也可以解。<a href="https://leetcode.com/problems/print-in-order/discuss/335939/5-Python-threading-solutions-(Barrier-Lock-Event-Semaphore-Condition)-with-explanation" target="_blank" rel="noopener">这篇讨论帖很好</a></p>
<h3 id="1115-Print-FooBar-Alternately-Medium"><a href="#1115-Print-FooBar-Alternately-Medium" class="headerlink" title="1115. Print FooBar Alternately (Medium)"></a><a href="https://leetcode.com/problems/print-foobar-alternately/" target="_blank" rel="noopener">1115. Print FooBar Alternately (Medium)</a></h3><p>Suppose you are given the following code:</p>
<pre><code>class FooBar {
  public void foo() {
    for (int i = 0; i &lt; n; i++) {
      print(&quot;foo&quot;);
    }
  }
  public void bar() {
    for (int i = 0; i &lt; n; i++) {
      print(&quot;bar&quot;);
    }
  }
}
</code></pre><p>The same instance of FooBar will be passed to two different threads. Thread A will call foo() while thread B will call bar(). Modify the given program to output “foobar” n times.</p>
<pre><code>Example 1:
Input: n = 1
Output: &quot;foobar&quot;
Explanation: There are two threads being fired asynchronously. One of them calls foo(), while the other calls bar(). &quot;foobar&quot; is being output 1 time.

Example 2:
Input: n = 2
Output: &quot;foobarfoobar&quot;
Explanation: &quot;foobar&quot; is being output 2 times.
</code></pre><pre><code class="python">class FooBar:
    def __init__(self, n):
        import threading
        self.n = n
        self.fooLock = threading.Lock()
        self.barLock = threading.Lock()
        self.fooLock.acquire()

    def foo(self, printFoo: &#39;Callable[[], None]&#39;) -&gt; None:
        for i in range(self.n):
            self.barLock.acquire()
            printFoo()
            self.fooLock.release()


    def bar(self, printBar: &#39;Callable[[], None]&#39;) -&gt; None:
        for i in range(self.n):
            self.fooLock.acquire()
            printBar()
            self.barLock.release()
</code></pre>
<p>一刷：Barrier, Condition, Event, Semaphore也可以解</p>
<h3 id="1116-Print-Zero-Even-Odd-Medium"><a href="#1116-Print-Zero-Even-Odd-Medium" class="headerlink" title="1116. Print Zero Even Odd (Medium)"></a><a href="https://leetcode.com/problems/print-zero-even-odd/" target="_blank" rel="noopener">1116. Print Zero Even Odd (Medium)</a></h3><p>Suppose you are given the following code:</p>
<pre><code>class ZeroEvenOdd {
  public ZeroEvenOdd(int n) { ... }      // constructor
  public void zero(printNumber) { ... }  // only output 0&#39;s
  public void even(printNumber) { ... }  // only output even numbers
  public void odd(printNumber) { ... }   // only output odd numbers
}
</code></pre><p>The same instance of ZeroEvenOdd will be passed to three different threads:<br>Thread A will call zero() which should only output 0’s.<br>Thread B will call even() which should only ouput even numbers.<br>Thread C will call odd() which should only output odd numbers.<br>Each of the threads is given a printNumber method to output an integer. Modify the given program to output the series 010203040506… where the length of the series must be 2n.</p>
<p>Example 1:<br>Input: n = 2<br>Output: “0102”<br>Explanation: There are three threads being fired asynchronously. One of them calls zero(), the other calls even(), and the last one calls odd(). “0102” is the correct output.</p>
<p>Example 2:<br>Input: n = 5<br>Output: “0102030405”</p>
<pre><code class="python">class ZeroEvenOdd:
    def __init__(self, n):
        import threading
        self.n = n
        self.cur = 0
        self.semas = [threading.Semaphore() for _ in range(3)]
        self.semas[0].acquire()
        self.semas[1].acquire()

    # printNumber(x) outputs &quot;x&quot;, where x is an integer.
    def zero(self, printNumber: &#39;Callable[[int], None]&#39;) -&gt; None:
        for _ in range(self.n):
            self.semas[2].acquire()
            printNumber(0)
            self.cur += 1
            self.semas[self.cur % 2].release()

    def even(self, printNumber: &#39;Callable[[int], None]&#39;) -&gt; None:
        for _ in range(self.n // 2):
            self.semas[0].acquire()
            printNumber(self.cur)
            self.semas[2].release()

    def odd(self, printNumber: &#39;Callable[[int], None]&#39;) -&gt; None:
        for _ in range((self.n + 1) // 2):
            self.semas[1].acquire()
            printNumber(self.cur)
            self.semas[2].release()
</code></pre>
<p>一刷</p>
<h3 id="1117-Building-H2O-Medium"><a href="#1117-Building-H2O-Medium" class="headerlink" title="1117. Building H2O (Medium)"></a><a href="https://leetcode.com/problems/building-h2o/" target="_blank" rel="noopener">1117. Building H2O (Medium)</a></h3><p>There are two kinds of threads, oxygen and hydrogen. Your goal is to group these threads to form water molecules. There is a barrier where each thread has to wait until a complete molecule can be formed. Hydrogen and oxygen threads will be given releaseHydrogen and releaseOxygen methods respectively, which will allow them to pass the barrier. These threads should pass the barrier in groups of three, and they must be able to immediately bond with each other to form a water molecule. You must guarantee that all the threads from one molecule bond before any other threads from the next molecule do.</p>
<p>In other words:<br>If an oxygen thread arrives at the barrier when no hydrogen threads are present, it has to wait for two hydrogen threads.<br>If a hydrogen thread arrives at the barrier when no other threads are present, it has to wait for an oxygen thread and another hydrogen thread.<br>We don’t have to worry about matching the threads up explicitly; that is, the threads do not necessarily know which other threads they are paired up with. The key is just that threads pass the barrier in complete sets; thus, if we examine the sequence of threads that bond and divide them into groups of three, each group should contain one oxygen and two hydrogen threads.</p>
<p>Write synchronization code for oxygen and hydrogen molecules that enforces these constraints.</p>
<p>Example 1:<br>Input: “HOH”<br>Output: “HHO”<br>Explanation: “HOH” and “OHH” are also valid answers.</p>
<p>Example 2:<br>Input: “OOHHHH”<br>Output: “HHOHHO”<br>Explanation: “HOHHHO”, “OHHHHO”, “HHOHOH”, “HOHHOH”, “OHHHOH”, “HHOOHH”, “HOHOHH” and “OHHOHH” are also valid answers.</p>
<p>Constraints:<br>Total length of input string will be 3n, where 1 ≤ n ≤ 20.<br>Total number of H will be 2n in the input string.<br>Total number of O will be n in the input string.</p>
<pre><code class="python">class H2O:
    def __init__(self):
        import threading
        self.H = 0
        self.O = 0
        self.lock = threading.Lock()

    def hydrogen(self, releaseHydrogen: &#39;Callable[[], None]&#39;) -&gt; None:
        with self.lock:
            self.releaseH = releaseHydrogen
            self.H += 1
            self.helper()

    def oxygen(self, releaseOxygen: &#39;Callable[[], None]&#39;) -&gt; None:
        with self.lock:
            self.releaseO = releaseOxygen
            self.O += 1
            self.helper()

    def helper(self):
        if self.H &gt;= 2 and self.O &gt;= 1:
            self.releaseH()
            self.releaseH()
            self.releaseO()
            self.H -= 2
            self.O -= 1
</code></pre>
<p>一刷</p>
<h1 id="Misc-杂类型，偏门-特殊算法"><a href="#Misc-杂类型，偏门-特殊算法" class="headerlink" title="Misc 杂类型，偏门/特殊算法"></a>Misc 杂类型，偏门/特殊算法</h1><h3 id="7-Reverse-Integer-Easy"><a href="#7-Reverse-Integer-Easy" class="headerlink" title="7. Reverse Integer (Easy)"></a><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="noopener">7. Reverse Integer (Easy)</a></h3><pre><code class="html">Given a 32-bit signed integer, reverse digits of an integer.

Example 1:

Input: 123
Output: 321
Example 2:

Input: -123
Output: -321
Example 3:

Input: 120
Output: 21
Note:
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
</code></pre>
<p>高频</p>
<pre><code class="python">class Solution:
    def reverse(self, x: int) -&gt; int:
        if x == 0:
            return 0
        if x &gt; 0:
            sign = 1
        else:
            sign = -1
            x = -x
        ans = 0
        while x:
            ans = ans * 10 + x % 10
            x //= 10
        if (sign == 1 and ans &gt; pow(2, 31) - 1) or (sign == -1 and ans &gt; pow(2, 31)):
            return 0
        return sign * ans
</code></pre>
<p>总结：…while x:…ans = ans * 10 + x <strong>%</strong> 10。转成字符串[::-1]是更优解</p>
<h3 id="31-Next-Permutation-Medium"><a href="#31-Next-Permutation-Medium" class="headerlink" title="31. Next Permutation (Medium)"></a><a href="https://leetcode.com/problems/next-permutation/" target="_blank" rel="noopener">31. Next Permutation (Medium)</a></h3><pre><code class="html">Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.

If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).

The replacement must be in-place and use only constant extra memory.

Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.

1,2,3 → 1,3,2
3,2,1 → 1,2,3
1,1,5 → 1,5,1
</code></pre>
<pre><code class="python">class Solution:
    def nextPermutation(self, nums: List[int]) -&gt; None:
        #find pivot
        pivot = -1
        for i in range(len(nums) - 1, 0, -1):
            if nums[i - 1] &lt; nums[i]:
                pivot = i - 1
                break
        if pivot == -1:
            self.reverse(nums, 0, len(nums) - 1)
            return
        #find rightmost &gt; element in surfix and swap
        for i in range(len(nums) - 1, pivot, -1):
            if nums[i] &gt; nums[pivot]:
                rightmostI = i
                break
        nums[pivot], nums[rightmostI] = nums[rightmostI], nums[pivot]
        #reverse surfix
        self.reverse(nums, pivot + 1, len(nums) - 1)
    def reverse(self, nums, l, r):
        while l &lt; r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1
</code></pre>
<p>高频，面经：维萨。lexicographical顺序的下一个排列<a href="https://www.nayuki.io/page/next-lexicographical-permutation-algorithm" target="_blank" rel="noopener">算法描述</a>，删去基于<a href="https://leetcode.com/problems/next-permutation/discuss/13867/C%2B%2B-from-Wikipedia" target="_blank" rel="noopener">十四世纪的一个算法</a>代码。知识型的不适合面试。</p>
<h3 id="60-Permutation-Sequence-Medium"><a href="#60-Permutation-Sequence-Medium" class="headerlink" title="60. Permutation Sequence (Medium)"></a><a href="https://leetcode.com/problems/permutation-sequence/" target="_blank" rel="noopener">60. Permutation Sequence (Medium)</a></h3><pre><code class="html">The set [1,2,3,...,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, we get the following sequence for n = 3:

&quot;123&quot;
&quot;132&quot;
&quot;213&quot;
&quot;231&quot;
&quot;312&quot;
&quot;321&quot;
Given n and k, return the kth permutation sequence.

Note:

Given n will be between 1 and 9 inclusive.
Given k will be between 1 and n! inclusive.
Example 1:

Input: n = 3, k = 3
Output: &quot;213&quot;
Example 2:

Input: n = 4, k = 9
Output: &quot;2314&quot;
</code></pre>
<pre><code class="python">class Solution:
    def getPermutation(self, n: int, k: int) -&gt; str:
        nums = [i + 1 for i in range(n)]
        ans = &quot;&quot;
        while len(nums) &gt; 1:
            import math
            nf = math.factorial(n - 1)
            i = (k - 1) // nf
            k = (k - 1) % nf + 1
            n -= 1
            ans += str(nums.pop(i))
        ans += str(nums.pop())
        return ans
</code></pre>
<p>高频：和上题一样无语。讨论区的python答案都不太行，提交结果里的高频可以。…while len(el) &gt; 1:…i = (k - 1) <strong>//</strong> nf; k = (k - 1) % nf <strong>+ 1</strong>…</p>
<h3 id="238-Product-of-Array-Except-Self-Medium"><a href="#238-Product-of-Array-Except-Self-Medium" class="headerlink" title="238. Product of Array Except Self (Medium)"></a><a href="https://leetcode.com/problems/product-of-array-except-self/" target="_blank" rel="noopener">238. Product of Array Except Self (Medium)</a></h3><p>Given an array nums of n integers where n &gt; 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].</p>
<p>Example:<br>Input:  [1,2,3,4]<br>Output: [24,12,8,6]<br>Note: Please solve it without division and in O(n).</p>
<p>Follow up:<br>Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)</p>
<pre><code class="python">class Solution:
    def productExceptSelf(self, nums: List[int]) -&gt; List[int]:
        p = 1
        n = len(nums)
        ans = [0] * n
        for i in range(n):
            ans[i] = p
            p *= nums[i]
        p = 1
        for i in range(n - 1, -1, -1):
            ans[i] *= p
            p *= nums[i]
        return ans
</code></pre>
<p>高频, 面经：Amazon。这题取决于知道从左到右，再从右到左把元素乘一遍放到结果里这个方法</p>
<h3 id="92-Reverse-Linked-List-II-Medium"><a href="#92-Reverse-Linked-List-II-Medium" class="headerlink" title="92. Reverse Linked List II (Medium)"></a><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. Reverse Linked List II (Medium)</a></h3><p>Reverse a linked list from position m to n. Do it in one-pass.<br>Note: 1 ≤ m ≤ n ≤ length of list.</p>
<p>Example:<br>Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4<br>Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</p>
<pre><code class="python">class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -&gt; ListNode:
        dummy = ListNode(0)
        dummy.next = head
        pre = dummy
        for _ in range(m - 1):
            pre = pre.next
        cur = pre.next
        for _ in range(n - m):
            t = cur.next
            cur.next = t.next
            t.next = pre.next
            pre.next = t
        return dummy.next
</code></pre>
<p>高频，二刷：…cur = p.next…for…t = cur.next; cur.next = t.next…</p>
<h3 id="84-Largest-Rectangle-in-Histogram-Hard"><a href="#84-Largest-Rectangle-in-Histogram-Hard" class="headerlink" title="84. Largest Rectangle in Histogram (Hard)"></a><a href="https://leetcode.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84. Largest Rectangle in Histogram (Hard)</a></h3><p>Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.<br><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram.png" alt="histogram example"><br>Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].<br><img src="https://assets.leetcode.com/uploads/2018/10/12/histogram_area.png" alt="largetst rectangle example"><br>The largest rectangle is shown in the shaded area, which has area = 10 unit.</p>
<p>Example:<br>Input: [2,1,5,6,2,3]<br>Output: 10</p>
<pre><code class="python">class Solution:
    def largestRectangleArea(self, heights: List[int]) -&gt; int:
</code></pre>
<p>一刷：有三个油管视频讲这个算法，<a href="https://www.youtube.com/watch?v=RVIh0snn4Qc" target="_blank" rel="noopener">目前对我最有用的是这个</a>， <a href="https://www.geeksforgeeks.org/largest-rectangle-under-histogram/" target="_blank" rel="noopener">python代码可以看这个</a> todo</p>
<h3 id="42-Trapping-Rain-Water-Hard"><a href="#42-Trapping-Rain-Water-Hard" class="headerlink" title="42. Trapping Rain Water (Hard)"></a><a href="https://leetcode.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42. Trapping Rain Water (Hard)</a></h3><p>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.<br><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="trapping rain water example"><br>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</p>
<p>Example:<br>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p>
<pre><code class="python">class Solution:
    def trap(self, height: List[int]) -&gt; int:
        n = len(height)
        maxL = [0] * n
        maxLSoFar = 0
        for i, h in enumerate(height):
            if h &gt; maxLSoFar:
                maxLSoFar = h
            maxL[i] = maxLSoFar
        maxR = [0] * n
        maxRSoFar = 0
        for i in range(n - 1, -1, -1):
            if height[i] &gt; maxRSoFar:
                maxRSoFar = height[i]
            maxR[i] = maxRSoFar
        ans = 0
        for i, h in enumerate(height):
            ans += min(maxL[i], maxR[i]) - h if min(maxL[i], maxR[i]) - h else 0
        return ans
</code></pre>
<p>一刷：<a href="https://leetcode.com/problems/trapping-rain-water/solution/" target="_blank" rel="noopener">答案</a>中有bruteforce和衍生的类似dp解法。todo: 类似上题stackbased</p>
<h3 id="732-My-Calendar-III-Hard"><a href="#732-My-Calendar-III-Hard" class="headerlink" title="732. My Calendar III (Hard)"></a><a href="https://leetcode.com/problems/my-calendar-iii/" target="_blank" rel="noopener">732. My Calendar III (Hard)</a></h3><p>Implement a MyCalendarThree class to store your events. A new event can always be added.<br>Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end.<br>A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)<br>For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar.<br>Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end)</p>
<pre><code>Example 1:
MyCalendarThree();
MyCalendarThree.book(10, 20); // returns 1
MyCalendarThree.book(50, 60); // returns 1
MyCalendarThree.book(10, 40); // returns 2
MyCalendarThree.book(5, 15); // returns 3
MyCalendarThree.book(5, 10); // returns 3
MyCalendarThree.book(25, 55); // returns 3
Explanation:
The first two events can be booked and are disjoint, so the maximum K-booking is a 1-booking.
The third event [10, 40) intersects the first event, and the maximum K-booking is a 2-booking.
The remaining events cause the maximum K-booking to be only a 3-booking.
Note that the last event locally causes a 2-booking, but the answer is still 3 because
eg. [10, 20), [10, 40), and [5, 15) are still triple booked.
</code></pre><p>Note:<br>The number of calls to MyCalendarThree.book per test case will be at most 400.<br>In calls to MyCalendarThree.book(start, end), start and end are integers in the range [0, 10^9].</p>
<pre><code class="python">class MyCalendarThree:
    def __init__(self):
        self.meetings = []
    def book(self, start: int, end: int) -&gt; int:
        from bisect import insort
        insort(self.meetings, (start, 1))
        insort(self.meetings, (end, -1))
        cumsum = 0
        res = 0
        for _, x in self.meetings:
            cumsum += x
            res = max(cumsum, res)
        return res
</code></pre>
<p>一刷：开始+1， 结束-1， 统计遍历中最大值的方法很巧妙</p>
<h1 id="skipped"><a href="#skipped" class="headerlink" title="skipped"></a>skipped</h1><h2 id="DFS-Union-Find"><a href="#DFS-Union-Find" class="headerlink" title="DFS / Union Find"></a>DFS / Union Find</h2><h3 id="721-Accounts-Merge-Medium"><a href="#721-Accounts-Merge-Medium" class="headerlink" title="721. Accounts Merge (Medium)"></a><a href="https://leetcode.com/problems/accounts-merge/" target="_blank" rel="noopener">721. Accounts Merge (Medium)</a></h3><h2 id="DP-Dynamic-Programming-动态规划-1"><a href="#DP-Dynamic-Programming-动态规划-1" class="headerlink" title="DP Dynamic Programming 动态规划"></a>DP Dynamic Programming 动态规划</h2><h3 id="123-Best-Time-to-Buy-and-Sell-Stock-III-Hard"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III-Hard" class="headerlink" title="123. Best Time to Buy and Sell Stock III (Hard)"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">123. Best Time to Buy and Sell Stock III (Hard)</a></h3><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/108870/Most-consistent-ways-of-dealing-with-the-series-of-stock-problems" target="_blank" rel="noopener">generalized best time to buy and sell stocks</a></p>
<h1 id="非核心题"><a href="#非核心题" class="headerlink" title="非核心题"></a>非核心题</h1><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="LinC-862-Next-Closest-Time-Medium"><a href="#LinC-862-Next-Closest-Time-Medium" class="headerlink" title="LinC 862. Next Closest Time (Medium)"></a><a href="https://www.lintcode.com/problem/next-closest-time/description" target="_blank" rel="noopener">LinC 862. Next Closest Time (Medium)</a></h3><p>Given a time represented in the format “HH:MM”, form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.<br>You may assume the given input string is always valid. For example, “01:34”, “12:09” are all valid. “1:34”, “12:9” are all invalid.</p>
<p>Example：<br>Given time = “19:34”, return “19:39”.<br>Explanation:<br>The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.</p>
<p>Given time = “23:59”, return “22:22”.<br>Explanation:<br>The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day’s time since it is smaller than the input time numerically.</p>
<pre><code class="python">class Solution:
    def nextClosestTime(self, time):
        s = set(time)
        if len(s) == 2:
            return time
        digits = time[0:2] + time[3:5]
        self.ans = &#39;&#39;
        self.minDiff = sys.maxsize
        self.target = int(time[0:2]) * 60 + int(time[3:5])
        self.dfs(digits, &#39;&#39;, 0)
        return self.ans
    def dfs(self, digits, path, start):
        if start == 4:
            # path 产生了一个合法的时间，判断和 target 距离 diff 和 self.minDiff 的关系
            m = int(path[0:2]) * 60 + int(path[2:4])
            diff = m - self.target
            if diff == 0:
                return
            if diff &lt; 0:
                diff = 24 * 60 + diff
            if diff &lt; self.minDiff:
                self.minDiff = diff
                self.ans = path[0:2] + &#39;:&#39; + path[2:4]
            return
        for digit in digits:
            # 处理 path, 把不合适的时间都 continue 过去, 但是怎么判断现在处理的是哪个位置？看了下答案， 其实不需要 enumerate
            if start == 0 and int(digit) &gt; 2:
                continue
            if start == 1 and int(path) * 10 + int(digit) &gt; 23:
                continue
            if start == 2 and int(digit) &gt; 5:
                continue
            if start == 3 and int(path[2:3]) * 10 + int(digit) &gt; 59:
                continue
            self.dfs(digits, path + digit, start + 1)
</code></pre>
<p>总结：python3 把 sys.maxint 改成 sys.maxsize 了。要一次对的话，很多取数的细节需要留心。1.input time 要取 [0:2] [3:5] 来跳过 ‘:’; 2.diff 是负数的时候要用 24 * 60 + diff（而不是 -）；3.for 循环里面的 digit 记得包上 int()</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="637-Average-of-Levels-in-Binary-Tree-Easy"><a href="#637-Average-of-Levels-in-Binary-Tree-Easy" class="headerlink" title="637. Average of Levels in Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">637. Average of Levels in Binary Tree (Easy)</a></h3><p>Given a non-empty binary tree, return the average value of the nodes on each level in the form of an array.</p>
<pre><code>Example 1:
Input:
    3
   / \
  9  20
    /  \
   15   7
Output: [3, 14.5, 11]
</code></pre><p>Explanation:<br>The average value of nodes on level 0 is 3,  on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11].<br>Note:<br>The range of node’s value is in the range of 32-bit signed integer.</p>
<pre><code class="python">class Solution:
    def averageOfLevels(self, root: TreeNode) -&gt; List[float]:
        if not root:
            return []
        res = [[]]
        self.helper(root, res, 0)
        return [sum(x) / len(x) for x in res]
    def helper(self, root, res, depth):
        if not root:
            return
        if depth &gt;= len(res):
            res.append([])
        res[depth].append(root.val)
        self.helper(root.left, res, depth + 1)
        self.helper(root.right, res, depth + 1)
</code></pre>
<p>一刷</p>
<h3 id="270-Closest-Binary-Search-Tree-Value-Easy-带锁"><a href="#270-Closest-Binary-Search-Tree-Value-Easy-带锁" class="headerlink" title="270. Closest Binary Search Tree Value (Easy) 带锁"></a><a href="https://leetcode.com/problems/closest-binary-search-tree-value" target="_blank" rel="noopener">270. Closest Binary Search Tree Value (Easy) 带锁</a></h3><p><a href="https://www.lintcode.com/problem/closest-binary-search-tree-value/description" target="_blank" rel="noopener">Linc 900. Closest Binary Search Tree Value (Easy)</a><br>Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.<br>Given target value is a floating point.<br>You are guaranteed to have only one unique value in the BST that is closest to the target.</p>
<pre><code>Example1
Input: root = {5,4,9,2,#,8,10} and target = 6.124780
Output: 5
Explanation：
Binary tree {5,4,9,2,#,8,10},  denote the following structure:
        5
       / \
     4    9
    /    / \
   2    8  10

Example2
Input: root = {3,2,4,1} and target = 4.142857
Output: 4
Explanation：
Binary tree {3,2,4,1},  denote the following structure:
     3
    / \
  2    4
 /
1
</code></pre><pre><code class="python">class Solution:
    def closestValue(self, root, target):
        self.ans = root.val
        self.helper(root, target)
        return self.ans
    def helper(self, root, target):
        if not root:
            return
        if abs(root.val - target) &lt; abs(self.ans - target):
            self.ans = root.val
        if root.val &gt; target:
            self.helper(root.left, target)
        elif root.val &lt; target:
            self.helper(root.right, target)
        else:
            self.ans = root.val
            return
</code></pre>
<p>一刷</p>
<h3 id="272-Closest-Binary-Search-Tree-Value-II-Hard-带锁"><a href="#272-Closest-Binary-Search-Tree-Value-II-Hard-带锁" class="headerlink" title="272. Closest Binary Search Tree Value II (Hard) 带锁"></a><a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii" target="_blank" rel="noopener">272. Closest Binary Search Tree Value II (Hard) 带锁</a></h3><p><a href="https://www.lintcode.com/problem/closest-binary-search-tree-value-ii/description" target="_blank" rel="noopener">Linc 901. Closest Binary Search Tree Value II (Hard)</a><br>Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.</p>
<pre><code>Example 1:
Input:
{1}
0.000000
1
Output:
[1]
Explanation：
Binary tree {1},  denote the following structure:
 1

Example 2:
Input:
{3,1,4,#,2}
0.275000
2
Output:
[1,2]
Explanation：
Binary tree {3,1,4,#,2},  denote the following structure:
  3
 /  \
1    4
 \
  2
</code></pre><p>Challenge<br>Assume that the BST is balanced, could you solve it in less than O(n) runtime (where n = total nodes)?</p>
<p>Notice<br>Given target value is a floating point.<br>You may assume k is always valid, that is: k ≤ total nodes.<br>You are guaranteed to have only one unique set of k values in the BST that are closest to the target.</p>
<pre><code class="python">class Solution:
    def closestKValues(self, root, target, k):
        ans = []
        self.helper(root, target, k, ans)
        return [x[1] for x in ans]
    def helper(self, root, target, k, ans):
        if not root:
            return
        import heapq
        heapq.heappush(ans, (-abs(root.val - target), root.val))
        if len(ans) == k + 1:
            heapq.heappop(ans)
        self.helper(root.left, target, k, ans)
        self.helper(root.right, target, k, ans)
</code></pre>
<h3 id="404-Sum-of-Left-Leaves-Easy"><a href="#404-Sum-of-Left-Leaves-Easy" class="headerlink" title="404. Sum of Left Leaves (Easy)"></a><a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">404. Sum of Left Leaves (Easy)</a></h3><p>Find the sum of all left leaves in a given binary tree.</p>
<pre><code>Example:
    3
   / \
  9  20
    /  \
   15   7
</code></pre><p>There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.</p>
<pre><code class="python">class Solution:
    def sumOfLeftLeaves(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        if root.left and not root.left.left and not root.left.right:
            return root.left.val + self.sumOfLeftLeaves(root.right)
        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)
</code></pre>
<p>一刷</p>
<h3 id="653-Two-Sum-IV-Input-is-a-BST-Easy"><a href="#653-Two-Sum-IV-Input-is-a-BST-Easy" class="headerlink" title="653. Two Sum IV - Input is a BST (Easy)"></a><a href="https://leetcode.com/problems/two-sum-iv-input-is-a-bst/" target="_blank" rel="noopener">653. Two Sum IV - Input is a BST (Easy)</a></h3><p>Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.</p>
<pre><code>Example 1:
Input:
    5
   / \
  3   6
 / \   \
2   4   7

Target = 9
Output: True

Example 2:
Input:
    5
   / \
  3   6
 / \   \
2   4   7

Target = 28
Output: False
</code></pre><p>hash表/set方法：</p>
<pre><code class="python">class Solution:
    def findTarget(self, root: TreeNode, k: int) -&gt; bool:
        if not root:
            return False
        seen = set()
        return self.helper(root, k, seen)
    def helper(self, root, k, seen):
        if not root:
            return False
        if k - root.val in seen:
            return True
        seen.add(root.val)
        return self.helper(root.left, k, seen) or self.helper(root.right, k, seen)
</code></pre>
<p>遍历BFS：</p>
<pre><code class="python">class Solution:
    def findTarget(self, root: TreeNode, k: int) -&gt; bool:
        q = [root]
        seen = set()
        while q:
            for _ in range(len(q)):
                n = q.pop(0)
                if k - n.val in seen:
                    return True
                seen.add(n.val)
                if n.left:
                    q.append(n.left)
                if n.right:
                    q.append(n.right)
        return False
</code></pre>
<p>in-order/中序遍历双指针：</p>
<pre><code class="python">class Solution:
    def findTarget(self, root: TreeNode, k: int) -&gt; bool:
        if not root:
            return False
        res = []
        self.inorder(root, res)
        i, j = 0, len(res) - 1
        while i &lt; j:
            t = res[i] + res[j]
            if t == k:
                return True
            elif t &lt; k:
                i += 1
            else:
                j -= 1
        return False
    def inorder(self, root, res):
        if not root:
            return
        self.inorder(root.left, res)
        res.append(root.val)
        self.inorder(root.right, res)
</code></pre>
<p>面经：Amazon。</p>
<h3 id="655-Print-Binary-Tree-Medium"><a href="#655-Print-Binary-Tree-Medium" class="headerlink" title="655. Print Binary Tree (Medium)"></a><a href="https://leetcode.com/problems/print-binary-tree/" target="_blank" rel="noopener">655. Print Binary Tree (Medium)</a></h3><p>Print a binary tree in an m*n 2D string array following these rules:</p>
<ol>
<li>The row number m should be equal to the height of the given binary tree.</li>
<li>The column number n should always be an odd number.</li>
<li>The root node’s value (in string format) should be put in the exactly middle of the first row it can be put. The column and the row where the root node belongs will separate the rest space into two parts (left-bottom part and right-bottom part). You should print the left subtree in the left-bottom part and print the right subtree in the right-bottom part. The left-bottom part and the right-bottom part should have the same size. Even if one subtree is none while the other is not, you don’t need to print anything for the none subtree but still need to leave the space as large as that for the other subtree. However, if two subtrees are none, then you don’t need to leave space for both of them.</li>
<li>Each unused space should contain an empty string “”.</li>
<li>Print the subtrees following the same rules.<br><code>`</code><br>Example 1:<br>Input:<br>  1<br> /<br>2<br>Output:<br>[[“”, “1”, “”],<br>[“2”, “”, “”]]</li>
</ol>
<p>Example 2:<br>Input:<br>     1<br>    / \<br>   2   3<br>    \<br>     4<br>Output:<br>[[“”, “”, “”, “1”, “”, “”, “”],<br> [“”, “2”, “”, “”, “”, “3”, “”],<br> [“”, “”, “4”, “”, “”, “”, “”]]</p>
<p>Example 3:<br>Input:<br>      1<br>     / \<br>    2   5<br>   /<br>  3<br> /<br>4<br>Output:<br>[[“”,  “”,  “”, “”,  “”, “”, “”, “1”, “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“”,  “”,  “”, “2”, “”, “”, “”, “”,  “”,  “”,  “”,  “5”, “”, “”, “”]<br> [“”,  “3”, “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]<br> [“4”, “”,  “”, “”,  “”, “”, “”, “”,  “”,  “”,  “”,  “”,  “”, “”, “”]]</p>
<pre><code>Note: The height of binary tree is in the range of [1, 10].

```python
class Solution:
    def printTree(self, root: TreeNode) -&gt; List[List[str]]:
        h = self.maxDepth(root)
        w = 2 ** h - 1
        ans = [[&quot;&quot;] * w for _ in range(h)]
        self.updateMatrix(root, ans, 0, 0, w - 1)
        return ans
    def maxDepth(self, root):
        if not root:
            return 0
        else:
            return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))
    def updateMatrix(self, root, ans, row, l, r):
        if not root or l &gt; r:
            return
        mid = (l + r) // 2
        ans[row][mid] = str(root.val)
        self.updateMatrix(root.left, ans, row + 1, l, mid - 1)
        self.updateMatrix(root.right, ans, row + 1, mid + 1, r)
</code></pre><p>一刷：比较重要的insight是宽度是2 ** h - 1</p>
<h3 id="701-Insert-into-a-Binary-Search-Tree-Medium"><a href="#701-Insert-into-a-Binary-Search-Tree-Medium" class="headerlink" title="701. Insert into a Binary Search Tree (Medium)"></a><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/description/" target="_blank" rel="noopener">701. Insert into a Binary Search Tree (Medium)</a></h3><p>Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.<br>Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</p>
<pre><code>For example,
Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
You can return this binary search tree:
         4
       /   \
      2     7
     / \   /
    1   3 5
This tree is also valid:
         5
       /   \
      2     7
     / \
    1   3
         \
          4
</code></pre><p>递归：</p>
<pre><code class="python">class Solution:
    def insertIntoBST(self, root, val):
        if val &gt; root.val:
            if root.right:
                self.insertIntoBST(root.right, val)
            else:
                root.right = TreeNode(val)
        if val &lt; root.val:
            if root.left:
                self.insertIntoBST(root.left, val)
            else:
                root.left = TreeNode(val)
        return root
</code></pre>
<p>遍历：</p>
<pre><code class="python">class Solution:
    def insertIntoBST(self, root, val):
        n = TreeNode(val)
        cur = root
        while cur != n:
            if n.val &gt; cur.val:
                if not cur.right:
                    cur.right = n
                cur = cur.right
            else:
                if not cur.left:
                    cur.left = n
                cur = cur.left
        return root
</code></pre>
<p>四刷：遍历：准备好数节点，遍历树直道cur和n相遇，如查到左或右该有此节点的地方不存在，即接上；有没有都往该方向走，</p>
<h3 id="173-Binary-Search-Tree-Iterator-Medium"><a href="#173-Binary-Search-Tree-Iterator-Medium" class="headerlink" title="173. Binary Search Tree Iterator (Medium)"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator/" target="_blank" rel="noopener">173. Binary Search Tree Iterator (Medium)</a></h3><p>Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.<br>Calling next() will return the next smallest number in the BST.</p>
<p>Example:<br><img src="https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png" alt="BST example"></p>
<pre><code>BSTIterator iterator = new BSTIterator(root);
iterator.next();    // return 3
iterator.next();    // return 7
iterator.hasNext(); // return true
iterator.next();    // return 9
iterator.hasNext(); // return true
iterator.next();    // return 15
iterator.hasNext(); // return true
iterator.next();    // return 20
iterator.hasNext(); // return false
</code></pre><p>Note:<br>next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.<br>You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.</p>
<pre><code class="python">class BSTIterator:
    def __init__(self, root: TreeNode):
        self.s = []
        self._inorderLeft(root)

    def next(self) -&gt; int:
        res = self.s.pop()
        if res.right:
            self._inorderLeft(res.right)
        return res.val

    def hasNext(self) -&gt; bool:
        return len(self.s) &gt; 0

    def _inorderLeft(self, root):
        while root:
            self.s.append(root)
            root = root.left
</code></pre>
<p>二刷：目前为O(h)空间，也可以O(n)的空间，还可以非常懒惰的init</p>
<h3 id="1120-Maximum-Average-Subtree-Medium-带锁"><a href="#1120-Maximum-Average-Subtree-Medium-带锁" class="headerlink" title="1120. Maximum Average Subtree (Medium) 带锁"></a><a href="https://leetcode.com/problems/maximum-average-subtree" target="_blank" rel="noopener">1120. Maximum Average Subtree (Medium) 带锁</a></h3><p>Given a binary tree, find the subtree with maximum average. Return the root of the subtree.</p>
<pre><code>Example 1
Input：
{1,-5,11,1,2,4,-2}
Output：11
Explanation:
The tree is look like this:
     1
   /   \
 -5     11
 / \   /  \
1   2 4    -2
The average of subtree of 11 is 4.3333, is the maximun.

Example 2
Input：
{1,-5,11}
Output：11
Explanation:
     1
   /   \
 -5     11
The average of subtree of 1,-5,11 is 2.333,-5,11. So the subtree of 11 is the maximun.
</code></pre><p>Notice<br>LintCode will print the subtree which root is your return node.<br>It’s guaranteed that there is only one subtree with maximum average.</p>
<pre><code class="python">class Solution:
    def findSubtree2(self, root):
        self.ans = (None, -sys.maxsize)
        self.helper(root)
        return self.ans[0]
    def helper(self, root):
        if not root:
            return 0, 0
        l, lCnt = self.helper(root.left)
        r, rCnt = self.helper(root.right)
        avg = (root.val + l * lCnt + r * rCnt) / (lCnt + rCnt + 1)
        if not self.ans[0] or avg &gt; self.ans[1]:
            self.ans = (root, avg)
        return avg, lCnt + rCnt + 1
</code></pre>
<p>一刷</p>
<h3 id="671-Second-Minimum-Node-In-a-Binary-Tree-Easy"><a href="#671-Second-Minimum-Node-In-a-Binary-Tree-Easy" class="headerlink" title="671. Second Minimum Node In a Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/" target="_blank" rel="noopener">671. Second Minimum Node In a Binary Tree (Easy)</a></h3><p>Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node’s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.<br>Given such a binary tree, you need to output the second minimum value in the set made of all the nodes’ value in the whole tree.<br>If no such second minimum value exists, output -1 instead.</p>
<pre><code>Example 1:
Input:
    2
   / \
  2   5
     / \
    5   7
Output: 5
Explanation: The smallest value is 2, the second smallest value is 5.

Example 2:
Input:
    2
   / \
  2   2
Output: -1
Explanation: The smallest value is 2, but there isn&#39;t any second smallest value.
</code></pre><pre><code class="python">class Solution:
    def findSecondMinimumValue(self, root: TreeNode) -&gt; int:
        self.ans = sys.maxsize
        self.smallest = root.val
        self.helper(root)
        return self.ans if self.ans &lt; sys.maxsize else -1
    def helper(self, root):
        if not root:
            return
        if self.smallest &lt; root.val &lt; self.ans:
            self.ans = root.val
        self.helper(root.left)
        self.helper(root.right)
</code></pre>
<p>一刷：O(n) time, O(1) space, O(h) callstack</p>
<h3 id="530-Minimum-Absolute-Difference-in-BST-Easy"><a href="#530-Minimum-Absolute-Difference-in-BST-Easy" class="headerlink" title="530. Minimum Absolute Difference in BST (Easy)"></a><a href="https://leetcode.com/problems/minimum-absolute-difference-in-bst/" target="_blank" rel="noopener">530. Minimum Absolute Difference in BST (Easy)</a></h3><p>Given a binary search tree with non-negative values, find the minimum absolute difference between values of any two nodes.</p>
<pre><code>Example:
Input:
   1
    \
     3
    /
   2
Output:
1
Explanation:
The minimum absolute difference is 1, which is the difference between 2 and 1 (or between 2 and 3).
</code></pre><p>Note: There are at least two nodes in this BST.</p>
<pre><code class="python">class Solution:
    def getMinimumDifference(self, root: TreeNode) -&gt; int:
        self.pre = None
        self.ans = sys.maxsize
        self.inorder(root)
        return self.ans
    def inorder(self, root):
        if not root:
            return
        self.inorder(root.left)
        if self.pre:
            self.ans = min(self.ans, root.val - self.pre.val)
        self.pre = root
        self.inorder(root.right)
</code></pre>
<p>一刷</p>
<h3 id="1008-Construct-Binary-Search-Tree-from-Preorder-Traversal-Medium"><a href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal-Medium" class="headerlink" title="1008. Construct Binary Search Tree from Preorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/" target="_blank" rel="noopener">1008. Construct Binary Search Tree from Preorder Traversal (Medium)</a></h3><p>Return the root node of a binary search tree that matches the given preorder traversal.<br>(Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val.  Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.)</p>
<p>Example 1:<br>Input: [8,5,1,7,10,12]<br>Output: [8,5,10,1,7,null,12]<br><img src="https://assets.leetcode.com/uploads/2019/03/06/1266.png" alt="Construct Binary Search Tree from Preorder Traversal example"></p>
<p>Note:<br>1 &lt;= preorder.length &lt;= 100<br>The values of preorder are distinct.</p>
<pre><code class="python">class Solution:
    def bstFromPreorder(self, preorder: List[int]) -&gt; TreeNode:
        if not preorder:
            return
        root = TreeNode(preorder[0])
        if len(preorder) &gt; 1:
            rIdxs = [i for i, v in enumerate(preorder) if v &gt; preorder[0]]
            if not rIdxs:
                root.left = self.bstFromPreorder(preorder[1:])
            else:
                root.left = self.bstFromPreorder(preorder[1:rIdxs[0]])
                root.right = self.bstFromPreorder(preorder[rIdxs[0]:])
        return root
</code></pre>
<p>一刷：Facebook tag</p>
<h3 id="987-Vertical-Order-Traversal-of-a-Binary-Tree-Medium"><a href="#987-Vertical-Order-Traversal-of-a-Binary-Tree-Medium" class="headerlink" title="987. Vertical Order Traversal of a Binary Tree (Medium)"></a><a href="https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/" target="_blank" rel="noopener">987. Vertical Order Traversal of a Binary Tree (Medium)</a></h3><p>Given a binary tree, return the vertical order traversal of its nodes values.<br>For each node at position (X, Y), its left and right children respectively will be at positions (X-1, Y-1) and (X+1, Y-1).<br>Running a vertical line from X = -infinity to X = +infinity, whenever the vertical line touches some nodes, we report the values of the nodes in order from top to bottom (decreasing Y coordinates).<br>If two nodes have the same position, then the value of the node that is reported first is the value that is smaller.<br>Return an list of non-empty reports in order of X coordinate.  Every report will have a list of values of nodes.</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/01/31/1236_example_1.PNG" alt="Vertical Order Traversal of a Binary Tree exmaple1"><br>Input: [3,9,20,null,null,15,7]<br>Output: [[9],[3,15],[20],[7]]<br>Explanation:<br>Without loss of generality, we can assume the root node is at position (0, 0):<br>Then, the node with value 9 occurs at position (-1, -1);<br>The nodes with values 3 and 15 occur at positions (0, 0) and (0, -2);<br>The node with value 20 occurs at position (1, -1);<br>The node with value 7 occurs at position (2, -2).</p>
<p>Example 2:<br><img src="https://assets.leetcode.com/uploads/2019/01/31/tree2.png" alt="Vertical Order Traversal of a Binary Tree exmaple2"><br>Input: [1,2,3,4,5,6,7]<br>Output: [[4],[2],[1,5,6],[3],[7]]<br>Explanation:<br>The node with value 5 and the node with value 6 have the same position according to the given scheme.<br>However, in the report “[1,5,6]”, the node value of 5 comes first since 5 is smaller than 6.</p>
<p>Note:<br>The tree will have between 1 and 1000 nodes.<br>Each node’s value will be between 0 and 1000.</p>
<pre><code class="python">class Solution:
    def verticalTraversal(self, root: TreeNode) -&gt; List[List[int]]:
        from collections import defaultdict
        mapping = defaultdict(list)
        self.helper(root, mapping, 0, 0)
        print(mapping)
        res = sorted(mapping.keys(), key = lambda x: -x[1])
        res = sorted(res, key = lambda x: x[0])
        ans = defaultdict(list)
        for k in res:
            ans[k[0]].extend(sorted(mapping[k]))
        return [ans[k] for k in sorted(ans.keys())]
    def helper(self, root, mapping, x, y):
        if not root:
            return
        mapping[x, y].append(root.val)
        self.helper(root.left, mapping, x - 1, y - 1)
        self.helper(root.right, mapping, x + 1, y - 1)
</code></pre>
<p>一刷：Facebook tag</p>
<h3 id="872-Leaf-Similar-Trees-Easy"><a href="#872-Leaf-Similar-Trees-Easy" class="headerlink" title="872. Leaf-Similar Trees (Easy)"></a><a href="https://leetcode.com/problems/leaf-similar-trees/" target="_blank" rel="noopener">872. Leaf-Similar Trees (Easy)</a></h3><p>Consider all the leaves of a binary tree.  From left to right order, the values of those leaves form a leaf value sequence.<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png" alt="Leaf-Similar Trees example"><br>For example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).<br>Two binary trees are considered leaf-similar if their leaf value sequence is the same.<br>Return true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.</p>
<p>Note:<br>Both of the given trees will have between 1 and 100 nodes.</p>
<pre><code class="python">class Solution:
    def leafSimilar(self, root1: TreeNode, root2: TreeNode) -&gt; bool:
        leafs1 = []
        self.helper(root1, leafs1)
        leafs2 = []
        self.helper(root2, leafs2)
        return leafs1 == leafs2
    def helper(self, root, arr):
        if not root:
            return
        if not root.left and not root.right:
            arr.append(root.val)
        self.helper(root.left, arr)
        self.helper(root.right, arr)
</code></pre>
<p>一刷：Facebook tag，其他submission里有酷炫的generator yield from写法</p>
<h3 id="863-All-Nodes-Distance-K-in-Binary-Tree-Medium"><a href="#863-All-Nodes-Distance-K-in-Binary-Tree-Medium" class="headerlink" title="863. All Nodes Distance K in Binary Tree (Medium)"></a><a href="https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/" target="_blank" rel="noopener">863. All Nodes Distance K in Binary Tree (Medium)</a></h3><p>We are given a binary tree (with root node root), a target node, and an integer value K.<br>Return a list of the values of all nodes that have a distance K from the target node.  The answer can be returned in any order.</p>
<p>Example 1:<br>Input: root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2<br>Output: [7,4,1]<br>Explanation:<br>The nodes that are a distance 2 from the target node (with value 5)<br>have values 7, 4, and 1.<br><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="All Nodes Distance K in Binary Tree example"><br>Note that the inputs “root” and “target” are actually TreeNodes.<br>The descriptions of the inputs above are just serializations of these objects.</p>
<p>Note:<br>The given tree is non-empty.<br>Each node in the tree has unique values 0 &lt;= node.val &lt;= 500.<br>The target node is a node in the tree.<br>0 &lt;= K &lt;= 1000.</p>
<pre><code class="python">class Solution:
    def distanceK(self, root, target, K):
        from collections import defaultdict
        neighbors = defaultdict(list)
        self.buildGraph(root, neighbors)
        ans = []
        self.visited = set()
        self.dfs(ans, target, neighbors, K)
        return ans
    def buildGraph(self, root, neighbors):
        q = [root]
        while q:
            root = q.pop(0)
            if root.left:
                neighbors[root].append(root.left)
                neighbors[root.left].append(root)
                q.append(root.left)
            if root.right:
                neighbors[root].append(root.right)
                neighbors[root.right].append(root)
                q.append(root.right)
    def dfs(self, ans, cur, neighbors, K):
        if K == 0:
            ans.append(cur.val)
            return
        self.visited.add(cur)
        for neighbor in neighbors[cur]:
            if neighbor not in self.visited:
                self.dfs(ans, neighbor, neighbors, K - 1)
</code></pre>
<p>一刷：Facebook tag</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="442-Find-All-Duplicates-in-an-Array-Medium"><a href="#442-Find-All-Duplicates-in-an-Array-Medium" class="headerlink" title="442. Find All Duplicates in an Array (Medium)"></a><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">442. Find All Duplicates in an Array (Medium)</a></h3><p>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.<br>Find all the elements that appear twice in this array.<br>Could you do it without extra space and in O(n) runtime?</p>
<p>Example:<br>Input:<br>[4,3,2,7,8,2,3,1]<br>Output:<br>[2,3]</p>
<pre><code class="python">class Solution:
    def findDuplicates(self, nums: List[int]) -&gt; List[int]:
        ans = []
        for v in nums:
            if nums[abs(v) - 1] &lt; 0:
                ans.append(abs(v))
            else:
                nums[abs(v) - 1]  = -nums[abs(v) - 1]
        return ans
</code></pre>
<p>面经：维萨。O(n) time O(1) space需要flip当前数-1所在的位置的符号，然后检查abs(每个当前数)-1位置是否已为负数</p>
<h3 id="240-Search-a-2D-Matrix-II-Medium"><a href="#240-Search-a-2D-Matrix-II-Medium" class="headerlink" title="240. Search a 2D Matrix II (Medium)"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/" target="_blank" rel="noopener">240. Search a 2D Matrix II (Medium)</a></h3><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:<br>Integers in each row are sorted in ascending from left to right.<br>Integers in each column are sorted in ascending from top to bottom.</p>
<pre><code>Consider the following matrix:

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
Given target = 5, return true.
Given target = 20, return false.
</code></pre><pre><code class="python">class Solution:
    def searchMatrix(self, matrix, target):
        if not matrix:
            return False
        r, c = 0, len(matrix[0]) - 1
        while r &lt;= len(matrix) - 1 and c &gt;= 0:
            if target == matrix[r][c]:
                return True
            #if target &gt; matrix[r][c] the anser cannot be in the row
            if target &gt; matrix[r][c]:
                r += 1
            #if target &lt; matrix[r][c] the answer cannot be in the column
            else:
                c -= 1
        return False
</code></pre>
<p>总结：不好的题， 因为需要一个insight就能解</p>
<h3 id="986-Interval-List-Intersections-Medium"><a href="#986-Interval-List-Intersections-Medium" class="headerlink" title="986. Interval List Intersections (Medium)"></a><a href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener">986. Interval List Intersections (Medium)</a></h3><p>Given two lists of closed intervals, each list of intervals is pairwise disjoint and in sorted order.<br>Return the intersection of these two interval lists.<br>(Formally, a closed interval [a, b] (with a &lt;= b) denotes the set of real numbers x with a &lt;= x &lt;= b.  The intersection of two closed intervals is a set of real numbers that is either empty, or can be represented as a closed interval.  For example, the intersection of [1, 3] and [2, 4] is [2, 3].)</p>
<p>Example 1:<br><img src="https://assets.leetcode.com/uploads/2019/01/30/interval1.png" alt="Interval List Intersections example"><br>Input: A = [[0,2],[5,10],[13,23],[24,25]], B = [[1,5],[8,12],[15,24],[25,26]]<br>Output: [[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]<br>Reminder: The inputs and the desired output are lists of Interval objects, and not arrays or lists.</p>
<p>Note:<br>0 &lt;= A.length &lt; 1000<br>0 &lt;= B.length &lt; 1000<br>0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9<br>NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.</p>
<pre><code class="python">class Solution:
    def intervalIntersection(self, A: List[List[int]], B: List[List[int]]) -&gt; List[List[int]]:
        ans = []
        i, j = 0, 0
        while i &lt; len(A) and j &lt; len(B):
            lo = max(A[i][0], B[j][0])
            hi = min(A[i][1], B[j][1])
            if lo &lt;= hi:
                ans.append([lo, hi])
            if A[i][1] &lt; B[j][1]:
                i += 1
            else:
                j += 1
        return ans
</code></pre>
<p>一刷：Facebook tag</p>
<h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="347-Top-K-Frequent-Elements-Medium"><a href="#347-Top-K-Frequent-Elements-Medium" class="headerlink" title="347. Top K Frequent Elements (Medium)"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener">347. Top K Frequent Elements (Medium)</a></h3><p>Given a non-empty array of integers, return the k most frequent elements.</p>
<p>Example 1:<br>Input: nums = [1,1,1,2,2,3], k = 2<br>Output: [1,2]</p>
<p>Example 2:<br>Input: nums = [1], k = 1<br>Output: [1]</p>
<p>Note:<br>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.<br>Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size.</p>
<pre><code class="python">class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&gt; List[int]:
        from collections import Counter
        counter = Counter(nums)
        import heapq
        pq = []
        for key, v in counter.items():
            heapq.heappush(pq, (v, key))
            if len(pq) &gt; k:
                heapq.heappop(pq)
        return [key for (v, key) in pq]
</code></pre>
<p>一刷</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="349-Intersection-of-Two-Arrays-Easy"><a href="#349-Intersection-of-Two-Arrays-Easy" class="headerlink" title="349. Intersection of Two Arrays (Easy)"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays/description/" target="_blank" rel="noopener">349. Intersection of Two Arrays (Easy)</a></h3><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:<br>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2]</p>
<p>Example 2:<br>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [9,4]</p>
<p>Note:<br>Each element in the result must be unique.<br>The result can be in any order.</p>
<pre><code class="python">class Solution:
    def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        nums1 = set(nums1)
        nums2 = set(nums2)
        if len(nums2) &lt; len(nums1):
            nums1, nums2 = nums2, nums1
        ans = set()
        for n in nums1:
            if n in nums2:
                ans.add(n)
        return ans
</code></pre>
<p>一刷</p>
<h3 id="350-Intersection-of-Two-Arrays-II-Easy"><a href="#350-Intersection-of-Two-Arrays-II-Easy" class="headerlink" title="350. Intersection of Two Arrays II (Easy)"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener">350. Intersection of Two Arrays II (Easy)</a></h3><p>Given two arrays, write a function to compute their intersection.</p>
<p>Example 1:<br>Input: nums1 = [1,2,2,1], nums2 = [2,2]<br>Output: [2,2]</p>
<p>Example 2:<br>Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]<br>Output: [4,9]</p>
<p>Note:<br>Each element in the result should appear as many times as it shows in both arrays.<br>The result can be in any order.</p>
<p>Follow up:<br>What if the given array is already sorted? How would you optimize your algorithm?<br>What if nums1’s size is small compared to nums2’s size? Which algorithm is better?<br>What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the memory at once?</p>
<pre><code class="python">class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -&gt; List[int]:
        from collections import Counter
        counter1 = Counter(nums1)
        counter2 = Counter(nums2)
        if len(counter2) &gt; len(counter1):
            counter1, counter2 = counter2, counter1
        ans = []
        for k in counter1:
            if k in counter2:
                ans.extend([k] * min(counter1[k], counter2[k]))
        return ans
</code></pre>
<p>二刷</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/03/2018-%E4%BA%94%E4%B8%80%E5%81%87%E6%9C%9F%E6%97%A5%E6%9C%AC%E5%A4%A7%E9%98%AA%E4%BA%AC%E9%83%BD%E5%A5%88%E8%89%AF-6-%E5%A4%A9-5-%E6%99%9A/" rel="next" title="2018年五一假期日本大阪京都奈良6日游">
                <i class="fa fa-chevron-left"></i> 2018年五一假期日本大阪京都奈良6日游
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/%20%7C%7C%20archive">
                
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://www.linkedin.com/in/alantang" target="_blank" title="LinkedIn"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://github.com/alant" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/users/3781358/alant" target="_blank" title="StackOverflow"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/tang-hao-3" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Tree-based-Recursion-amp-Divide-Conquer-二叉树递归与分治"><span class="nav-number">1.</span> <span class="nav-text">Binary Tree based Recursion &amp; Divide Conquer 二叉树递归与分治</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#226-Invert-Binary-Tree-Easy"><span class="nav-number">1.0.1.</span> <span class="nav-text">226. Invert Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#100-Same-Tree-Easy"><span class="nav-number">1.0.2.</span> <span class="nav-text">100. Same Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#101-Symmetric-Tree-Easy"><span class="nav-number">1.0.3.</span> <span class="nav-text">101. Symmetric Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree-Easy"><span class="nav-number">1.0.4.</span> <span class="nav-text">104. Maximum Depth of Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#111-Minimum-Depth-of-Binary-Tree-Easy"><span class="nav-number">1.0.5.</span> <span class="nav-text">111. Minimum Depth of Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#144-Binary-Tree-Preorder-Traversal-Medium"><span class="nav-number">1.0.6.</span> <span class="nav-text">144. Binary Tree Preorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-Binary-Tree-Inorder-Traversal-Medium"><span class="nav-number">1.0.7.</span> <span class="nav-text">94. Binary Tree Inorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#230-Kth-Smallest-Element-in-a-BST-Medium"><span class="nav-number">1.0.8.</span> <span class="nav-text">230. Kth Smallest Element in a BST (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#129-Sum-Root-to-Leaf-Numbers-Medium"><span class="nav-number">1.0.9.</span> <span class="nav-text">129. Sum Root to Leaf Numbers (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#116-Populating-Next-Right-Pointers-in-Each-Node-Medium"><span class="nav-number">1.0.10.</span> <span class="nav-text">116. Populating Next Right Pointers in Each Node (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#117-Populating-Next-Right-Pointers-in-Each-Node-II-Medium"><span class="nav-number">1.0.11.</span> <span class="nav-text">117. Populating Next Right Pointers in Each Node II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#110-Balanced-Binary-Tree-Easy"><span class="nav-number">1.0.12.</span> <span class="nav-text">110. Balanced Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#108-Convert-Sorted-Array-to-Binary-Search-Tree-Easy"><span class="nav-number">1.0.13.</span> <span class="nav-text">108. Convert Sorted Array to Binary Search Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#109-Convert-Sorted-List-to-Binary-Search-Tree-Medium"><span class="nav-number">1.0.14.</span> <span class="nav-text">109. Convert Sorted List to Binary Search Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#112-Path-Sum-Easy"><span class="nav-number">1.0.15.</span> <span class="nav-text">112. Path Sum (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#199-Binary-Tree-Right-Side-View-Medium"><span class="nav-number">1.0.16.</span> <span class="nav-text">199. Binary Tree Right Side View (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy"><span class="nav-number">1.0.17.</span> <span class="nav-text">235. Lowest Common Ancestor of a Binary Search Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#543-Diameter-of-Binary-Tree-Easy"><span class="nav-number">1.0.18.</span> <span class="nav-text">543. Diameter of Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#563-Binary-Tree-Tilt-Easy"><span class="nav-number">1.0.19.</span> <span class="nav-text">563. Binary Tree Tilt (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#669-Trim-a-Binary-Search-Tree-Easy"><span class="nav-number">1.0.20.</span> <span class="nav-text">669. Trim a Binary Search Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#687-Longest-Univalue-Path-Easy"><span class="nav-number">1.0.21.</span> <span class="nav-text">687. Longest Univalue Path (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-Flatten-Binary-Tree-to-Linked-List-Medium"><span class="nav-number">1.0.22.</span> <span class="nav-text">114. Flatten Binary Tree to Linked List (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium"><span class="nav-number">1.0.23.</span> <span class="nav-text">236. Lowest Common Ancestor of a Binary Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#285-Inorder-Successor-in-BST-Medium-带锁"><span class="nav-number">1.0.24.</span> <span class="nav-text">285. Inorder Successor in BST (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#98-Validate-Binary-Search-Tree-Medium"><span class="nav-number">1.0.25.</span> <span class="nav-text">98. Validate Binary Search Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#572-Subtree-of-Another-Tree-Easy"><span class="nav-number">1.0.26.</span> <span class="nav-text">572. Subtree of Another Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#606-Construct-String-from-Binary-Tree-Easy"><span class="nav-number">1.0.27.</span> <span class="nav-text">606. Construct String from Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#297-Serialize-and-Deserialize-Binary-Tree-Hard"><span class="nav-number">1.0.28.</span> <span class="nav-text">297. Serialize and Deserialize Binary Tree (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#536-Construct-Binary-Tree-from-String-Medium-带锁"><span class="nav-number">1.0.29.</span> <span class="nav-text">536. Construct Binary Tree from String (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium"><span class="nav-number">1.0.30.</span> <span class="nav-text">105. Construct Binary Tree from Preorder and Inorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#106-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium"><span class="nav-number">1.0.31.</span> <span class="nav-text">106. Construct Binary Tree from Inorder and Postorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#889-Construct-Binary-Tree-from-Preorder-and-Postorder-Traversal-Medium"><span class="nav-number">1.0.32.</span> <span class="nav-text">889. Construct Binary Tree from Preorder and Postorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#865-Smallest-Subtree-with-all-the-Deepest-Nodes-Medium"><span class="nav-number">1.0.33.</span> <span class="nav-text">865. Smallest Subtree with all the Deepest Nodes (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#426-Convert-Binary-Search-Tree-to-Sorted-Doubly-Linked-List-Medium-带锁"><span class="nav-number">1.0.34.</span> <span class="nav-text">426. Convert Binary Search Tree to Sorted Doubly Linked List (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#298-Binary-Tree-Longest-Consecutive-Sequence-Medium-带锁"><span class="nav-number">1.0.35.</span> <span class="nav-text">298. Binary Tree Longest Consecutive Sequence (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#897-Increasing-Order-Search-Tree-Easy"><span class="nav-number">1.0.36.</span> <span class="nav-text">897. Increasing Order Search Tree (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Tree-based-BFS-基于树的-BFS"><span class="nav-number">1.1.</span> <span class="nav-text">Tree based BFS 基于树的 BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#102-Binary-Tree-Level-Order-Traversal-Medium"><span class="nav-number">1.1.1.</span> <span class="nav-text">102. Binary Tree Level Order Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#107-Binary-Tree-Level-Order-Traversal-II-Easy"><span class="nav-number">1.1.2.</span> <span class="nav-text">107. Binary Tree Level Order Traversal II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium"><span class="nav-number">1.1.3.</span> <span class="nav-text">103. Binary Tree Zigzag Level Order Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#958-Check-Completeness-of-a-Binary-Tree-Medium"><span class="nav-number">1.1.4.</span> <span class="nav-text">958. Check Completeness of a Binary Tree (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Search-amp-LogN-Algorithm"><span class="nav-number">2.</span> <span class="nav-text">Binary Search &amp; LogN Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#704-Binary-Search-Easy"><span class="nav-number">2.0.1.</span> <span class="nav-text">704. Binary Search (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-14-First-Position-of-Target-Easy"><span class="nav-number">2.0.2.</span> <span class="nav-text">LinC 14. First Position of Target (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#278-First-Bad-Version-Easy"><span class="nav-number">2.0.3.</span> <span class="nav-text">278. First Bad Version (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><span class="nav-number">2.0.4.</span> <span class="nav-text">34. Find First and Last Position of Element in Sorted Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-61-Search-for-a-Range-Medium"><span class="nav-number">2.0.5.</span> <span class="nav-text">LinC 61. Search for a Range (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#852-Peak-Index-in-a-Mountain-Array"><span class="nav-number">2.0.6.</span> <span class="nav-text">852. Peak Index in a Mountain Array</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#162-Find-Peak-Element-Medium"><span class="nav-number">2.0.7.</span> <span class="nav-text">162. Find Peak Element (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74-Search-a-2D-Matrix-Medium"><span class="nav-number">2.0.8.</span> <span class="nav-text">74. Search a 2D Matrix (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><span class="nav-number">2.0.9.</span> <span class="nav-text">153. Find Minimum in Rotated Sorted Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-Search-in-Rotated-Sorted-Array-Medium"><span class="nav-number">2.0.10.</span> <span class="nav-text">33. Search in Rotated Sorted Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#81-Search-in-Rotated-Sorted-Array-II-Medium"><span class="nav-number">2.0.11.</span> <span class="nav-text">81. Search in Rotated Sorted Array II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#69-Sqrt-x-Easy"><span class="nav-number">2.0.12.</span> <span class="nav-text">69. Sqrt(x) (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#35-Search-Insert-Position-Easy"><span class="nav-number">2.0.13.</span> <span class="nav-text">35. Search Insert Position (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#658-Find-K-Closest-Elements-Medium"><span class="nav-number">2.0.14.</span> <span class="nav-text">658. Find K Closest Elements (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Two-pointers"><span class="nav-number">3.</span> <span class="nav-text">Two pointers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-373-Partition-Array-by-Odd-and-Even-Easy"><span class="nav-number">3.0.1.</span> <span class="nav-text">LinC 373. Partition Array by Odd and Even (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-Remove-Duplicates-from-Sorted-Array-Easy"><span class="nav-number">3.0.2.</span> <span class="nav-text">26. Remove Duplicates from Sorted Array (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#80-Remove-Duplicates-from-Sorted-Array-II-Medium"><span class="nav-number">3.0.3.</span> <span class="nav-text">80. Remove Duplicates from Sorted Array II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-Implement-strStr-Easy"><span class="nav-number">3.0.4.</span> <span class="nav-text">28. Implement strStr() (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#283-Move-Zeroes-Easy"><span class="nav-number">3.0.5.</span> <span class="nav-text">283. Move Zeroes (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125-Valid-Palindrome-Easy"><span class="nav-number">3.0.6.</span> <span class="nav-text">125. Valid Palindrome (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#680-Valid-Palindrome-II-Easy"><span class="nav-number">3.0.7.</span> <span class="nav-text">680. Valid Palindrome II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Two-Sum-Easy"><span class="nav-number">3.0.8.</span> <span class="nav-text">1. Two Sum (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#167-Two-Sum-II-Input-array-is-sorted-Easy"><span class="nav-number">3.0.9.</span> <span class="nav-text">167. Two Sum II - Input array is sorted (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-607-Two-Sum-III-Data-structure-design-Easy"><span class="nav-number">3.0.10.</span> <span class="nav-text">LinC 607. Two Sum III - Data structure design (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3Sum-Medium"><span class="nav-number">3.0.11.</span> <span class="nav-text">15. 3Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-382-Triangle-Count-Medium"><span class="nav-number">3.0.12.</span> <span class="nav-text">LinC 382. Triangle Count (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3Sum-Closest-Medium"><span class="nav-number">3.0.13.</span> <span class="nav-text">16. 3Sum Closest (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-31-Partition-Array-Medium"><span class="nav-number">3.0.14.</span> <span class="nav-text">LinC 31. Partition Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#215-Kth-Largest-Element-in-an-Array-Medium"><span class="nav-number">3.0.15.</span> <span class="nav-text">215. Kth Largest Element in an Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75-Sort-Colors-Medium"><span class="nav-number">3.0.16.</span> <span class="nav-text">75. Sort Colors (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4Sum-Medium"><span class="nav-number">3.0.17.</span> <span class="nav-text">18. 4Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#27-Remove-Element"><span class="nav-number">3.0.18.</span> <span class="nav-text">27. Remove Element</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Container-With-Most-Water-Medium"><span class="nav-number">3.0.19.</span> <span class="nav-text">11. Container With Most Water (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#345-Reverse-Vowels-of-a-String-Easy"><span class="nav-number">3.0.20.</span> <span class="nav-text">345. Reverse Vowels of a String (Easy)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS-广度优先搜索"><span class="nav-number">4.</span> <span class="nav-text">BFS 广度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#695-Max-Area-of-Island-Medium"><span class="nav-number">4.0.1.</span> <span class="nav-text">695. Max Area of Island (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#133-Clone-Graph-Medium"><span class="nav-number">4.0.2.</span> <span class="nav-text">133. Clone Graph (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127-Word-Ladder-Medium"><span class="nav-number">4.0.3.</span> <span class="nav-text">127. Word Ladder (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#200-Number-of-Islands-Medium"><span class="nav-number">4.0.4.</span> <span class="nav-text">200. Number of Islands (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-611-Knight-Shortest-Path-Medium"><span class="nav-number">4.0.5.</span> <span class="nav-text">LinC 611. Knight Shortest Path (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#785-Is-Graph-Bipartite-Medium"><span class="nav-number">4.0.6.</span> <span class="nav-text">785. Is Graph Bipartite? (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-178-Graph-Valid-Tree-Medium"><span class="nav-number">4.0.7.</span> <span class="nav-text">LinC 178. Graph Valid Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#130-Surrounded-Regions-Medium"><span class="nav-number">4.0.8.</span> <span class="nav-text">130. Surrounded Regions (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#675-Cut-Off-Trees-for-Golf-Event-Hard"><span class="nav-number">4.0.9.</span> <span class="nav-text">675. Cut Off Trees for Golf Event (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#310-Minimum-Height-Trees-Medium"><span class="nav-number">4.0.10.</span> <span class="nav-text">310. Minimum Height Trees (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Topological-sorting-拓扑排序"><span class="nav-number">4.1.</span> <span class="nav-text">Topological sorting 拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-127-Topological-Sorting-Medium"><span class="nav-number">4.1.1.</span> <span class="nav-text">LinC 127. Topological Sorting (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#207-Course-Schedule-Medium"><span class="nav-number">4.1.2.</span> <span class="nav-text">207. Course Schedule (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#210-Course-Schedule-II-Medium"><span class="nav-number">4.1.3.</span> <span class="nav-text">210. Course Schedule II (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DFS-深度优先搜索"><span class="nav-number">5.</span> <span class="nav-text">DFS 深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree-DFS-二叉树与树上的深度优先搜索"><span class="nav-number">5.1.</span> <span class="nav-text">Binary Tree DFS 二叉树与树上的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#257-Binary-Tree-Paths-Easy"><span class="nav-number">5.1.1.</span> <span class="nav-text">257. Binary Tree Paths (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#113-Path-Sum-II-Medium"><span class="nav-number">5.1.2.</span> <span class="nav-text">113. Path Sum II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#437-Path-Sum-III-Medium"><span class="nav-number">5.1.3.</span> <span class="nav-text">437. Path Sum III (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Combination-based-DFS-基于组合的深度优先搜索"><span class="nav-number">5.2.</span> <span class="nav-text">Combination based DFS - 基于组合的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#78-Subsets-Medium"><span class="nav-number">5.2.1.</span> <span class="nav-text">78. Subsets (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Combination-Sum-Medium"><span class="nav-number">5.2.2.</span> <span class="nav-text">39. Combination Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-Combination-Sum-II-Medium"><span class="nav-number">5.2.3.</span> <span class="nav-text">40. Combination Sum II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#216-combination-sum-iii-medium"><span class="nav-number">5.2.4.</span> <span class="nav-text">216. combination sum iii (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-combinations-medium"><span class="nav-number">5.2.5.</span> <span class="nav-text">77. combinations (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-palindrome-partitioning-medium"><span class="nav-number">5.2.6.</span> <span class="nav-text">131. palindrome partitioning (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93-restore-ip-addresses-medium"><span class="nav-number">5.2.7.</span> <span class="nav-text">93. restore ip addresses (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#linc-680-split-string-easy"><span class="nav-number">5.2.8.</span> <span class="nav-text">linc 680. split string (easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-subsets-ii-medium"><span class="nav-number">5.2.9.</span> <span class="nav-text">90. subsets ii (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#140-Word-Break-II-Hard"><span class="nav-number">5.2.10.</span> <span class="nav-text">140. Word Break II (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Permutation-based-DFS-基于排列的深度优先搜索"><span class="nav-number">5.3.</span> <span class="nav-text">Permutation based DFS - 基于排列的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#46-Permutations-Medium"><span class="nav-number">5.3.1.</span> <span class="nav-text">46. Permutations (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-Permutations-II-Medium"><span class="nav-number">5.3.2.</span> <span class="nav-text">47. Permutations II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-Generate-Parentheses-Medium"><span class="nav-number">5.3.3.</span> <span class="nav-text">22. Generate Parentheses (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#51-N-Queens-Hard"><span class="nav-number">5.3.4.</span> <span class="nav-text">51. N-Queens (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph-based-DFS-基于图的深度优先搜索"><span class="nav-number">5.4.</span> <span class="nav-text">Graph based DFS 基于图的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-Letter-Combinations-of-a-Phone-Number-Medium"><span class="nav-number">5.4.1.</span> <span class="nav-text">17. Letter Combinations of a Phone Number (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79-Word-Search-Medium"><span class="nav-number">5.4.2.</span> <span class="nav-text">79. Word Search (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#490-The-Maze-Medium-带锁"><span class="nav-number">5.4.3.</span> <span class="nav-text">490. The Maze (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#417-Pacific-Atlantic-Water-Flow-Medium"><span class="nav-number">5.4.4.</span> <span class="nav-text">417. Pacific Atlantic Water Flow (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#399-Evaluate-Division-Medium"><span class="nav-number">5.4.5.</span> <span class="nav-text">399. Evaluate Division (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#332-Reconstruct-Itinerary-Medium"><span class="nav-number">5.4.6.</span> <span class="nav-text">332. Reconstruct Itinerary (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">6.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-数组"><span class="nav-number">6.1.</span> <span class="nav-text">Array 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-6-Merge-Two-Sorted-Arrays-Easy"><span class="nav-number">6.1.1.</span> <span class="nav-text">LinC 6. Merge Two Sorted Arrays (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88-Merge-Sorted-Array-Easy"><span class="nav-number">6.1.2.</span> <span class="nav-text">88. Merge Sorted Array (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#73-Set-Matrix-Zeroes-Medium"><span class="nav-number">6.1.3.</span> <span class="nav-text">73. Set Matrix Zeroes (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#56-Merge-Intervals-Medium"><span class="nav-number">6.1.4.</span> <span class="nav-text">56. Merge Intervals (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-839-Merge-Two-Sorted-Interval-Lists-Easy"><span class="nav-number">6.1.5.</span> <span class="nav-text">LinC 839. Merge Two Sorted Interval Lists (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#228-Summary-Ranges-Medium"><span class="nav-number">6.1.6.</span> <span class="nav-text">228. Summary Ranges (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#67-Add-Binary-Easy"><span class="nav-number">6.1.7.</span> <span class="nav-text">67. Add Binary (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-Integer-to-Roman-Medium"><span class="nav-number">6.1.8.</span> <span class="nav-text">12. Integer to Roman (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#43-Multiply-Strings-Medium"><span class="nav-number">6.1.9.</span> <span class="nav-text">43. Multiply Strings (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#128-Longest-Consecutive-Sequence-Medium"><span class="nav-number">6.1.10.</span> <span class="nav-text">128. Longest Consecutive Sequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#66-Plus-One-Easy"><span class="nav-number">6.1.11.</span> <span class="nav-text">66. Plus One (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-Palindrome-Number-Easy"><span class="nav-number">6.1.12.</span> <span class="nav-text">9. Palindrome Number (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#59-Spiral-Matrix-II-Medium"><span class="nav-number">6.1.13.</span> <span class="nav-text">59. Spiral Matrix II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#48-Rotate-Image-Medium"><span class="nav-number">6.1.14.</span> <span class="nav-text">48. Rotate Image (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#54-Spiral-Matrix-Medium"><span class="nav-number">6.1.15.</span> <span class="nav-text">54. Spiral Matrix (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#68-Text-Justification-Hard"><span class="nav-number">6.1.16.</span> <span class="nav-text">68. Text Justification (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#36-Valid-Sudoku-Medium"><span class="nav-number">6.1.17.</span> <span class="nav-text">36. Valid Sudoku (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#38-Count-and-Say-Easy"><span class="nav-number">6.1.18.</span> <span class="nav-text">38. Count and Say (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-Longest-Common-Prefix-Easy"><span class="nav-number">6.1.19.</span> <span class="nav-text">14. Longest Common Prefix (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#119-Pascal’s-Triangle-II-Easy"><span class="nav-number">6.1.20.</span> <span class="nav-text">119. Pascal’s Triangle II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-ZigZag-Conversion-Medium"><span class="nav-number">6.1.21.</span> <span class="nav-text">6. ZigZag Conversion (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-String-to-Integer-atoi-Medium"><span class="nav-number">6.1.22.</span> <span class="nav-text">8. String to Integer (atoi) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-Insert-Interval-Hard"><span class="nav-number">6.1.23.</span> <span class="nav-text">57. Insert Interval (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#937-Reorder-Log-Files-Easy"><span class="nav-number">6.1.24.</span> <span class="nav-text">937. Reorder Log Files (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#189-Rotate-Array-Easy"><span class="nav-number">6.1.25.</span> <span class="nav-text">189. Rotate Array (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#296-Best-Meeting-Point-Hard-带锁"><span class="nav-number">6.1.26.</span> <span class="nav-text">296. Best Meeting Point (Hard) 带锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Sliding-Window-滑动窗口"><span class="nav-number">6.2.</span> <span class="nav-text">Sliding Window 滑动窗口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#438-Find-All-Anagrams-in-a-String-Medium"><span class="nav-number">6.2.1.</span> <span class="nav-text">438. Find All Anagrams in a String (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-Longest-Substring-Without-Repeating-Characters-Medium"><span class="nav-number">6.2.2.</span> <span class="nav-text">3. Longest Substring Without Repeating Characters (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#76-Minimum-Window-Substring-Hard"><span class="nav-number">6.2.3.</span> <span class="nav-text">76. Minimum Window Substring (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1151-Minimum-Swaps-to-Group-All-1’s-Together-Medium-带锁"><span class="nav-number">6.2.4.</span> <span class="nav-text">1151    Minimum Swaps to Group All 1’s Together (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1004-Max-Consecutive-Ones-III-medium"><span class="nav-number">6.2.5.</span> <span class="nav-text">1004. Max Consecutive Ones III medium</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linked-List-链表"><span class="nav-number">6.3.</span> <span class="nav-text">Linked List 链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#83-Remove-Duplicates-from-Sorted-List-Easy"><span class="nav-number">6.3.1.</span> <span class="nav-text">83. Remove Duplicates from Sorted List (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#82-Remove-Duplicates-from-Sorted-List-II-Medium"><span class="nav-number">6.3.2.</span> <span class="nav-text">82. Remove Duplicates from Sorted List II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#21-Merge-Two-Sorted-Lists-Easy"><span class="nav-number">6.3.3.</span> <span class="nav-text">21. Merge Two Sorted Lists (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Remove-Nth-Node-From-End-of-List-Medium"><span class="nav-number">6.3.4.</span> <span class="nav-text">19. Remove Nth Node From End of List (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Add-Two-Numbers-Medium"><span class="nav-number">6.3.5.</span> <span class="nav-text">2. Add Two Numbers (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86-Partition-List-Medium"><span class="nav-number">6.3.6.</span> <span class="nav-text">86. Partition List (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141-Linked-List-Cycle-Easy"><span class="nav-number">6.3.7.</span> <span class="nav-text">141. Linked List Cycle (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-Linked-List-Cycle-II-Medium"><span class="nav-number">6.3.8.</span> <span class="nav-text">142. Linked List Cycle II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#206-Reverse-Linked-List-Easy"><span class="nav-number">6.3.9.</span> <span class="nav-text">206. Reverse Linked List (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists-Easy"><span class="nav-number">6.3.10.</span> <span class="nav-text">160. Intersection of Two Linked Lists (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#24-Swap-Nodes-in-Pairs-Medium"><span class="nav-number">6.3.11.</span> <span class="nav-text">24. Swap Nodes in Pairs (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#61-Rotate-List-Medium"><span class="nav-number">6.3.12.</span> <span class="nav-text">61. Rotate List (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#146-LRU-Cache-Medium"><span class="nav-number">6.3.13.</span> <span class="nav-text">146. LRU Cache (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#234-Palindrome-Linked-List-Easy"><span class="nav-number">6.3.14.</span> <span class="nav-text">234. Palindrome Linked List (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack-栈"><span class="nav-number">6.4.</span> <span class="nav-text">Stack 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20-Valid-Parentheses-Easy"><span class="nav-number">6.4.1.</span> <span class="nav-text">20. Valid Parentheses (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#71-Simplify-Path-Medium"><span class="nav-number">6.4.2.</span> <span class="nav-text">71. Simplify Path (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#150-Evaluate-Reverse-Polish-Notation-Medium"><span class="nav-number">6.4.3.</span> <span class="nav-text">150. Evaluate Reverse Polish Notation (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#155-Min-Stack-Easy"><span class="nav-number">6.4.4.</span> <span class="nav-text">155. Min Stack (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#224-Basic-Calculator-Hard"><span class="nav-number">6.4.5.</span> <span class="nav-text">224. Basic Calculator (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#227-Basic-Calculator-II-Medium"><span class="nav-number">6.4.6.</span> <span class="nav-text">227. Basic Calculator II (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-队列"><span class="nav-number">6.5.</span> <span class="nav-text">Queue 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-642-Moving-Average-from-Data-Stream-Easy"><span class="nav-number">6.5.1.</span> <span class="nav-text">LinC 642. Moving Average from Data Stream (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-哈希表"><span class="nav-number">6.6.</span> <span class="nav-text">Hash 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#290-Word-Pattern-Easy"><span class="nav-number">6.6.1.</span> <span class="nav-text">290. Word Pattern (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#387-First-Unique-Character-in-a-String-Easy"><span class="nav-number">6.6.2.</span> <span class="nav-text">387. First Unique Character in a String (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#409-Longest-Palindrome-Easy"><span class="nav-number">6.6.3.</span> <span class="nav-text">409. Longest Palindrome (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#380-Insert-Delete-GetRandom-O-1-Medium"><span class="nav-number">6.6.4.</span> <span class="nav-text">380. Insert Delete GetRandom O(1) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-960-First-Unique-Number-in-a-Stream-II-Medium"><span class="nav-number">6.6.5.</span> <span class="nav-text">LinC 960. First Unique Number in a Stream II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#49-Group-Anagrams-Medium"><span class="nav-number">6.6.6.</span> <span class="nav-text">49. Group Anagrams (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap-Priority-Queue"><span class="nav-number">6.7.</span> <span class="nav-text">Heap (Priority Queue)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#264-Ugly-Number-II-Medium"><span class="nav-number">6.7.1.</span> <span class="nav-text">264. Ugly Number II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#973-K-Closest-Points-to-Origin-Medium"><span class="nav-number">6.7.2.</span> <span class="nav-text">973. K Closest Points to Origin (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-545-Top-k-Largest-Numbers-II-Medium"><span class="nav-number">6.7.3.</span> <span class="nav-text">LinC 545. Top k Largest Numbers II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-486-Merge-K-Sorted-Arrays-Medium"><span class="nav-number">6.7.4.</span> <span class="nav-text">LinC 486. Merge K Sorted Arrays (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-Merge-k-Sorted-Lists-Hard"><span class="nav-number">6.7.5.</span> <span class="nav-text">23. Merge k Sorted Lists (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#295-Find-Median-from-Data-Stream-Hard"><span class="nav-number">6.7.6.</span> <span class="nav-text">295. Find Median from Data Stream (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#743-Network-Delay-Time-Medium"><span class="nav-number">6.7.7.</span> <span class="nav-text">743. Network Delay Time (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#787-Cheapest-Flights-Within-K-Stops-Medium"><span class="nav-number">6.7.8.</span> <span class="nav-text">787. Cheapest Flights Within K Stops (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#855-Exam-Room-Medium"><span class="nav-number">6.7.9.</span> <span class="nav-text">855. Exam Room (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie"><span class="nav-number">6.8.</span> <span class="nav-text">Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree-Medium"><span class="nav-number">6.8.1.</span> <span class="nav-text">208. Implement Trie (Prefix Tree) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#211-Add-and-Search-Word-Data-structure-design-Medium"><span class="nav-number">6.8.2.</span> <span class="nav-text">211. Add and Search Word - Data structure design (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Union-Find-MST"><span class="nav-number">6.9.</span> <span class="nav-text">Union Find &#x2F; MST</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-629-Minimum-Spanning-Tree-Hard"><span class="nav-number">6.9.1.</span> <span class="nav-text">LinC 629. Minimum Spanning Tree (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DP-Dynamic-Programming-动态规划"><span class="nav-number">7.</span> <span class="nav-text">DP Dynamic Programming 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#70-Climbing-Stairs-Easy"><span class="nav-number">7.0.1.</span> <span class="nav-text">70. Climbing Stairs (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#120-Triangle-Medium"><span class="nav-number">7.0.2.</span> <span class="nav-text">120. Triangle (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy"><span class="nav-number">7.0.3.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#122-Best-Time-to-Buy-and-Sell-Stock-II-Easy"><span class="nav-number">7.0.4.</span> <span class="nav-text">122. Best Time to Buy and Sell Stock II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#91-Decode-Ways-Medium"><span class="nav-number">7.0.5.</span> <span class="nav-text">91. Decode Ways (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#62-Unique-Paths-Medium"><span class="nav-number">7.0.6.</span> <span class="nav-text">62. Unique Paths (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-Maximum-Subarray-Easy"><span class="nav-number">7.0.7.</span> <span class="nav-text">53. Maximum Subarray (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#63-Unique-Paths-II-Medium"><span class="nav-number">7.0.8.</span> <span class="nav-text">63. Unique Paths II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#64-Minimum-Path-Sum-Medium"><span class="nav-number">7.0.9.</span> <span class="nav-text">64. Minimum Path Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#72-Edit-Distance-Hard"><span class="nav-number">7.0.10.</span> <span class="nav-text">72. Edit Distance (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#132-Palindrome-Partitioning-II-Hard"><span class="nav-number">7.0.11.</span> <span class="nav-text">132. Palindrome Partitioning II (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Longest-Palindromic-Substring-Medium"><span class="nav-number">7.0.12.</span> <span class="nav-text">5. Longest Palindromic Substring (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#55-Jump-Game-Medium"><span class="nav-number">7.0.13.</span> <span class="nav-text">55. Jump Game (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#96-Unique-Binary-Search-Trees-Medium"><span class="nav-number">7.0.14.</span> <span class="nav-text">96. Unique Binary Search Trees (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#95-Unique-Binary-Search-Trees-II-Medium"><span class="nav-number">7.0.15.</span> <span class="nav-text">95. Unique Binary Search Trees II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#198-House-Robber-Easy"><span class="nav-number">7.0.16.</span> <span class="nav-text">198. House Robber (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#213-House-Robber-II-Medium"><span class="nav-number">7.0.17.</span> <span class="nav-text">213. House Robber II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Regular-Expression-Matching-Hard"><span class="nav-number">7.0.18.</span> <span class="nav-text">10. Regular Expression Matching (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-Wildcard-Matching-Hard"><span class="nav-number">7.0.19.</span> <span class="nav-text">44. Wildcard Matching (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#139-Word-Break-Medium"><span class="nav-number">7.0.20.</span> <span class="nav-text">139. Word Break (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#377-Combination-Sum-IV-Medium"><span class="nav-number">7.0.21.</span> <span class="nav-text">377. Combination Sum IV (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#152-Maximum-Product-Subarray-Medium"><span class="nav-number">7.0.22.</span> <span class="nav-text">152. Maximum Product Subarray (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#516-Longest-Palindromic-Subsequence-Medium"><span class="nav-number">7.0.23.</span> <span class="nav-text">516. Longest Palindromic Subsequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#300-Longest-Increasing-Subsequence-Medium"><span class="nav-number">7.0.24.</span> <span class="nav-text">300. Longest Increasing Subsequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1143-Longest-Common-Subsequence-Medium"><span class="nav-number">7.0.25.</span> <span class="nav-text">1143. Longest Common Subsequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1027-Longest-Arithmetic-Sequence-Medium"><span class="nav-number">7.0.26.</span> <span class="nav-text">1027. Longest Arithmetic Sequence (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#背包问题"><span class="nav-number">7.1.</span> <span class="nav-text">背包问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#322-Coin-Change-Medium"><span class="nav-number">7.1.1.</span> <span class="nav-text">322. Coin Change (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#474-Ones-and-Zeroes-Medium"><span class="nav-number">7.1.2.</span> <span class="nav-text">474. Ones and Zeroes (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#416-Partition-Equal-Subset-Sum-Medium"><span class="nav-number">7.1.3.</span> <span class="nav-text">416. Partition Equal Subset Sum (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Recursion-递归-Backtracking"><span class="nav-number">8.</span> <span class="nav-text">Recursion 递归 &#x2F; Backtracking</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#13-Roman-to-Integer-Easy"><span class="nav-number">8.0.1.</span> <span class="nav-text">13. Roman to Integer (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-Pow-x-n-Medium"><span class="nav-number">8.0.2.</span> <span class="nav-text">50. Pow(x, n) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Median-of-Two-Sorted-Arrays-Hard"><span class="nav-number">8.0.3.</span> <span class="nav-text">4. Median of Two Sorted Arrays (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bit-Manipulation"><span class="nav-number">9.</span> <span class="nav-text">Bit Manipulation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#231-Power-of-Two-Easy"><span class="nav-number">9.0.1.</span> <span class="nav-text">231. Power of Two (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#29-Divide-Two-Integers-Medium"><span class="nav-number">9.0.2.</span> <span class="nav-text">29. Divide Two Integers (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#89-Gray-Code-Medium"><span class="nav-number">9.0.3.</span> <span class="nav-text">89. Gray Code (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Regular-Expression"><span class="nav-number">10.</span> <span class="nav-text">Regular Expression</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#65-Valid-Number-Hard"><span class="nav-number">10.0.1.</span> <span class="nav-text">65. Valid Number (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Multi-threading-多线程"><span class="nav-number">11.</span> <span class="nav-text">Multi-threading 多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1114-Print-in-Order-Easy"><span class="nav-number">11.0.1.</span> <span class="nav-text">1114. Print in Order (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1115-Print-FooBar-Alternately-Medium"><span class="nav-number">11.0.2.</span> <span class="nav-text">1115. Print FooBar Alternately (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1116-Print-Zero-Even-Odd-Medium"><span class="nav-number">11.0.3.</span> <span class="nav-text">1116. Print Zero Even Odd (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1117-Building-H2O-Medium"><span class="nav-number">11.0.4.</span> <span class="nav-text">1117. Building H2O (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Misc-杂类型，偏门-特殊算法"><span class="nav-number">12.</span> <span class="nav-text">Misc 杂类型，偏门&#x2F;特殊算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-Reverse-Integer-Easy"><span class="nav-number">12.0.1.</span> <span class="nav-text">7. Reverse Integer (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-Next-Permutation-Medium"><span class="nav-number">12.0.2.</span> <span class="nav-text">31. Next Permutation (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#60-Permutation-Sequence-Medium"><span class="nav-number">12.0.3.</span> <span class="nav-text">60. Permutation Sequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#238-Product-of-Array-Except-Self-Medium"><span class="nav-number">12.0.4.</span> <span class="nav-text">238. Product of Array Except Self (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#92-Reverse-Linked-List-II-Medium"><span class="nav-number">12.0.5.</span> <span class="nav-text">92. Reverse Linked List II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#84-Largest-Rectangle-in-Histogram-Hard"><span class="nav-number">12.0.6.</span> <span class="nav-text">84. Largest Rectangle in Histogram (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#42-Trapping-Rain-Water-Hard"><span class="nav-number">12.0.7.</span> <span class="nav-text">42. Trapping Rain Water (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#732-My-Calendar-III-Hard"><span class="nav-number">12.0.8.</span> <span class="nav-text">732. My Calendar III (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#skipped"><span class="nav-number">13.</span> <span class="nav-text">skipped</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS-Union-Find"><span class="nav-number">13.1.</span> <span class="nav-text">DFS &#x2F; Union Find</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#721-Accounts-Merge-Medium"><span class="nav-number">13.1.1.</span> <span class="nav-text">721. Accounts Merge (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DP-Dynamic-Programming-动态规划-1"><span class="nav-number">13.2.</span> <span class="nav-text">DP Dynamic Programming 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#123-Best-Time-to-Buy-and-Sell-Stock-III-Hard"><span class="nav-number">13.2.1.</span> <span class="nav-text">123. Best Time to Buy and Sell Stock III (Hard)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#非核心题"><span class="nav-number">14.</span> <span class="nav-text">非核心题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#深度优先搜索"><span class="nav-number">14.1.</span> <span class="nav-text">深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-862-Next-Closest-Time-Medium"><span class="nav-number">14.1.1.</span> <span class="nav-text">LinC 862. Next Closest Time (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#树"><span class="nav-number">14.2.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#637-Average-of-Levels-in-Binary-Tree-Easy"><span class="nav-number">14.2.1.</span> <span class="nav-text">637. Average of Levels in Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#270-Closest-Binary-Search-Tree-Value-Easy-带锁"><span class="nav-number">14.2.2.</span> <span class="nav-text">270. Closest Binary Search Tree Value (Easy) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#272-Closest-Binary-Search-Tree-Value-II-Hard-带锁"><span class="nav-number">14.2.3.</span> <span class="nav-text">272. Closest Binary Search Tree Value II (Hard) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#404-Sum-of-Left-Leaves-Easy"><span class="nav-number">14.2.4.</span> <span class="nav-text">404. Sum of Left Leaves (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#653-Two-Sum-IV-Input-is-a-BST-Easy"><span class="nav-number">14.2.5.</span> <span class="nav-text">653. Two Sum IV - Input is a BST (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#655-Print-Binary-Tree-Medium"><span class="nav-number">14.2.6.</span> <span class="nav-text">655. Print Binary Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#701-Insert-into-a-Binary-Search-Tree-Medium"><span class="nav-number">14.2.7.</span> <span class="nav-text">701. Insert into a Binary Search Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#173-Binary-Search-Tree-Iterator-Medium"><span class="nav-number">14.2.8.</span> <span class="nav-text">173. Binary Search Tree Iterator (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1120-Maximum-Average-Subtree-Medium-带锁"><span class="nav-number">14.2.9.</span> <span class="nav-text">1120. Maximum Average Subtree (Medium) 带锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#671-Second-Minimum-Node-In-a-Binary-Tree-Easy"><span class="nav-number">14.2.10.</span> <span class="nav-text">671. Second Minimum Node In a Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#530-Minimum-Absolute-Difference-in-BST-Easy"><span class="nav-number">14.2.11.</span> <span class="nav-text">530. Minimum Absolute Difference in BST (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1008-Construct-Binary-Search-Tree-from-Preorder-Traversal-Medium"><span class="nav-number">14.2.12.</span> <span class="nav-text">1008. Construct Binary Search Tree from Preorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#987-Vertical-Order-Traversal-of-a-Binary-Tree-Medium"><span class="nav-number">14.2.13.</span> <span class="nav-text">987. Vertical Order Traversal of a Binary Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#872-Leaf-Similar-Trees-Easy"><span class="nav-number">14.2.14.</span> <span class="nav-text">872. Leaf-Similar Trees (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#863-All-Nodes-Distance-K-in-Binary-Tree-Medium"><span class="nav-number">14.2.15.</span> <span class="nav-text">863. All Nodes Distance K in Binary Tree (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">14.3.</span> <span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#442-Find-All-Duplicates-in-an-Array-Medium"><span class="nav-number">14.3.1.</span> <span class="nav-text">442. Find All Duplicates in an Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#240-Search-a-2D-Matrix-II-Medium"><span class="nav-number">14.3.2.</span> <span class="nav-text">240. Search a 2D Matrix II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#986-Interval-List-Intersections-Medium"><span class="nav-number">14.3.3.</span> <span class="nav-text">986. Interval List Intersections (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap"><span class="nav-number">14.4.</span> <span class="nav-text">Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#347-Top-K-Frequent-Elements-Medium"><span class="nav-number">14.4.1.</span> <span class="nav-text">347. Top K Frequent Elements (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash"><span class="nav-number">14.5.</span> <span class="nav-text">Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#349-Intersection-of-Two-Arrays-Easy"><span class="nav-number">14.5.1.</span> <span class="nav-text">349. Intersection of Two Arrays (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#350-Intersection-of-Two-Arrays-II-Easy"><span class="nav-number">14.5.2.</span> <span class="nav-text">350. Intersection of Two Arrays II (Easy)</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan</span>

  

  
</div>








  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
