<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.4.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.4.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.4.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.4.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.4.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Binary Search &amp;amp; LogN Algorithm比O(n)更优的时间复杂度几乎只能是O(logn)的二分法二分法模板: start + 1 &amp;lt; end; start + (end - start) / 2; A[mid] ==, &amp;lt;, &amp;gt;; A[start] A[end] ? target 704. Binary Search (Easy)lintcode’s">
<meta name="keywords" content="产品经理，软件工程师，区块链，互联网，流量变现">
<meta property="og:type" content="article">
<meta property="og:title" content="面试刷题">
<meta property="og:url" content="http://ahtang.com//2018/09/13/面试刷题/index.html">
<meta property="og:site_name" content="汤包个人页">
<meta property="og:description" content="Binary Search &amp;amp; LogN Algorithm比O(n)更优的时间复杂度几乎只能是O(logn)的二分法二分法模板: start + 1 &amp;lt; end; start + (end - start) / 2; A[mid] ==, &amp;lt;, &amp;gt;; A[start] A[end] ? target 704. Binary Search (Easy)lintcode’s">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://ahtang.com/images/lintcode_127_topo_1.jpeg">
<meta property="og:image" content="http://ahtang.com/images/leetode_144_bina_1.jpeg">
<meta property="og:image" content="http://ahtang.com/images/leetcode_17_lett_1.png">
<meta property="og:image" content="http://ahtang.com/images/leetcode_114_flat.jpeg">
<meta property="og:updated_time" content="2018-09-14T04:44:27.666Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试刷题">
<meta name="twitter:description" content="Binary Search &amp;amp; LogN Algorithm比O(n)更优的时间复杂度几乎只能是O(logn)的二分法二分法模板: start + 1 &amp;lt; end; start + (end - start) / 2; A[mid] ==, &amp;lt;, &amp;gt;; A[start] A[end] ? target 704. Binary Search (Easy)lintcode’s">
<meta name="twitter:image" content="http://ahtang.com/images/lintcode_127_topo_1.jpeg">






  <link rel="canonical" href="http://ahtang.com//2018/09/13/面试刷题/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>面试刷题 | 汤包个人页</title>
  




<script async src="https://www.googletagmanager.com/gtag/js?id=UA-2155923-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-2155923-2');
</script>






  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">汤包个人页</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />About</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://ahtang.com//2018/09/13/面试刷题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alan">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汤包个人页">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试刷题
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-13 21:17:00" itemprop="dateCreated datePublished" datetime="2018-09-13T21:17:00+08:00">2018-09-13</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Binary-Search-amp-LogN-Algorithm"><a href="#Binary-Search-amp-LogN-Algorithm" class="headerlink" title="Binary Search &amp; LogN Algorithm"></a>Binary Search &amp; LogN Algorithm</h1><p>比O(n)更优的时间复杂度几乎只能是O(logn)的二分法<br>二分法模板: start + 1 &lt; end; start + (end - start) / 2; A[mid] ==, &lt;, &gt;; A[start] A[end] ? target</p>
<h3 id="704-Binary-Search-Easy"><a href="#704-Binary-Search-Easy" class="headerlink" title="704. Binary Search (Easy)"></a><a href="https://leetcode.com/problems/binary-search/description/" target="_blank" rel="noopener">704. Binary Search (Easy)</a></h3><p><a href="https://www.lintcode.com/problem/classical-binary-search/description" target="_blank" rel="noopener">lintcode’s version</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Find any position of a target number in a sorted array. Return -1 if target does not exist.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given [1, 2, 2, 4, 5, 5].</span><br><span class="line"></span><br><span class="line">For target = 2, return 1 or 2.</span><br><span class="line"></span><br><span class="line">For target = 5, return 4 or 5.</span><br><span class="line"></span><br><span class="line">For target = 6, return -1.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(logn) time</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: nums: An integer array sorted in ascending order</span></span><br><span class="line"><span class="string">    @param: target: An integer</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPosition</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (len(nums) == <span class="number">0</span>):</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span>     </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> (nums[mid] &lt; target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid    </span><br><span class="line">        <span class="keyword">if</span> (nums[start] == target):</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> (nums[end] == target):</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>总结：背好模板，lintcode 的 test case 包含空输入数组，需要 python3 的 // 整除运算符才能过</p>
<h3 id="LinC-14-First-Position-of-Target-Easy"><a href="#LinC-14-First-Position-of-Target-Easy" class="headerlink" title="LinC 14. First Position of Target (Easy)"></a><a href="https://www.lintcode.com/problem/first-position-of-target/description" target="_blank" rel="noopener">LinC 14. First Position of Target (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Description</span><br><span class="line">For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.</span><br><span class="line"></span><br><span class="line">If the target number does not exist in the array, return -1.</span><br><span class="line"></span><br><span class="line">Have you met this question in a real interview?  </span><br><span class="line">Example</span><br><span class="line">If the array is [1, 2, 3, 3, 4, 5, 10], for given target 3, return 2.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">If the count of numbers is bigger than 2^32, can your code work properly?</span><br></pre></td></tr></table></figure>
<p>思路：找到了不要 return，扔掉大的一半，继续找<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: The integer array.</span></span><br><span class="line"><span class="string">    @param target: Target to find.</span></span><br><span class="line"><span class="string">    @return: The first position of target. Position starts from 0.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binarySearch</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (len(nums) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">if</span> (nums[start] == target):</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> (nums[end] == target):</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：背好模板，模板 v5</p>
<h3 id="278-First-Bad-Version-Easy"><a href="#278-First-Bad-Version-Easy" class="headerlink" title="278. First Bad Version (Easy)"></a><a href="https://leetcode.com/problems/first-bad-version/description/" target="_blank" rel="noopener">278. First Bad Version (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</span><br><span class="line"></span><br><span class="line">Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.</span><br><span class="line"></span><br><span class="line">You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given n = 5, and version = 4 is the first bad version.</span><br><span class="line"></span><br><span class="line">call isBadVersion(3) -&gt; false</span><br><span class="line">call isBadVersion(5) -&gt; true</span><br><span class="line">call isBadVersion(4) -&gt; true</span><br><span class="line"></span><br><span class="line">Then 4 is the first bad version.</span><br></pre></td></tr></table></figure>
<p>思路：前面 first position of target 的变体，可以不做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The isBadVersion API is already defined for you.</span></span><br><span class="line"><span class="comment"># @param version, an integer</span></span><br><span class="line"><span class="comment"># @return a bool</span></span><br><span class="line"><span class="comment"># def isBadVersion(version):</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstBadVersion</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        start, end = <span class="number">0</span>, n</span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(start)):</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> (isBadVersion(end)):</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>
<p>总结：可不做</p>
<h3 id="34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><a href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium" class="headerlink" title="34. Find First and Last Position of Element in Sorted Array (Medium)"></a><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/" target="_blank" rel="noopener">34. Find First and Last Position of Element in Sorted Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</span><br><span class="line"></span><br><span class="line">Your algorithm's runtime complexity must be in the order of O(log n).</span><br><span class="line"></span><br><span class="line">If the target is not found in the array, return [-1, -1].</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">Output: [3,4]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">Output: [-1,-1]</span><br></pre></td></tr></table></figure>
<p>思路：二分法找 Target, 两次二分法，一次找左边界，一次找右边界<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = [<span class="number">-1</span>, <span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 找左边界</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l ) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; target:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> nums[l] == target:</span><br><span class="line">            ans[<span class="number">0</span>] = l</span><br><span class="line">        <span class="keyword">elif</span> nums[r] == target:</span><br><span class="line">            ans[<span class="number">0</span>] = r</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 找右边界</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l + <span class="number">1</span> &lt; r:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt;= target:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="keyword">if</span> nums[r] == target:</span><br><span class="line">            ans[<span class="number">1</span>] = r</span><br><span class="line">        <span class="keyword">elif</span> nums[l] == target:</span><br><span class="line">            ans[<span class="number">1</span>] = l</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：按今天的水平，写的时候注意 while 的终止条件是 while l + 1 &lt; r (l, r 不要重合就终止循环)。 两年多前写了稍微更简洁些的版本。可以回头再看看能不能写得出。</p>
<h3 id="LinC-61-Search-for-a-Range-Medium"><a href="#LinC-61-Search-for-a-Range-Medium" class="headerlink" title="LinC 61. Search for a Range (Medium)"></a><a href="https://www.lintcode.com/problem/search-for-a-range/description" target="_blank" rel="noopener">LinC 61. Search for a Range (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array of n integers, find the starting and ending position of a given target value.</span><br><span class="line"></span><br><span class="line">If the target is not found in the array, return [-1, -1].</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given [5, 7, 7, 8, 8, 10] and target value 8,</span><br><span class="line">return [3, 4].</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(log n) time.</span><br></pre></td></tr></table></figure>
<p>思路：找一个数的第一次和最后一次出现的 index<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: an integer sorted array</span></span><br><span class="line"><span class="string">    @param target: an integer to be inserted</span></span><br><span class="line"><span class="string">    @return: a list of length 2, [index1, index2]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, A, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        firstO, lastO = <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(A) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [firstO, lastO]</span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt; target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> (A[end] == target):</span><br><span class="line">            firstO = end        </span><br><span class="line">        <span class="keyword">if</span> (A[start] == target):</span><br><span class="line">            firstO = start</span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt;= target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> (A[start] == target):</span><br><span class="line">            lastO = start</span><br><span class="line">        <span class="keyword">if</span> (A[end] == target):</span><br><span class="line">            lastO = end</span><br><span class="line">        <span class="keyword">return</span> [firstO, lastO]</span><br></pre></td></tr></table></figure></p>
<p>总结：注意检查空输入！</p>
<h3 id="LinC-460-Find-K-Closest-Elements-Medium"><a href="#LinC-460-Find-K-Closest-Elements-Medium" class="headerlink" title="LinC 460. Find K Closest Elements (Medium)"></a><a href="https://www.lintcode.com/problem/find-k-closest-elements/description" target="_blank" rel="noopener">LinC 460. Find K Closest Elements (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a target number, a non-negative integer k and an integer array A sorted in ascending order, find the k closest numbers to target in A, sorted in ascending order by the difference between the number and target. Otherwise, sorted in ascending order by number if the difference is same.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given A = [1, 2, 3], target = 2 and k = 3, return [2, 1, 3].</span><br><span class="line"></span><br><span class="line">Given A = [1, 4, 6, 8], target = 3 and k = 3, return [4, 1, 6].</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(logn + k) time complexity.</span><br><span class="line"></span><br><span class="line">Notice</span><br><span class="line">The value k is a non-negative integer and will always be smaller than the length of the sorted array.</span><br><span class="line">Length of the given array is positive and will not exceed 10^4</span><br><span class="line">Absolute value of elements in the array and x will not exceed 10^4</span><br></pre></td></tr></table></figure>
<p>思路：二分查找找到 start end 以后，用两个判断条件来限制取值范围。当 left 超过取值范围之后，只取 right 以后的数。<br>当 right 超过取值范围之后，只取 left 之前的数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: an integer array</span></span><br><span class="line"><span class="string">    @param target: An integer</span></span><br><span class="line"><span class="string">    @param k: An integer</span></span><br><span class="line"><span class="string">    @return: an integer array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosestNumbers</span><span class="params">(self, A, target, k)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(A) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (A[mid] &lt; target):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        left, right = start, end</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">while</span> (k &gt; <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= <span class="number">0</span> <span class="keyword">and</span> right &lt;= len(A) - <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> (target - A[left] &lt;= A[right] - target):</span><br><span class="line">                    result.append(A[left])</span><br><span class="line">                    left -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    result.append(A[right])</span><br><span class="line">                    right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> (left &lt; <span class="number">0</span>):</span><br><span class="line">                result.append(A[right])</span><br><span class="line">                right += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result.append(A[left])</span><br><span class="line">                left -= <span class="number">1</span></span><br><span class="line">            k -=  <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>总结，一开始没有充分理解题目，题目说的是 k closest elements to x in the array， 找到离 x 最近的点以后要往两边看 k 次。解题方法多少有点需要背的因素。</p>
<h3 id="LinC-585-Maximum-Number-in-Mountain-Sequence-Medium"><a href="#LinC-585-Maximum-Number-in-Mountain-Sequence-Medium" class="headerlink" title="LinC 585. Maximum Number in Mountain Sequence (Medium)"></a><a href="https://www.lintcode.com/problem/maximum-number-in-mountain-sequence/description" target="_blank" rel="noopener">LinC 585. Maximum Number in Mountain Sequence (Medium)</a></h3><p><a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/description/" target="_blank" rel="noopener">852. Peak Index in a Mountain Array</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given a mountain sequence of n integers which increase firstly and then decrease, find the mountain top.</span><br><span class="line">Example</span><br><span class="line">Given nums = [1, 2, 4, 8, 6, 3] return 8</span><br><span class="line">Given nums = [10, 9, 8, 7], return 10</span><br></pre></td></tr></table></figure></p>
<p>思路：一开始以为跟上题一样，返回 start 就行了，也许是不值得做的题，可是没有考虑到后面不是递增而是递减。所以，需要改算法为切一刀，判断递增就扔左边，递减就扔右边， 不然就找到了中点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: a mountain sequence which increase firstly and then decrease</span></span><br><span class="line"><span class="string">    @return: then mountain top</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mountainSequence</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &lt; nums[mid] &lt; nums[mid + <span class="number">1</span>]):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">elif</span> (nums[mid - <span class="number">1</span>] &gt; nums[mid] &gt; nums[mid + <span class="number">1</span>]):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> nums[mid]</span><br><span class="line">        <span class="keyword">return</span> nums[end] <span class="keyword">if</span> nums[start] &lt; nums[end] <span class="keyword">else</span> nums[start]</span><br></pre></td></tr></table></figure></p>
<h3 id="162-Find-Peak-Element-Medium"><a href="#162-Find-Peak-Element-Medium" class="headerlink" title="162. Find Peak Element (Medium)"></a><a href="https://leetcode.com/problems/find-peak-element/description/" target="_blank" rel="noopener">162. Find Peak Element (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">A peak element is an element that is greater than its neighbors.</span><br><span class="line"></span><br><span class="line">Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</span><br><span class="line"></span><br><span class="line">The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</span><br><span class="line"></span><br><span class="line">You may imagine that nums[-1] = nums[n] = -∞.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,3,1]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: 3 is a peak element and your function should return the index number 2.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,1,3,5,6,4]</span><br><span class="line">Output: 1 or 5</span><br><span class="line">Explanation: Your function can return either index number 1 where the peak element is 2,</span><br><span class="line">             or index number 5 where the peak element is 6.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Your solution should be in logarithmic complexity.</span><br></pre></td></tr></table></figure>
<p>思路：和前面 Lintcode 585. Maximum Number in Mountain Sequence 应该是一个路子<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> (len(nums) == <span class="number">0</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid - <span class="number">1</span>] &lt; nums[mid] &lt; nums[mid + <span class="number">1</span>]):</span><br><span class="line">                start = mid</span><br><span class="line">            <span class="keyword">elif</span> (nums[mid - <span class="number">1</span>] &lt; nums[mid] &gt; nums[mid + <span class="number">1</span>]):</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                end = mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] &gt; nums[end]:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> end</span><br></pre></td></tr></table></figure></p>
<p>总结：确实和前面一样， 不用做</p>
<h3 id="74-Search-a-2D-Matrix-Medium"><a href="#74-Search-a-2D-Matrix-Medium" class="headerlink" title="74. Search a 2D Matrix (Medium)"></a><a href="https://leetcode.com/problems/search-a-2d-matrix/description/" target="_blank" rel="noopener">74. Search a 2D Matrix (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</span><br><span class="line"></span><br><span class="line">Integers in each row are sorted from left to right.</span><br><span class="line">The first integer of each row is greater than the last integer of the previous row.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 3</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">matrix = [</span><br><span class="line">  [1,   3,  5,  7],</span><br><span class="line">  [10, 11, 16, 20],</span><br><span class="line">  [23, 30, 34, 50]</span><br><span class="line">]</span><br><span class="line">target = 13</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>思路：二分查找，不过是放到二维数组里了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(matrix[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        startR, endR = <span class="number">0</span>, len(matrix) - <span class="number">1</span></span><br><span class="line">        startC, endC = <span class="number">0</span>, len(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span>(startR + <span class="number">1</span> &lt; endR):</span><br><span class="line">            midR = startR + (endR - startR) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[midR][<span class="number">0</span>] == target):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> (matrix[midR][<span class="number">0</span>] &lt; target):</span><br><span class="line">                startR = midR</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                endR = midR</span><br><span class="line">        <span class="keyword">if</span> (matrix[startR][<span class="number">0</span>] == target <span class="keyword">or</span> matrix[endR][<span class="number">0</span>] == target):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">elif</span> (matrix[endR][<span class="number">0</span>] &lt; target):</span><br><span class="line">            targetR = endR</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            targetR = startR</span><br><span class="line">        <span class="keyword">while</span>(startC + <span class="number">1</span> &lt; endC):</span><br><span class="line">            midC = startC + (endC - startC) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[targetR][midC] == target):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> (matrix[targetR][midC] &lt; target):</span><br><span class="line">                startC = midC</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                endC = midC</span><br><span class="line">        <span class="keyword">if</span> (matrix[targetR][startC] == target <span class="keyword">or</span> matrix[targetR][endC] == target):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意检查空输入</p>
<h3 id="153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><a href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium" class="headerlink" title="153. Find Minimum in Rotated Sorted Array (Medium)"></a><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/description/" target="_blank" rel="noopener">153. Find Minimum in Rotated Sorted Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).</span><br><span class="line"></span><br><span class="line">Find the minimum element.</span><br><span class="line"></span><br><span class="line">You may assume no duplicate exists in the array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [3,4,5,1,2]</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [4,5,6,7,0,1,2]</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>思路：找 pivot，pivot &gt; 0 时返回 nums[pivot + 1]。找 pivot 时,如果 mid &lt; start, 扔 end， 如果 mid &gt; start 扔 start<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMin</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt; nums[len(nums) - <span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; nums[start]):</span><br><span class="line">                end = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                start = mid</span><br><span class="line">        <span class="keyword">return</span> nums[end]</span><br></pre></td></tr></table></figure></p>
<p>总结：应改为 Easy 难度的题。<br>Follow up: 如果有重复的数? 无法保证在 Log(N) 的时间复杂度内解决 例子:[1,1,1,1,1….,1] 里藏着一个 0.最坏情况下需要把每个位置上的1都看一遍，才能找到最后一个有0 的位置. 考点:能想到这个最坏情况的例子</p>
<h3 id="33-Search-in-Rotated-Sorted-Array-Medium"><a href="#33-Search-in-Rotated-Sorted-Array-Medium" class="headerlink" title="33. Search in Rotated Sorted Array (Medium)"></a><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/description/" target="_blank" rel="noopener">33. Search in Rotated Sorted Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</span><br><span class="line"></span><br><span class="line">(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</span><br><span class="line"></span><br><span class="line">You are given a target value to search. If found in the array return its index, otherwise return -1.</span><br><span class="line"></span><br><span class="line">You may assume no duplicate exists in the array.</span><br><span class="line"></span><br><span class="line">Your algorithm's runtime complexity must be in the order of O(log n).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">Output: 4</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">Output: -1</span><br></pre></td></tr></table></figure>
<p>思路：第一感觉是得知道 pivot 在哪，有 pivot 一侧不能随便扔，但是更优的方法是查单调的侧是否可以扔<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        start, end = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> (start + <span class="number">1</span> &lt; end):</span><br><span class="line">            mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[start] &lt; nums[mid]:</span><br><span class="line">                <span class="keyword">if</span> nums[start] &lt;= target &lt;= nums[mid]:</span><br><span class="line">                    end = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    start = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[mid] &lt;= target &lt;= nums[end]:</span><br><span class="line">                    start = mid</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid</span><br><span class="line">        <span class="keyword">if</span> nums[start] == target:</span><br><span class="line">            <span class="keyword">return</span> start</span><br><span class="line">        <span class="keyword">if</span> nums[end] == target:</span><br><span class="line">            <span class="keyword">return</span> end</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结： 注意 [1, 3, 5] target 为 1 这种边界条件， 判断 target 在单调这边需要加等号</p>
<h3 id="LinC-140-Fast-Power-Medium"><a href="#LinC-140-Fast-Power-Medium" class="headerlink" title="LinC 140. Fast Power (Medium)"></a><a href="https://www.lintcode.com/problem/fast-power/description" target="_blank" rel="noopener">LinC 140. Fast Power (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Calculate the a**n % b where a, b and n are all 32bit integers.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">For 2**31 % 3 = 2</span><br><span class="line"></span><br><span class="line">For 100**1000 % 1000 = 0</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(logn)</span><br></pre></td></tr></table></figure>
<p>思路：第一感觉是：需要用某种数学方法，取模只取决于这个数取模后剩下的数加多少次，可以将次方换成乘法，再取模，乘法可以换算成 n 次幂取模 b 再乘 a。<br>总结：递归版本： (a <em> b) % p = (a % p </em> b % p) % p 将 a^n % b 分解为 (a^(n/2) <em> a^(n/2) </em> (a)) %b = ((a^(n/2) <em> a^(n/2))%b </em> (a)%b) %b = ((a^(n/2)%b <em> a^(n/2)%b)%b </em> (a)%b) %b； 非递归版本，思路是转换为二进制</p>
<h3 id="50-Pow-x-n-Medium"><a href="#50-Pow-x-n-Medium" class="headerlink" title="50. Pow(x, n) (Medium)"></a><a href="https://leetcode.com/problems/powx-n/description/" target="_blank" rel="noopener">50. Pow(x, n) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Implement pow(x, n), which calculates x raised to the power n (xn).</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2.00000, 10</span><br><span class="line">Output: 1024.00000</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 2.10000, 3</span><br><span class="line">Output: 9.26100</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 2.00000, -2</span><br><span class="line">Output: 0.25000</span><br><span class="line">Explanation: 2-2 = 1/22 = 1/4 = 0.25</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">-100.0 &lt; x &lt; 100.0</span><br><span class="line">n is a 32-bit signed integer, within the range [−231, 231 − 1]</span><br></pre></td></tr></table></figure>
<p>思路：递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type x: float</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: float</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> / self.power(x, -n)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.power(x, n)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">power</span><span class="params">(self, x, n)</span>:</span>    </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        result = self.power(x, n // <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> result * result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> x * result * result</span><br></pre></td></tr></table></figure></p>
<p>总结：有固定写法套路的题目， 不值得做。</p>
<h3 id="228-Summary-Ranges-Medium"><a href="#228-Summary-Ranges-Medium" class="headerlink" title="228. Summary Ranges (Medium)"></a><a href="https://leetcode.com/problems/summary-ranges/description/" target="_blank" rel="noopener">228. Summary Ranges (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted integer array without duplicates, return the summary of its ranges.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:  [0,1,2,4,5,7]</span><br><span class="line">Output: ["0-&gt;2","4-&gt;5","7"]</span><br><span class="line">Explanation: 0,1,2 form a continuous range; 4,5 form a continuous range.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:  [0,2,3,4,6,8,9]</span><br><span class="line">Output: ["0","2-&gt;4","6","8-&gt;9"]</span><br><span class="line">Explanation: 2,3,4 form a continuous range; 8,9 form a continuous range.</span><br></pre></td></tr></table></figure>
<p>思路：最土的办法就是 O(n), Medium 题肯定是利用 index 和 value 增量的关系用二分法找断点，然后将上一个断点连上<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先写 O(n) 的再优化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">summaryRanges</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> [str(nums[<span class="number">0</span>])]</span><br><span class="line">        ans = []</span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; len(nums):            </span><br><span class="line">            <span class="keyword">if</span> fast + <span class="number">1</span> &lt; len(nums) <span class="keyword">and</span> nums[fast + <span class="number">1</span>] == nums[fast] + <span class="number">1</span>:</span><br><span class="line">                <span class="comment"># fast keeps going</span></span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> slow == fast:</span><br><span class="line">                <span class="comment"># need to put slow in the ans</span></span><br><span class="line">                ans.append(str(nums[slow]))</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">                slow = fast</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># create range</span></span><br><span class="line">                ans.append(str(nums[slow]) + <span class="string">'-&gt;'</span> + str(nums[fast]))</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">                slow = fast</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：O(n) 一次写过都不容易，注意 1.slow 和 fast 都从 0 开始；2.循环条件 fast &lt; len(nums); 3.三种情况：fast 前进，fast 不前进 fast 和 slow 在一起， fast 不前进 fast 在 slow 前面 4。fast 前进的判断 if fast + 1 &lt; len(nums) and nums[fast + 1] == nums[fast] + 1。比两年多前的写法要略优一点。</p>
<h1 id="Two-pointers"><a href="#Two-pointers" class="headerlink" title="Two pointers"></a>Two pointers</h1><h3 id="LinC-373-Partition-Array-by-Odd-and-Even-Easy"><a href="#LinC-373-Partition-Array-by-Odd-and-Even-Easy" class="headerlink" title="LinC 373. Partition Array by Odd and Even (Easy)"></a><a href="http://www.lintcode.com/problem/partition-array-by-odd-and-even/" target="_blank" rel="noopener">LinC 373. Partition Array by Odd and Even (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Partition an integers array into odd number first and even number second.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given [1, 2, 3, 4], return [1, 3, 2, 4]</span><br></pre></td></tr></table></figure>
<p>思路：双指针一头一尾，碰到不符合的就换。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: nums: an array of integers</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionArray</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> nums[l] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> nums[r] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        <span class="keyword">if</span> nums[l] % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> nums[r] % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br></pre></td></tr></table></figure></p>
<p>总结：送两个测试数据进去就能写对。 最后两个 if 可以简化。</p>
<h3 id="26-Remove-Duplicates-from-Sorted-Array-Easy"><a href="#26-Remove-Duplicates-from-Sorted-Array-Easy" class="headerlink" title="26. Remove Duplicates from Sorted Array (Easy)"></a><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">26. Remove Duplicates from Sorted Array (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.</span><br><span class="line"></span><br><span class="line">Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given nums = [1,1,2],</span><br><span class="line"></span><br><span class="line">Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what you leave beyond the returned length.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given nums = [0,0,1,1,1,2,2,3,3,4],</span><br><span class="line"></span><br><span class="line">Your function should return length = 5, with the first five elements of nums being modified to 0, 1, 2, 3, and 4 respectively.</span><br><span class="line"></span><br><span class="line">It doesn't matter what values are set beyond the returned length.</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">Confused why the returned value is an integer but your answer is an array?</span><br><span class="line"></span><br><span class="line">Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well.</span><br><span class="line"></span><br><span class="line">Internally you can think of this:</span><br><span class="line"></span><br><span class="line">// nums is passed in by reference. (i.e., without making a copy)</span><br><span class="line">int len = removeDuplicates(nums);</span><br><span class="line"></span><br><span class="line">// any modification to nums in your function would be known by the caller.</span><br><span class="line">// using the length returned by your function, it prints the first len elements.</span><br><span class="line">for (int i = 0; i <span class="tag">&lt; <span class="attr">len</span>; <span class="attr">i</span>++) &#123;</span></span><br><span class="line"><span class="tag">    <span class="attr">print</span>(<span class="attr">nums</span>[<span class="attr">i</span>]);</span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure>
<p>思路：简单题， 慢指针只有在快指针碰到不同的值才走。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[fast] == nums[slow]:</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                slow += <span class="number">1</span></span><br><span class="line">                nums[slow] = nums[fast]</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：纯热身，秒解</p>
<h3 id="28-Implement-strStr-Easy"><a href="#28-Implement-strStr-Easy" class="headerlink" title="28. Implement strStr() (Easy)"></a><a href="https://leetcode.com/problems/implement-strstr/description/" target="_blank" rel="noopener">28. Implement strStr() (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Implement strStr().</span><br><span class="line"></span><br><span class="line">Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: haystack = "hello", needle = "ll"</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: haystack = "aaaaa", needle = "bba"</span><br><span class="line">Output: -1</span><br><span class="line">Clarification:</span><br><span class="line"></span><br><span class="line">What should we return when needle is an empty string? This is a great question to ask during an interview.</span><br><span class="line"></span><br><span class="line">For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().</span><br></pre></td></tr></table></figure>
<p>思路：快慢指针<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">strStr</span><span class="params">(self, haystack, needle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type haystack: str</span></span><br><span class="line"><span class="string">        :type needle: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(needle) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(haystack) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(haystack)):</span><br><span class="line">            <span class="keyword">if</span> haystack[i] == needle[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">if</span> i + len(needle) - <span class="number">1</span> &lt; len(haystack):</span><br><span class="line">                    <span class="keyword">if</span> needle == haystack[i: i + len(needle)]:</span><br><span class="line">                        <span class="keyword">return</span> i</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结: 思路是双指针没问题，实际用 python 的时候可以用 python 的性质直接取子串</p>
<h3 id="160-Intersection-of-Two-Linked-Lists-Easy"><a href="#160-Intersection-of-Two-Linked-Lists-Easy" class="headerlink" title="160. Intersection of Two Linked Lists (Easy)"></a><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">160. Intersection of Two Linked Lists (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Write a program to find the node at which the intersection of two singly linked lists begins.</span><br><span class="line"></span><br><span class="line">For example, the following two linked lists:</span><br><span class="line"></span><br><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br><span class="line">begin to intersect at node c1.</span><br><span class="line"></span><br><span class="line">Notes:</span><br><span class="line">If the two linked lists have no intersection at all, return null.</span><br><span class="line">The linked lists must retain their original structure after the function returns.</span><br><span class="line">You may assume there are no cycles anywhere in the entire linked structure.</span><br><span class="line">Your code should preferably run in O(n) time and use only O(1) memory.</span><br></pre></td></tr></table></figure>
<p>思路：统计两条链走到头的长度，lenA 和 lenB, 然后让长的那条先走两者的差值，然后一起走，返回相遇的那点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getIntersectionNode</span><span class="params">(self, headA, headB)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head1, head1: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        savedHeadA, savedHeadB = headA, headB</span><br><span class="line">        <span class="keyword">if</span> headA == <span class="keyword">None</span> <span class="keyword">or</span> headB == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        lenA, lenB = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> headA.next != <span class="keyword">None</span>:</span><br><span class="line">            headA = headA.next</span><br><span class="line">            lenA += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> headB.next != <span class="keyword">None</span>:</span><br><span class="line">            headB = headB.next</span><br><span class="line">            lenB += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> lenA &gt; lenB:</span><br><span class="line">            diff = lenA - lenB</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> xrange(diff):</span><br><span class="line">                savedHeadA = savedHeadA.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            diff = lenB - lenA</span><br><span class="line">            <span class="keyword">for</span> x <span class="keyword">in</span> xrange(diff):</span><br><span class="line">                savedHeadB = savedHeadB.next</span><br><span class="line">        <span class="keyword">while</span> savedHeadA != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> savedHeadA == savedHeadB:</span><br><span class="line">                <span class="keyword">return</span> savedHeadA</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                savedHeadA = savedHeadA.next</span><br><span class="line">                savedHeadB = savedHeadB.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure>
<p>总结：1.注意空输入（不能假设 headA 或 B 有 next）2.注意 headA headB 是一个节点 i.e. 合体的情况</p>
<h3 id="141-Linked-List-Cycle-Easy"><a href="#141-Linked-List-Cycle-Easy" class="headerlink" title="141. Linked List Cycle (Easy)"></a><a href="https://leetcode.com/problems/linked-list-cycle/description/" target="_blank" rel="noopener">141. Linked List Cycle (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Given a linked list, determine if it has a cycle in it.</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Can you solve it without using extra space?</span><br></pre></td></tr></table></figure>
<p>思路：记得应该是慢的 +1 快的 +2 如果有 loop 会重逢。。。可能不那么值得做，热身吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        slow, fast = head, head.next.next</span><br><span class="line">        <span class="keyword">while</span> fast != <span class="keyword">None</span> <span class="keyword">and</span> fast.next != <span class="keyword">None</span> <span class="keyword">and</span> fast.next.next != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：有点意思，适合热身，代码写好后要测的情况比较多， 1 -&gt; 2 无 loop，1 -&gt; 2 -&gt; 3 -&gt; 4 loop 回 2 这些情况都要测一下。防止 next 和 next.next 不存在的情况</p>
<h3 id="142-Linked-List-Cycle-II-Medium"><a href="#142-Linked-List-Cycle-II-Medium" class="headerlink" title="142. Linked List Cycle II (Medium)"></a><a href="https://leetcode.com/problems/linked-list-cycle-ii/description/" target="_blank" rel="noopener">142. Linked List Cycle II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</span><br><span class="line"></span><br><span class="line">Note: Do not modify the linked list.</span><br><span class="line"></span><br><span class="line">Follow up:</span><br><span class="line">Can you solve it without using extra space?</span><br></pre></td></tr></table></figure>
<p>思路：记得好像是找到有 loop 以后走多久能找到 cycle 的起点。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">detectCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        slow, fast = head, head</span><br><span class="line">        <span class="keyword">while</span> fast.next != <span class="keyword">None</span> <span class="keyword">and</span> fast.next.next != <span class="keyword">None</span>:</span><br><span class="line">            slow = slow.next</span><br><span class="line">            fast = fast.next.next            </span><br><span class="line">            <span class="keyword">if</span> slow == fast:</span><br><span class="line">                <span class="keyword">while</span> head != slow:</span><br><span class="line">                    head = head.next</span><br><span class="line">                    slow = slow.next</span><br><span class="line">                <span class="keyword">return</span> head</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">```        </span><br><span class="line">总结：slow fast 同时在 head，先走再判断。不然容易出错。有数学关系，面试当场不一定能推导出来。就算推导出来也要注意前面的 slow，fast写法。</span><br><span class="line">    a            b</span><br><span class="line">A ------ B --------+</span><br><span class="line">         |         |</span><br><span class="line">       c |         |</span><br><span class="line">         +-------- C</span><br><span class="line"></span><br><span class="line">* A: 起始点</span><br><span class="line">* B: Cycle Begins</span><br><span class="line">* C: <span class="number">1</span>st 快慢指针相遇点</span><br><span class="line"></span><br><span class="line">* A-&gt;B: a</span><br><span class="line">* B-&gt;C: b</span><br><span class="line">* C-&gt;B: c</span><br><span class="line">* 环的长度 (b+c) 为 R</span><br><span class="line"></span><br><span class="line">第一次相遇时，慢指针所走步数为 a + b 快指针走的步数为 *a + b + nR*</span><br><span class="line">我们知道快指针是慢指针速度的<span class="number">2</span>倍，因此 <span class="number">2</span>(a + b) = a + b + nR 那么 a + b = nR</span><br><span class="line">同时 b + c = R 所以 a = (n - <span class="number">1</span>)R + c;</span><br><span class="line">也就是说，从A点和C点同时出发，以相同的速度前进，相遇的位置将是B。</span><br><span class="line"></span><br><span class="line"><span class="comment">### [283. Move Zeroes (Easy)](https://leetcode.com/problems/move-zeroes/description/)</span></span><br><span class="line">```html</span><br><span class="line">Given an array nums, write a function to move all <span class="number">0</span><span class="string">'s to the end of it while maintaining the relative order of the non-zero elements.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Example:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Input: [0,1,0,3,12]</span></span><br><span class="line"><span class="string">Output: [1,3,12,0,0]</span></span><br><span class="line"><span class="string">Note:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">You must do this in-place without making a copy of the array.</span></span><br><span class="line"><span class="string">Minimize the total number of operations.</span></span><br></pre></td></tr></table></figure></p>
<p>思路：第一感觉是快指针直接跑到最后， 慢指针遇到 0 就接快指针面；仔细读题才发现是数组 in place 转换；那就快指针到第一个非 0 的数，直到快指针到最后<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moveZeroes</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        slow, fast = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> fast &lt; len(nums) <span class="keyword">and</span> nums[fast] == <span class="number">0</span>:</span><br><span class="line">            fast += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> slow &lt; len(nums) - <span class="number">1</span> <span class="keyword">and</span> fast &lt; len(nums):</span><br><span class="line">            <span class="keyword">if</span> nums[slow] == <span class="number">0</span>:</span><br><span class="line">                nums[slow], nums[fast] = nums[fast], nums[slow]</span><br><span class="line">                <span class="keyword">while</span> fast &lt; len(nums) <span class="keyword">and</span> nums[fast] == <span class="number">0</span>:</span><br><span class="line">                    fast += <span class="number">1</span></span><br><span class="line">            slow += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> slow &gt; fast:</span><br><span class="line">                fast += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> fast &lt; len(nums) <span class="keyword">and</span> nums[fast] == <span class="number">0</span>:</span><br><span class="line">                    fast += <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：思路简单，但是情况很多， 需要考虑，无 0， 0 在前， 后， 中四种情况 [1,2], [0, 1, 2], [1, 0, 0], [1, 0, 0, 1] 才能写对</p>
<h3 id="125-Valid-Palindrome-Easy"><a href="#125-Valid-Palindrome-Easy" class="headerlink" title="125. Valid Palindrome (Easy)"></a><a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">125. Valid Palindrome (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.</span><br><span class="line"></span><br><span class="line">Note: For the purpose of this problem, we define empty string as valid palindrome.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "A man, a plan, a canal: Panama"</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "race a car"</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>思路：头尾双指针， 碰头了返回 True，相同继续走，不同返回 False<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span> <span class="keyword">or</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        head, tail = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[head].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">not</span> s[tail].isalnum() <span class="keyword">and</span> head &lt; tail:</span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> s[head].lower() != s[tail].lower():</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：思路简单， 但是要想到的 case 很多。考虑带标点符号，连续两个位置都是标点符号，整个字符串都是标点符合这三个情况才能写对</p>
<h3 id="680-Valid-Palindrome-II-Easy"><a href="#680-Valid-Palindrome-II-Easy" class="headerlink" title="680. Valid Palindrome II (Easy)"></a><a href="https://leetcode.com/problems/valid-palindrome-ii/description/" target="_blank" rel="noopener">680. Valid Palindrome II (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty string s, you may delete at most one character. Judge whether you can make it a palindrome.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: "aba"</span><br><span class="line">Output: True</span><br><span class="line">Example 2:</span><br><span class="line">Input: "abca"</span><br><span class="line">Output: True</span><br><span class="line">Explanation: You could delete the character 'c'.</span><br><span class="line">Note:</span><br><span class="line">The string will only contain lowercase characters a-z. The maximum length of the string is 50000.</span><br></pre></td></tr></table></figure>
<p>思路：目前网上看到大部分答案都以贪心算法为主，等看贪心了再刷这题。再看一眼感觉就是统计有没有 &gt; 2 单数的题，撸之<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            <span class="keyword">if</span> s[l] != s[r]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            l += <span class="number">1</span></span><br><span class="line">            r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> l &gt;= r:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># 要么删左边，要么删右边</span></span><br><span class="line">        <span class="keyword">return</span> self.isPalindrome(s[:l] + s[l + <span class="number">1</span>:]) <span class="keyword">or</span> self.isPalindrome(s[:r] + s[r + <span class="number">1</span>:])</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：没那么简单，还要考虑这些情况 1.如果有 2 个 single 均不在 mid 位置；2. 去掉 single 点后的 string 仍然不是 palindrome; 3. 1 个 single，多个位置可以删除； 然后就抓狂了。 看了答案， 真他妈的妖。双指针算法。从两头走到中间，发现第一对不一样的字符之后，要么删左边的，要么删右边的。</p>
<h3 id="1-Two-Sum-Easy"><a href="#1-Two-Sum-Easy" class="headerlink" title="1. Two Sum (Easy)"></a><a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">1. Two Sum (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Given an array of integers, return indices of the two numbers such that they add up to a specific target.</span><br><span class="line"></span><br><span class="line">You may assume that each input would have exactly one solution, and you may not use the same element twice.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line">return [0, 1].</span><br></pre></td></tr></table></figure>
<p>思路：固定一个找另一个<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> index1 <span class="keyword">in</span> xrange(len(nums)):</span><br><span class="line">            <span class="keyword">for</span> index2 <span class="keyword">in</span> xrange(index1 + <span class="number">1</span>, len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[index1] + nums[index2] == target:</span><br><span class="line">                    <span class="keyword">return</span> [index1, index2]</span><br></pre></td></tr></table></figure></p>
<p>总结： 第二层循环的起始数字注意条件 you may not use the same element twice</p>
<h3 id="167-Two-Sum-II-Input-array-is-sorted-Easy"><a href="#167-Two-Sum-II-Input-array-is-sorted-Easy" class="headerlink" title="167. Two Sum II - Input array is sorted (Easy)"></a><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">167. Two Sum II - Input array is sorted (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.</span><br><span class="line"></span><br><span class="line">The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Your returned answers (both index1 and index2) are not zero-based.</span><br><span class="line">You may assume that each input would have exactly one solution and you may not use the same element twice.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: numbers = [2,7,11,15], target = 9</span><br><span class="line">Output: [1,2]</span><br><span class="line">Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.</span><br></pre></td></tr></table></figure>
<p>思路：增加了 sorted 这个条件， 第一感觉是可以折半查找了。固定 index1，index2 用折半查找获得<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span><span class="params">(self, numbers, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numbers: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> index1 <span class="keyword">in</span> range(len(numbers)):</span><br><span class="line">            start, end = index1 + <span class="number">1</span>, len(numbers) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> start + <span class="number">1</span> &lt; end:</span><br><span class="line">                mid = start + (end - start) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> numbers[index1] + numbers[mid] == target:</span><br><span class="line">                    <span class="keyword">return</span> [index1 + <span class="number">1</span>, mid + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> numbers[index1] + numbers[mid] &lt; target:</span><br><span class="line">                    start = mid + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    end = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> numbers[index1] + numbers[start] == target:</span><br><span class="line">                <span class="keyword">return</span> [index1 + <span class="number">1</span>, start + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> numbers[index1] + numbers[end] == target:</span><br><span class="line">                <span class="keyword">return</span> [index1 + <span class="number">1</span>, end + <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：要细心。1.题中 answers are not zero-based 2.要测两个情况 [2, 7, 19], 9 和 [5, 25, 75] 可以测出代码的问题</p>
<h3 id="LinC-607-Two-Sum-III-Data-structure-design-Easy"><a href="#LinC-607-Two-Sum-III-Data-structure-design-Easy" class="headerlink" title="LinC 607. Two Sum III - Data structure design (Easy)"></a><a href="https://www.lintcode.com/problem/two-sum-iii-data-structure-design/description" target="_blank" rel="noopener">LinC 607. Two Sum III - Data structure design (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Design and implement a TwoSum class. It should support the following operations: add and find.</span><br><span class="line"></span><br><span class="line">add - Add the number to an internal data structure.</span><br><span class="line">find - Find if there exists any pair of numbers which sum is equal to the value.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">add(1); add(3); add(5);</span><br><span class="line">find(4) // return true</span><br><span class="line">find(7) // return false</span><br></pre></td></tr></table></figure>
<p>思路：add 的时候把 sum 都存 dict 里面， 查的时候直接返回 dict 里面有没有 sum. 会超时。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TwoSum</span>:</span></span><br><span class="line">    keys = &#123;&#125;</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: number: An integer</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> number <span class="keyword">not</span> <span class="keyword">in</span> self.keys:</span><br><span class="line">            self.keys[number] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.keys[number] = <span class="number">2</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: value: An integer</span></span><br><span class="line"><span class="string">    @return: Find if there exists any pair of numbers which sum is equal to the value.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.keys:</span><br><span class="line">            <span class="keyword">if</span> value - key <span class="keyword">in</span> self.keys:</span><br><span class="line">                <span class="keyword">if</span> value - key == key:</span><br><span class="line">                    <span class="keyword">if</span> self.keys[key] == <span class="number">2</span>:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：虽然是一道容易题， 第一反应的思路会超时。 需要在 find 的时候判断能凑出答案的另一个 key 是不是已经在 keys 里了。而不是先存好 sum。 还要判断两个数相同的时候有没有存过两个数。</p>
<h3 id="15-3Sum-Medium"><a href="#15-3Sum-Medium" class="headerlink" title="15. 3Sum (Medium)"></a><a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">15. 3Sum (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The solution set must not contain duplicate triplets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [-1, 0, 1, 2, -1, -4],</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：可以吧 a + b + c = 0 变为 a + b = - c 的问题，问题则变为， 对于任意数 a，dict 里是否存在 -c - a 这么个数， a 和 c 是两层循环<br>二刷：可以把天真的第一想法扔掉了：）。 就是以当前遍历的点 i 为基础的双指针。二刷比一刷有一点改进空间。python 的 list 就带一定的去重机制，可以少写几行去重代码。3 年前写的还是很牛逼的。。。靠，三年前的写法会 TLE。。。真是难度越来越高了。。。尼玛。。。注意：当 sum == 0 的时候需要在 ans.appen(); l += 1; r -= 1; 的基础上加 while l &lt; r and <strong>nums[l] == nums[l - 1]:</strong> l += 1 和 while l &lt; r and nums[r] == nums[r + 1]: r -= 1 这样的跳过语句才能 AC。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        results = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> index1 <span class="keyword">in</span> range(len(nums) - <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> index1 <span class="keyword">and</span> nums[index1] == nums[index1 - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            head = index1 + <span class="number">1</span></span><br><span class="line">            tail = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">                <span class="keyword">if</span> nums[index1] + nums[head] &gt; -nums[tail]:</span><br><span class="line">                    tail -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[index1] + nums[head] &lt; -nums[tail]:</span><br><span class="line">                    head += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    results.append([nums[index1], nums[head], nums[tail]])</span><br><span class="line">                    head += <span class="number">1</span></span><br><span class="line">                    tail -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> head &lt; tail <span class="keyword">and</span> nums[head] == nums[head - <span class="number">1</span>]:</span><br><span class="line">                        head += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> head &lt; tail <span class="keyword">and</span> nums[tail] == nums[tail + <span class="number">1</span>]:</span><br><span class="line">                        tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure></p>
<p>总结：三层循环是暴力方法，去重会受阻，这个时候需要想到给输入数组先排个序，因为结果里，没有要求元素的顺序，这是个重要的提示。排序以后每次固定一个数 index1，然后找的过程是：head = index1 + 1, tail = len(nums) - 1; while head &lt; tail:  if nums[index1] + nums[head] &gt; - nums[tail]: tail -= 1, elif nums[index1] + nums[head] &lt; -nums[tail]: head += 1, else: results.append()<br>代码还需要考虑的几个情况：1.对于已经用过的元素需要跳过， 这里要用到 if index1 and nums[index1] == nums[index1 - 1]; 2.如果碰到了一个 result，要跳过所有重复的元素，需要用到 while head &lt; tail and nums[head] == nums[head - 1]: 和相应的 …nums[tail + 1]</p>
<h3 id="LinC-382-Triangle-Count-Medium"><a href="#LinC-382-Triangle-Count-Medium" class="headerlink" title="LinC 382. Triangle Count (Medium)"></a><a href="https://www.lintcode.com/problem/triangle-count/description" target="_blank" rel="noopener">LinC 382. Triangle Count (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given an array of integers, how many three numbers can be found in the array, so that we can build an triangle whose three edges length is the three numbers that we find?</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given array S = [3,4,6,7], return 3. They are:</span><br><span class="line"></span><br><span class="line">[3,4,6]</span><br><span class="line">[3,6,7]</span><br><span class="line">[4,6,7]</span><br><span class="line">Given array S = [4,4,4,4], return 4. They are:</span><br><span class="line"></span><br><span class="line">[4(1),4(2),4(3)]</span><br><span class="line">[4(1),4(2),4(4)]</span><br><span class="line">[4(1),4(3),4(4)]</span><br><span class="line">[4(2),4(3),4(4)]</span><br></pre></td></tr></table></figure>
<p>思路： 判断能不能做三角形以后全排列<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param S: A list of integers</span></span><br><span class="line"><span class="string">    @return: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">triangleCount</span><span class="params">(self, S)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        S.sort(reverse=<span class="keyword">True</span>)</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> index1, longest <span class="keyword">in</span> enumerate(S):</span><br><span class="line">            head, tail = index1 + <span class="number">1</span>, index1 + <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> tail &lt; len(S) <span class="keyword">and</span> S[head] + S[tail] &gt; longest:</span><br><span class="line">                tail += <span class="number">1</span></span><br><span class="line">            tail -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">                sum += tail - head</span><br><span class="line">                head += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> head &lt; tail <span class="keyword">and</span> S[head] + S[tail] &lt;= longest:</span><br><span class="line">                    tail -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sum</span><br></pre></td></tr></table></figure></p>
<p>总结：看清题目，问的是有多少个这样的三角形， 返回数就行。 全排列效率比较低。 更优解是每次定下最长边， 寻找符合条件的另外两个边的数量。 双指针的解法是将 tail 推到最小不能组成三角形的位置， 退一步， 然后从 tail 到 head 的位置的都可以组， 因为他们相加只会比最长边更长。 然后将 head 进一步（缩短），tail 边加长到大于最长边的位置，新 tail 到 head 的位置又都可以组。</p>
<h3 id="16-3Sum-Closest-Medium"><a href="#16-3Sum-Closest-Medium" class="headerlink" title="16. 3Sum Closest (Medium)"></a><a href="https://leetcode.com/problems/3sum-closest/description/" target="_blank" rel="noopener">16. 3Sum Closest (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [-1, 2, 1, -4], and target = 1.</span><br><span class="line"></span><br><span class="line">The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure>
<p>思路：3sum 的思路是先排序，固定一个点以后，开始用双指针搜索符合条件的数。closest 感觉已经是 4sum，需要记 delta，然后往 delata 小的方向走。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSumClosest</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = <span class="keyword">None</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> index1, val <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            head = index1 + <span class="number">1</span></span><br><span class="line">            tail = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> head &lt; tail:</span><br><span class="line">                sum = nums[index1] + nums[head] + nums[tail]</span><br><span class="line">                <span class="keyword">if</span> ans == <span class="keyword">None</span> <span class="keyword">or</span> abs(target - sum) &lt; abs(target - ans):</span><br><span class="line">                    ans = sum</span><br><span class="line">                <span class="keyword">if</span> sum &lt; target:</span><br><span class="line">                    head += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> sum &gt; target:</span><br><span class="line">                    tail -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：比 3sum 省事的是不需要优化跳过重复的元素也可以过。pyhton 可以用 None 就不用想 Java 那样吧 ans 初始化为 MAX_VALUE 了</p>
<h3 id="86-Partition-List-Medium"><a href="#86-Partition-List-Medium" class="headerlink" title="86. Partition List (Medium)"></a><a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">86. Partition List (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.</span><br><span class="line"></span><br><span class="line">You should preserve the original relative order of the nodes in each of the two partitions.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: head = 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2, x = 3</span><br><span class="line">Output: 1-&gt;2-&gt;2-&gt;4-&gt;3-&gt;5</span><br></pre></td></tr></table></figure>
<p>思路：慢快指针，慢指针在最后一个 &lt; x 的位置， 快指针在最后一个 &gt;= x 的位置，快指针碰到一个 &lt; x 的就和慢指针换<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, head, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> head == <span class="keyword">None</span> <span class="keyword">or</span> head.next == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        fakie = ListNode(<span class="number">-1</span>)</span><br><span class="line">        fakie.next = head</span><br><span class="line">        slow, fast = fakie, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> slow != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">while</span> slow != <span class="keyword">None</span> <span class="keyword">and</span> slow.next != <span class="keyword">None</span> <span class="keyword">and</span> slow.next.val &lt; x:</span><br><span class="line">                slow = slow.next</span><br><span class="line">            <span class="keyword">if</span> fast == <span class="keyword">None</span>:</span><br><span class="line">                fast = slow</span><br><span class="line">            <span class="keyword">while</span> fast != <span class="keyword">None</span> <span class="keyword">and</span> fast.next != <span class="keyword">None</span> <span class="keyword">and</span> fast.next.val &gt;= x:</span><br><span class="line">                fast = fast.next</span><br><span class="line">            <span class="keyword">if</span> fast.next == <span class="keyword">None</span> <span class="keyword">or</span> slow.next == <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            savedFastNext = fast.next</span><br><span class="line">            fast.next = fast.next.next</span><br><span class="line">            savedSlowNext = slow.next</span><br><span class="line">            slow.next = savedFastNext</span><br><span class="line">            savedFastNext.next = savedSlowNext</span><br><span class="line">            slow = slow.next</span><br><span class="line">        <span class="keyword">return</span> fakie.next</span><br></pre></td></tr></table></figure></p>
<p>总结：链表的问题需要先放一个假头，注意 1-&gt;1 x = 0, 1-&gt;1 x = 2, 2-&gt;1 x = 2 这三种情况和题中的例子情况 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;2 才能写对。</p>
<h3 id="LinC-31-Partition-Array-Medium"><a href="#LinC-31-Partition-Array-Medium" class="headerlink" title="LinC 31. Partition Array (Medium)"></a><a href="https://www.lintcode.com/problem/partition-array/description" target="_blank" rel="noopener">LinC 31. Partition Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Description</span><br><span class="line">Given an array nums of integers and an int k, partition the array (i.e move the elements in "nums") such that:</span><br><span class="line"></span><br><span class="line">All elements <span class="tag">&lt; <span class="attr">k</span> <span class="attr">are</span> <span class="attr">moved</span> <span class="attr">to</span> <span class="attr">the</span> <span class="attr">left</span></span></span><br><span class="line"><span class="tag"><span class="attr">All</span> <span class="attr">elements</span> &gt;</span>= k are moved to the right</span><br><span class="line">Return the partitioning index, i.e the first index i nums[i] &gt;= k.</span><br><span class="line"></span><br><span class="line">You should do really partition in array nums instead of just counting the numbers of integers smaller than k.</span><br><span class="line"></span><br><span class="line">If all elements in nums are smaller than k, then return nums.length</span><br><span class="line">Example</span><br><span class="line">If nums = [3,2,2,1] and k=2, a valid answer is 1.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">Can you partition the array in-place and in O(n)?</span><br></pre></td></tr></table></figure>
<p>思路：和 partition list 很像， 数组的话就只能用双指针了. l 是最后一个 &lt; k, r 是最后一个 &gt;= k<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param nums: The integer array you should partition</span></span><br><span class="line"><span class="string">    @param k: An integer</span></span><br><span class="line"><span class="string">    @return: The index after partition</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partitionArray</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            <span class="keyword">while</span> l &lt; len(nums) <span class="keyword">and</span> nums[l] &lt; k:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> r &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[r] &gt;= k:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; r:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">        <span class="keyword">return</span> l</span><br></pre></td></tr></table></figure></p>
<p>总结：因为数组比链表好操作的多， 比 partition list 解法简单， 需要注意：1。while 的条件是 l &lt;= r 2。l 往右走，r 往左走不要越界，r 往左需要 r &gt;= 0 3.l &gt; r 的时候需要 break</p>
<h3 id="215-Kth-Largest-Element-in-an-Array-Medium"><a href="#215-Kth-Largest-Element-in-an-Array-Medium" class="headerlink" title="215. Kth Largest Element in an Array (Medium)"></a><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">215. Kth Largest Element in an Array (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [3,2,1,5,6,4] and k = 2</span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [3,2,3,1,2,4,5,5,6] and k = 4</span><br><span class="line">Output: 4</span><br><span class="line">Note:</span><br><span class="line">You may assume k is always valid, 1 ≤ k ≤ array's length.</span><br></pre></td></tr></table></figure>
<p>思路：应该是不去排序的基础上找到第 K 大的数。现场想是基本没戏的。网上答案：quickselect 算法，基于 quicksort. 1.选第一个数为 pivot 2.比 pivot 大的放左边， 不然右边 3.如果 pivot 是第 k, 返回该值， 大于 k 扔掉右边， 否则扔掉左边<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        k -= <span class="number">1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span><span class="params">(s, e)</span>:</span></span><br><span class="line">            l, r = s + <span class="number">1</span>, e</span><br><span class="line">            <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &gt; nums[s]:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums[l], nums[r] = nums[r], nums[l]</span><br><span class="line">                    r -= <span class="number">1</span></span><br><span class="line">            nums[s], nums[r] = nums[r], nums[s]</span><br><span class="line">            <span class="keyword">if</span> r == k:</span><br><span class="line">                <span class="keyword">return</span> nums[r]</span><br><span class="line">            <span class="keyword">elif</span> r &gt; k:</span><br><span class="line">                <span class="keyword">return</span> quickSelect(s, r - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> quickSelect(r + <span class="number">1</span>, e)</span><br><span class="line">        <span class="keyword">return</span> quickSelect(<span class="number">0</span>, len(nums) - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：要背 pivot 的部分，如果第一个数是 pivot，那么走一遍，碰到比他大的不动，小的塞右边，l &lt;= r 走完把 pivot 和 r 值互换，r 左边就是大于 pivot 数的子数组. 注意：递归调用的时候记得函数名前要加 return 否则不会返回任何值。由于完全抛弃另一侧，时间复杂度平均由 quick sort 的 O(nlogn) 降为 O(n) 因为输入变小了， quicksort 的输入一直是 n, 最差情况 O(n^2)</p>
<h3 id="75-Sort-Colors-Medium"><a href="#75-Sort-Colors-Medium" class="headerlink" title="75. Sort Colors (Medium)"></a><a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="noopener">75. Sort Colors (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.</span><br><span class="line"></span><br><span class="line">Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</span><br><span class="line"></span><br><span class="line">Note: You are not suppose to use the library's sort function for this problem.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [2,0,2,1,1,0]</span><br><span class="line">Output: [0,0,1,1,2,2]</span><br><span class="line">Follow up:</span><br><span class="line"></span><br><span class="line">A rather straight forward solution is a two-pass algorithm using counting sort.</span><br><span class="line">First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.</span><br><span class="line">Could you come up with a one-pass algorithm using only constant space?</span><br></pre></td></tr></table></figure>
<p>思路：因为只有 3 种颜色，1 pass 就是设好 l, r 两个指针，分别代表颜色的边界，碰到不属于边界的就往正确的边界内交换<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span> <span class="keyword">or</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index, l, r = <span class="number">0</span>, <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> index &lt;= r:</span><br><span class="line">            <span class="keyword">while</span> nums[l] == <span class="number">0</span> <span class="keyword">and</span> l &lt; r:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[r] == <span class="number">2</span> <span class="keyword">and</span> l &lt; r:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> l &gt; index:</span><br><span class="line">                index = l</span><br><span class="line">            <span class="keyword">if</span> nums[index] == <span class="number">0</span>:</span><br><span class="line">                nums[l], nums[index] = nums[index], nums[l]</span><br><span class="line">            <span class="keyword">if</span> nums[index] == <span class="number">1</span>:</span><br><span class="line">                index += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> nums[index] == <span class="number">2</span>:</span><br><span class="line">                nums[index], nums[r] = nums[r], nums[index]</span><br></pre></td></tr></table></figure></p>
<p>总结：counting sort：数一下每个元素有多少个，一次给写到结果里; 这种写法基本上秒出 :)，想当年傻逼呵呵的这种简单题都面试的时候挂掉，哎。。。如今得换种 1 pass 高级点的；一开始想的思路有个问题，就是如果只有两个指针，两个指针都指 1， 中间夹一大堆 2 就没办法了。 改成三指针， l, r 维持边界，index 从 l 走到 r; 要一次写对得注意：1.当 l 大于 index 的时候， index 要追上来 2.整个循环的终止条件需要 l &lt; r and index &lt;= r, 不然过不了 [2, 0, 1] (index &lt;= r), [0, 0], [1, 1] (l &lt; r) 这两个情况</p>
<h3 id="658-Find-K-Closest-Elements-Medium"><a href="#658-Find-K-Closest-Elements-Medium" class="headerlink" title="658. Find K Closest Elements (Medium)"></a><a href="https://leetcode.com/problems/find-k-closest-elements/description/" target="_blank" rel="noopener">658. Find K Closest Elements (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a sorted array, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [1,2,3,4,5], k=4, x=3</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Example 2:</span><br><span class="line">Input: [1,2,3,4,5], k=4, x=-1</span><br><span class="line">Output: [1,2,3,4]</span><br><span class="line">Note:</span><br><span class="line">The value k is positive and will always be smaller than the length of the sorted array.</span><br><span class="line">Length of the given array is positive and will not exceed 104</span><br><span class="line">Absolute value of elements in the array and x will not exceed 104</span><br><span class="line">UPDATE (2017/9/19):</span><br><span class="line">The arr parameter had been changed to an array of integers (instead of a list of integers). Please reload the code definition to get the latest changes.</span><br></pre></td></tr></table></figure>
<p>思路：看答案思路还是比较清楚的，1.二分法查找 target，将 l, r 指针放到正确的位置；2.左右按 diff 走 k；3.往左走到底，往右走到底<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findClosestElements</span><span class="params">(self, arr, k, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type arr: List[int]</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type x: int</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> arr</span><br><span class="line">        ans = []</span><br><span class="line">        l, r = <span class="number">0</span>, len(arr) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># 将 l, r 放到正确的位置， 如果 mid 值 &lt; k, 扔左边， else 仍右边</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r - <span class="number">1</span>:</span><br><span class="line">            mid = l + (r - l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> arr[mid] &lt; x:</span><br><span class="line">                l = mid</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = mid</span><br><span class="line">        <span class="comment"># l，r 都在正确的位置了，左右按 diff 搜集 k 个</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> r &lt;= len(arr) - <span class="number">1</span> <span class="keyword">and</span> count &lt; k:</span><br><span class="line">            <span class="keyword">if</span> abs(arr[l] - x) &lt;= abs(arr[r] - x):</span><br><span class="line">                ans.append(arr[l])</span><br><span class="line">                l -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ans.append(arr[r])</span><br><span class="line">                r += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &gt;= <span class="number">0</span> <span class="keyword">and</span> count &lt; k:</span><br><span class="line">            ans.append(arr[l])</span><br><span class="line">            l -= <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> r &lt;= len(arr) - <span class="number">1</span> <span class="keyword">and</span> count &lt; k:</span><br><span class="line">            ans.append(arr[r])</span><br><span class="line">            r += <span class="number">1</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> sorted(ans)</span><br></pre></td></tr></table></figure></p>
<p>总结：注意：1.结果需要是 sorted；2.题目中的一个条件 “If there is a tie, the smaller elements are always preferred.”</p>
<h3 id="18-4Sum-Medium"><a href="#18-4Sum-Medium" class="headerlink" title="18. 4Sum (Medium)"></a><a href="https://leetcode.com/problems/4sum/description/" target="_blank" rel="noopener">18. 4Sum (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The solution set must not contain duplicate quadruplets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.</span><br><span class="line"></span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [-1,  0, 0, 1],</span><br><span class="line">  [-2, -1, 1, 2],</span><br><span class="line">  [-2,  0, 0, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：看了下三年前的答案，不是特别直观。看了九章的答案，貌似好理解一点：去重，枚举一个数，然后用 3Sum 的做法，O(N^3)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fourSum</span><span class="params">(self, nums, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(nums) - <span class="number">3</span>):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, len(nums) - <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j != i + <span class="number">1</span> <span class="keyword">and</span> nums[j] == nums[j - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                l, r = j + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r:</span><br><span class="line">                    sum = nums[i] + nums[j] + nums[l] + nums[r]</span><br><span class="line">                    <span class="keyword">if</span> sum == target:</span><br><span class="line">                        ans.append([nums[i], nums[j], nums[l], nums[r]])</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l - <span class="number">1</span>]:</span><br><span class="line">                            l += <span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[r] == nums[r + <span class="number">1</span>]:</span><br><span class="line">                            r -= <span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> sum &lt; target:</span><br><span class="line">                        l += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：有一个自己肯定想不出的条件就是第二层循环怎么跳过：<strong>if j != i + 1 and nums[j] == nums[j - 1]: continue</strong>; 非常勉强能过 AC. 看了网上和三年前的，都是用 dict 先存 2sum，然后再 loop 两遍，用 if pair[0] &gt; j 来去重（第三个元素的 index 要大于前面两个）。todo：有兴致二刷的时候写优化的算法吧。不是那么值得二刷。先这么地了。</p>
<h1 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS 广度优先搜索"></a>BFS 广度优先搜索</h1><p>图的遍历 Traversal in Graph</p>
<ul>
<li>层级遍历 Level Order Traversal</li>
<li>由点及面 Connected Component</li>
<li>拓扑排序 Topological Sorting</li>
</ul>
<p>最短路径 Shortest Path in Simple Graph</p>
<ul>
<li>仅限简单图求最短路径。即，图中每条边长度都是1，或者边长都相等</li>
</ul>
<h3 id="695-Max-Area-of-Island-Easy"><a href="#695-Max-Area-of-Island-Easy" class="headerlink" title="695. Max Area of Island (Easy)"></a><a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">695. Max Area of Island (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty 2D array grid of 0's and 1's, an island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</span><br><span class="line"></span><br><span class="line">Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line">Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</span><br><span class="line">Example 2:</span><br><span class="line">[[0,0,0,0,0,0,0,0]]</span><br><span class="line">Given the above grid, return 0.</span><br><span class="line">Note: The length of each dimension in the given grid does not exceed 50.</span><br></pre></td></tr></table></figure>
<p>思路：没啥太多好说的，BFS 暴力<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxAreaOfIsland</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(grid) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[row][col] == <span class="number">1</span>:</span><br><span class="line">                    ans = max(self.bfs(grid, row, col), ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, grid, row, col)</span>:</span></span><br><span class="line">        <span class="keyword">import</span> collections</span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append((row, col))</span><br><span class="line">        grid[row][col] = <span class="number">0</span></span><br><span class="line">        size = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            row, col = q.popleft()</span><br><span class="line">            size += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row - <span class="number">1</span>, col) <span class="keyword">and</span> grid[row - <span class="number">1</span>][col] == <span class="number">1</span>:</span><br><span class="line">                q.append((row - <span class="number">1</span>, col))</span><br><span class="line">                grid[row - <span class="number">1</span>][col] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row + <span class="number">1</span>, col) <span class="keyword">and</span> grid[row + <span class="number">1</span>][col] == <span class="number">1</span>:</span><br><span class="line">                q.append((row + <span class="number">1</span>, col))</span><br><span class="line">                grid[row + <span class="number">1</span>][col] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row, col - <span class="number">1</span>) <span class="keyword">and</span> grid[row][col - <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                q.append((row, col - <span class="number">1</span>))</span><br><span class="line">                grid[row][col - <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> self.isValid(grid, row, col + <span class="number">1</span>) <span class="keyword">and</span> grid[row][col + <span class="number">1</span>] == <span class="number">1</span>:</span><br><span class="line">                q.append((row, col + <span class="number">1</span>))</span><br><span class="line">                grid[row][col + <span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> size</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, grid, row, col)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> row &gt;= <span class="number">0</span> <span class="keyword">and</span> row &lt; len(grid) <span class="keyword">and</span> col &gt;= <span class="number">0</span> <span class="keyword">and</span> col &lt; len(grid[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>总结：在上下左右走的时候注意入 q 以后立刻将该点标为 0， 以防同一个点入两次。</p>
<h3 id="102-Binary-Tree-Level-Order-Traversal-Medium"><a href="#102-Binary-Tree-Level-Order-Traversal-Medium" class="headerlink" title="102. Binary Tree Level Order Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/description/" target="_blank" rel="noopener">102. Binary Tree Level Order Traversal (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">return its level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [9,20],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：热身阶段，先看答案<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        q = [root]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            new_q = []</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> q:</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    new_q.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    new_q.append(node.right)</span><br><span class="line">            ans.append(temp)</span><br><span class="line">            q = new_q</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：看来答案还是很简单的，注意只需要处理 root 为空，记得返回 ans<br>二刷：<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">107. Binary Tree Level Order Traversal II (Easy)</a> 没毛病，注意：list.reverse() 是 in place, 不返回 list 可以 ans.reverse() return ans, 或者啰嗦点的 list(reversed(ans)) 返回 list。用 deque 其实是多余的，因为每个 level 的 q 都直接扔掉（拼出来的下一层的 newQ 取代），可以用 list，for 循环一遍就可以了。</p>
<h3 id="103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium" class="headerlink" title="103. Binary Tree Zigzag Level Order Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/" target="_blank" rel="noopener">103. Binary Tree Zigzag Level Order Traversal (Medium)</a></h3><p><a href="http://www.lintcode.com/en/problem/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">LinC 71. Binary Tree Zigzag Order Traversal</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">return its zigzag level order traversal as:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [20,9],</span><br><span class="line">  [15,7]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>思路：reverse 初始为 0，每层 1 - reverse, reverse == 1 就 reverse<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">zigzagLevelOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        q = [root]</span><br><span class="line">        ans = []</span><br><span class="line">        reverse = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> q:        </span><br><span class="line">            temp = []</span><br><span class="line">            newQ = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> q:</span><br><span class="line">                temp.append(node.val)</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    newQ.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    newQ.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> reverse:</span><br><span class="line">                temp.reverse()</span><br><span class="line">            reverse = <span class="number">1</span> - reverse</span><br><span class="line">            ans.append(temp)</span><br><span class="line">            q = newQ</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：一次过，可做可不做吧</p>
<h3 id="133-Clone-Graph-Medium"><a href="#133-Clone-Graph-Medium" class="headerlink" title="133. Clone Graph (Medium)"></a><a href="https://leetcode.com/problems/clone-graph/description/" target="_blank" rel="noopener">133. Clone Graph (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">OJ's undirected graph serialization:</span><br><span class="line">Nodes are labeled uniquely.</span><br><span class="line"></span><br><span class="line">We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.</span><br><span class="line">As an example, consider the serialized graph &#123;0,1,2#1,2#2,2&#125;.</span><br><span class="line"></span><br><span class="line">The graph has a total of three nodes, and therefore contains three parts as separated by #.</span><br><span class="line"></span><br><span class="line">First node is labeled as 0. Connect node 0 to both nodes 1 and 2.</span><br><span class="line">Second node is labeled as 1. Connect node 1 to node 2.</span><br><span class="line">Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle.</span><br><span class="line">Visually, the graph looks like the following:</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     /   \</span><br><span class="line">    0 --- 2</span><br><span class="line">         / \</span><br><span class="line">         \_/</span><br></pre></td></tr></table></figure>
<p>思路：BFS, 用一个 dict 存当前节点的邻居，如果没见过就加 dict 存 queue，queue 出来建 node，放 neighbor；概念上比较好懂，写码可能有坑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a undirected graph node</span></span><br><span class="line"><span class="comment"># class UndirectedGraphNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.label = x</span></span><br><span class="line"><span class="comment">#         self.neighbors = []</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="comment"># @param node, a undirected graph node</span></span><br><span class="line">    <span class="comment"># @return a undirected graph node</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cloneGraph</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> node == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        _cloneNode = UndirectedGraphNode(node.label)</span><br><span class="line">        dict[node] = _cloneNode</span><br><span class="line">        q = [node]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            new_q = []</span><br><span class="line">            <span class="keyword">for</span> _node <span class="keyword">in</span> q:</span><br><span class="line">                <span class="keyword">for</span> neighbor <span class="keyword">in</span> _node.neighbors:</span><br><span class="line">                    <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                        _cloneNode = UndirectedGraphNode(neighbor.label)</span><br><span class="line">                        dict[neighbor] = _cloneNode</span><br><span class="line">                        new_q.append(neighbor)</span><br><span class="line">                    dict[_node].neighbors.append(dict[neighbor])    </span><br><span class="line">            q = new_q</span><br><span class="line">        <span class="keyword">return</span> dict[node]</span><br></pre></td></tr></table></figure></p>
<p>总结：思路用 dict 来存当前节点的邻居是错的，需要用 dict 存当前节点和克隆节点的映射关系。因为反正映射关系在，加邻居可以后加. 邻居是不能直接 copy 或者 = 的， 因为邻居的类型也是节点， 需要创造以后加进去。测一下，然后 debug 细一点， 要测出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict[_node].neighbors.append(dict[neighbor])</span><br></pre></td></tr></table></figure></p>
<h3 id="127-Word-Ladder-Medium"><a href="#127-Word-Ladder-Medium" class="headerlink" title="127. Word Ladder (Medium)"></a><a href="https://leetcode.com/problems/word-ladder/description/" target="_blank" rel="noopener">127. Word Ladder (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:</span><br><span class="line"></span><br><span class="line">Only one letter can be changed at a time.</span><br><span class="line">Each transformed word must exist in the word list. Note that beginWord is not a transformed word.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Return 0 if there is no such transformation sequence.</span><br><span class="line">All words have the same length.</span><br><span class="line">All words contain only lowercase alphabetic characters.</span><br><span class="line">You may assume no duplicates in the word list.</span><br><span class="line">You may assume beginWord and endWord are non-empty and are not the same.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">beginWord = "hit",</span><br><span class="line">endWord = "cog",</span><br><span class="line">wordList = ["hot","dot","dog","lot","log","cog"]</span><br><span class="line"></span><br><span class="line">Output: 5</span><br><span class="line"></span><br><span class="line">Explanation: As one shortest transformation is "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog",</span><br><span class="line">return its length 5.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">beginWord = "hit"</span><br><span class="line">endWord = "cog"</span><br><span class="line">wordList = ["hot","dot","dog","lot","log"]</span><br><span class="line"></span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.</span><br></pre></td></tr></table></figure>
<p>思路：确实是寻找路径的问题，从 beginWord 到 endWord 是否存在最短路径让他俩相连，最短路径取决于词库里有哪些词（路径）。怎么实现很不清晰<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ladderLength</span><span class="params">(self, beginWord, endWord, wordList)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type beginWord: str</span></span><br><span class="line"><span class="string">        :type endWord: str</span></span><br><span class="line"><span class="string">        :type wordList: List[str]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> beginWord == endWord:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        wordSet = set(wordList)</span><br><span class="line">        q = collections.deque([[beginWord, <span class="number">1</span>]])</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            word, level = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> index <span class="keyword">in</span> range(len(word)):</span><br><span class="line">                <span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>:</span><br><span class="line">                    newWord = word[:index] + char + word[index + <span class="number">1</span>:]</span><br><span class="line">                    <span class="keyword">if</span> newWord <span class="keyword">in</span> wordSet:</span><br><span class="line">                        <span class="keyword">if</span> newWord == endWord:</span><br><span class="line">                            <span class="keyword">return</span> level + <span class="number">1</span></span><br><span class="line">                        wordSet.remove(newWord)</span><br><span class="line">                        q.append([newWord, level + <span class="number">1</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>总结：看了下答案，网上答案解释的比较好理解的是，起始词是树的根节点，每一层是从第一个字母到最后一个字母，每次一个字母，从 a - z 替换过一遍，同时又在 wordList 里的词。从上往下 BFS，找到 endWord 即返回当前 level。啧啧啧，强大的应用题。逻辑对还得不 TLE 需要1.将 wordList 转成 set；2.使用 collections.deque；3.碰到 wordSet 中的词，先该词在 wordSet 中删除，再入 deque</p>
<h3 id="200-Number-of-Islands-Medium"><a href="#200-Number-of-Islands-Medium" class="headerlink" title="200. Number of Islands (Medium)"></a><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">200. Number of Islands (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">11110</span><br><span class="line">11010</span><br><span class="line">11000</span><br><span class="line">00000</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:</span><br><span class="line">11000</span><br><span class="line">11000</span><br><span class="line">00100</span><br><span class="line">00011</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>思路：遍历矩阵，碰到 1 就上下左右 BFS，碰到 0 跳过。BFS 访问过的标 0<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numIslands</span><span class="params">(self, grid)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type grid: List[List[str]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(grid) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> rowI <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">            <span class="keyword">for</span> colI <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> grid[rowI][colI] == <span class="string">"1"</span>:</span><br><span class="line">                    ans += <span class="number">1</span></span><br><span class="line">                    q = collections.deque([[rowI, colI]])</span><br><span class="line">                    grid[rowI][colI] = <span class="string">"0"</span></span><br><span class="line">                    <span class="keyword">while</span> q:</span><br><span class="line">                        row, col = q.popleft()</span><br><span class="line">                        <span class="comment"># up</span></span><br><span class="line">                        <span class="keyword">if</span> (row &gt; <span class="number">0</span>) <span class="keyword">and</span> grid[row - <span class="number">1</span>][col] == <span class="string">"1"</span>:</span><br><span class="line">                                q.append([row - <span class="number">1</span>, col])</span><br><span class="line">                                grid[row - <span class="number">1</span>][col] = <span class="string">'0'</span></span><br><span class="line">                        <span class="comment"># down</span></span><br><span class="line">                        <span class="keyword">if</span> (row &lt; len(grid) - <span class="number">1</span>) <span class="keyword">and</span> grid[row + <span class="number">1</span>][col] == <span class="string">"1"</span>:</span><br><span class="line">                                q.append([row + <span class="number">1</span>, col])</span><br><span class="line">                                grid[row + <span class="number">1</span>][col] = <span class="string">'0'</span></span><br><span class="line">                        <span class="comment"># left</span></span><br><span class="line">                        <span class="keyword">if</span> (col &gt; <span class="number">0</span>) <span class="keyword">and</span> grid[row][col - <span class="number">1</span>] == <span class="string">"1"</span>:</span><br><span class="line">                                q.append([row, col - <span class="number">1</span>])</span><br><span class="line">                                grid[row][col - <span class="number">1</span>] = <span class="string">'0'</span></span><br><span class="line">                        <span class="comment"># right</span></span><br><span class="line">                        <span class="keyword">if</span> (col &lt; len(grid[<span class="number">0</span>]) - <span class="number">1</span>) <span class="keyword">and</span> grid[row][col + <span class="number">1</span>] == <span class="string">"1"</span>:</span><br><span class="line">                                q.append([row, col + <span class="number">1</span>])</span><br><span class="line">                                grid[row][col + <span class="number">1</span>] = <span class="string">'0'</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：对于 leetcode ac 比较重要的细节是，gird[][] = ‘0’ 这句话要在 while 的每个 if 里面，否则逻辑 OK 但是会 TLE</p>
<h3 id="LinC-611-Knight-Shortest-Path-Medium"><a href="#LinC-611-Knight-Shortest-Path-Medium" class="headerlink" title="LinC 611. Knight Shortest Path (Medium)"></a><a href="https://www.lintcode.com/problem/knight-shortest-path/description" target="_blank" rel="noopener">LinC 611. Knight Shortest Path (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Given a knight in a chessboard (a binary matrix with 0 as empty and 1 as barrier) with a source position, find the shortest path to a destination position, return the length of the route.</span><br><span class="line">Return -1 if knight can not reached.</span><br><span class="line"></span><br><span class="line">source and destination must be empty.</span><br><span class="line">Knight can not enter the barrier.</span><br><span class="line"></span><br><span class="line">Clarification</span><br><span class="line">If the knight is at (x, y), he can get to the following positions in one step:</span><br><span class="line"></span><br><span class="line">(x + 1, y + 2)</span><br><span class="line">(x + 1, y - 2)</span><br><span class="line">(x - 1, y + 2)</span><br><span class="line">(x - 1, y - 2)</span><br><span class="line">(x + 2, y + 1)</span><br><span class="line">(x + 2, y - 1)</span><br><span class="line">(x - 2, y + 1)</span><br><span class="line">(x - 2, y - 1)</span><br><span class="line">Example</span><br><span class="line">[[0,0,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">source = [2, 0] destination = [2, 2] return 2</span><br><span class="line"></span><br><span class="line">[[0,1,0],</span><br><span class="line"> [0,0,0],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">source = [2, 0] destination = [2, 2] return 6</span><br><span class="line"></span><br><span class="line">[[0,1,0],</span><br><span class="line"> [0,0,1],</span><br><span class="line"> [0,0,0]]</span><br><span class="line">source = [2, 0] destination = [2, 2] return -1</span><br></pre></td></tr></table></figure>
<p>思路：没什么思路， 看了下答案，就是 BFS 硬来，需要检查走了某个方向以后是不是还是在棋盘内<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition for a point.</span></span><br><span class="line"><span class="string">class Point:</span></span><br><span class="line"><span class="string">    def __init__(self, a=0, b=0):</span></span><br><span class="line"><span class="string">        self.x = a</span></span><br><span class="line"><span class="string">        self.y = b</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param grid: a chessboard included 0 (false) and 1 (true)</span></span><br><span class="line"><span class="string">    @param source: a point</span></span><br><span class="line"><span class="string">    @param destination: a point</span></span><br><span class="line"><span class="string">    @return: the shortest path</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shortestPath</span><span class="params">(self, grid, source, destination)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(grid) == <span class="number">0</span> <span class="keyword">or</span> (len(grid[<span class="number">0</span>]) == <span class="number">1</span> <span class="keyword">and</span> grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        dx = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">-2</span>]</span><br><span class="line">        dy = [<span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>]</span><br><span class="line">        q = collections.deque([source])</span><br><span class="line">        grid[source.x][source.y] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            qlen = len(q)</span><br><span class="line">            next_q = collections.deque()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(qlen):</span><br><span class="line">                pt = q.popleft()</span><br><span class="line">                <span class="keyword">if</span> pt.x == destination.x <span class="keyword">and</span> pt.y == destination.y:</span><br><span class="line">                    <span class="keyword">return</span> ans</span><br><span class="line">                <span class="keyword">for</span> move <span class="keyword">in</span> range(len(dx)):</span><br><span class="line">                    nextPt = Point(pt.x + dx[move], pt.y + dy[move])</span><br><span class="line">                    <span class="keyword">if</span> (self.isInbound(grid, nextPt) <span class="keyword">and</span> grid[nextPt.x][nextPt.y] == <span class="number">0</span>):</span><br><span class="line">                        next_q.append(nextPt)</span><br><span class="line">                        grid[nextPt.x][nextPt.y] = <span class="number">1</span></span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">            q = next_q</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isInbound</span><span class="params">(self, grid, pt)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> pt.x &gt;= <span class="number">0</span> <span class="keyword">and</span> pt.x &lt; len(grid) <span class="keyword">and</span> pt.y &gt;= <span class="number">0</span> <span class="keyword">and</span> pt.y &lt; len(grid[<span class="number">0</span>])</span><br></pre></td></tr></table></figure></p>
<p>总结：注意 isInbound 要查的是 &gt;=0 和 &lt; len()， 其他的问题可以通过跑一个测试数据发现</p>
<h3 id="785-Is-Graph-Bipartite-Medium"><a href="#785-Is-Graph-Bipartite-Medium" class="headerlink" title="785. Is Graph Bipartite? (Medium)"></a><a href="https://leetcode.com/problems/is-graph-bipartite/description/" target="_blank" rel="noopener">785. Is Graph Bipartite? (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Given an undirected graph, return true if and only if it is bipartite.</span><br><span class="line"></span><br><span class="line">Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</span><br><span class="line"></span><br><span class="line">The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">We can divide the vertices into two groups: &#123;0, 2&#125; and &#123;1, 3&#125;.</span><br><span class="line">Example 2:</span><br><span class="line">Input: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation:</span><br><span class="line">The graph looks like this:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">We cannot find a way to divide the set of nodes into two independent subsets.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">graph will have length in range [1, 100].</span><br><span class="line">graph[i] will contain integers in range [0, graph.length - 1].</span><br><span class="line">graph[i] will not contain i or duplicate values.</span><br><span class="line">The graph is undirected: if any element j is in graph[i], then i will be in graph[j].</span><br></pre></td></tr></table></figure>
<p>思路：光理解题目就要花一点时间，现场想几乎是不可能的。用染色的方法，可以用 DFS, BFS 给所有 node 染上两种色中的一种，如果存在相邻的两个 node 能染上同一个颜色，那么就不是 bipartite。具体实现先看答案。看到一个比较好理解的，不知道对不对。 1.初始化 colors 为 -1 的数组，遍历，<strong>如果没有染色</strong>，如果 bfs() 为 False 则 返回 False；2.bfs 内 while q: 如未染色，入 q, 染上 1 - c 的色，如已染色，检查是否是 1 - c 的色<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBipartite</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type graph: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(graph) &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        colors = [<span class="number">-1</span>] * len(graph)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(graph)):</span><br><span class="line">            <span class="keyword">if</span> colors[i] == <span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.bfs(graph, colors, <span class="number">0</span>, i):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(self, graph, colors, color, node)</span>:</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        q.append(node)</span><br><span class="line">        colors[node] = color</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur = q.popleft()</span><br><span class="line">            curColor = colors[cur]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> graph[cur]:</span><br><span class="line">                <span class="keyword">if</span> colors[i] == <span class="number">-1</span>:</span><br><span class="line">                    colors[i] = <span class="number">1</span> - curColor</span><br><span class="line">                    q.append(i)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">if</span> colors[i] != <span class="number">1</span> - curColor:</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：遍历的时候注意需要加如果还未染色这个条件。较变态的题，还有 DFS 的解法，todo 吧</p>
<h3 id="LinC-178-Graph-Valid-Tree-Medium"><a href="#LinC-178-Graph-Valid-Tree-Medium" class="headerlink" title="LinC 178. Graph Valid Tree (Medium)"></a><a href="http://www.lintcode.com/problem/graph-valid-tree/" target="_blank" rel="noopener">LinC 178. Graph Valid Tree (Medium)</a></h3><p>Leetcode 261. Graph Valid Tree 加锁<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given n nodes labeled from 0 to n - 1 and a list of undirected edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.</span><br><span class="line"></span><br><span class="line">You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given n = 5 and edges = [[0, 1], [0, 2], [0, 3], [1, 4]], return true.</span><br><span class="line"></span><br><span class="line">Given n = 5 and edges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]], return false.</span><br></pre></td></tr></table></figure></p>
<p>思路：树的两个条件是不能有环，不能有孤儿节点。怎么实现想不太出来。看了答案，用 defaultdict(list) 放节点之间的关系， 有没有环其实不用管，因为只要确保边的数量 == n - 1, 并且 <strong>BFS</strong> 走过一遍之后访问过了所有的点，就确定没有环了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param n: An integer</span></span><br><span class="line"><span class="string">    @param edges: a list of undirected edges</span></span><br><span class="line"><span class="string">    @return: true if it's a valid tree, or false</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">validTree</span><span class="params">(self, n, edges)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(edges) == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span>        </span><br><span class="line">        <span class="keyword">if</span> len(edges) != n - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mapping = collections.defaultdict(list)</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> edges:</span><br><span class="line">            mapping[edge[<span class="number">0</span>]].append(edge[<span class="number">1</span>])</span><br><span class="line">            mapping[edge[<span class="number">1</span>]].append(edge[<span class="number">0</span>])</span><br><span class="line">        visited = set()</span><br><span class="line">        q = [<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            node = q.pop()</span><br><span class="line">            visited.add(node)</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> mapping[node]:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">                    q.append(neighbor)</span><br><span class="line">                    visited.add(neighbor)</span><br><span class="line">        <span class="keyword">return</span> len(visited) == n</span><br></pre></td></tr></table></figure></p>
<p>总结：相当值得做的一道 BFS 题。注意 已经访问过的节点不要入 q，不然无向图的边会导致死循环</p>
<h2 id="Topological-sorting-拓扑排序"><a href="#Topological-sorting-拓扑排序" class="headerlink" title="Topological sorting 拓扑排序"></a>Topological sorting 拓扑排序</h2><h3 id="LinC-127-Topological-Sorting-Medium"><a href="#LinC-127-Topological-Sorting-Medium" class="headerlink" title="LinC 127. Topological Sorting (Medium)"></a><a href="https://www.lintcode.com/problem/topological-sorting/description" target="_blank" rel="noopener">LinC 127. Topological Sorting (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given an directed graph, a topological order of the graph nodes is defined as follow:</span><br><span class="line"></span><br><span class="line">For each directed edge A -&gt; B in graph, A must before B in the order list.</span><br><span class="line">The first node in the order can be any node in the graph with no nodes direct to it.</span><br><span class="line">Find any topological order for the given graph.</span><br><span class="line"></span><br><span class="line">You can assume that there is at least one topological order in the graph.</span><br><span class="line"></span><br><span class="line">Clarification</span><br><span class="line">[Learn more about representation of graphs](http://www.lintcode.com/help/graph)</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">For graph as follow:</span><br></pre></td></tr></table></figure>
<p><img src="/images/lintcode_127_topo_1.jpeg" alt="graph example"><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The topological order can be:</span><br><span class="line">[0, 1, 2, 3, 4, 5]</span><br><span class="line">[0, 2, 3, 1, 5, 4]</span><br></pre></td></tr></table></figure></p>
<p>思路：拓扑排序，算法貌似是：1.统计每个点的入度；2.将入度为 0 的点入 queue；3.从队列中 pop 点，去掉所有指向别的点的边: 相应点入度 -1；4.新入度为 0 的点入 queue<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition for a Directed graph node</span></span><br><span class="line"><span class="string">class DirectedGraphNode:</span></span><br><span class="line"><span class="string">    def __init__(self, x):</span></span><br><span class="line"><span class="string">        self.label = x</span></span><br><span class="line"><span class="string">        self.neighbors = []</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: graph: A list of Directed graph node</span></span><br><span class="line"><span class="string">    @return: Any topological order for the given graph.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topSort</span><span class="params">(self, graph)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(graph) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        inBound = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> graph:</span><br><span class="line">            <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> inBound:</span><br><span class="line">                inBound[node] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> node.neighbors:</span><br><span class="line">                <span class="keyword">if</span> neighbor <span class="keyword">not</span> <span class="keyword">in</span> inBound:</span><br><span class="line">                    inBound[neighbor] = <span class="number">0</span></span><br><span class="line">                inBound[neighbor] += <span class="number">1</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> inBound:</span><br><span class="line">            <span class="keyword">if</span> inBound[node] == <span class="number">0</span>:</span><br><span class="line">                q.append(node)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            zNode = q.popleft()</span><br><span class="line">            ans.append(zNode)</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> zNode.neighbors:</span><br><span class="line">                inBound[node] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inBound[node] == <span class="number">0</span>:</span><br><span class="line">                    q.append(node)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">```            </span><br><span class="line">总结：顺利。但是题目没有说清楚 <span class="keyword">return</span> 的是一个拓扑排序好的 node 的 list</span><br><span class="line"></span><br><span class="line"><span class="comment">### [207. Course Schedule (Medium)](https://leetcode.com/problems/course-schedule/description/)</span></span><br><span class="line">```html</span><br><span class="line">There are a total of n courses you have to take, labeled <span class="keyword">from</span> <span class="number">0</span> to n<span class="number">-1.</span></span><br><span class="line"></span><br><span class="line">Some courses may have prerequisites, <span class="keyword">for</span> example to take course <span class="number">0</span> you have to first take course <span class="number">1</span>, which <span class="keyword">is</span> expressed <span class="keyword">as</span> a pair: [<span class="number">0</span>,<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</span><br><span class="line"></span><br><span class="line">Example <span class="number">1</span>:</span><br><span class="line"></span><br><span class="line">Input: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: There are a total of <span class="number">2</span> courses to take.</span><br><span class="line">             To take course <span class="number">1</span> you should have finished course <span class="number">0.</span> So it <span class="keyword">is</span> possible.</span><br><span class="line">Example <span class="number">2</span>:</span><br><span class="line"></span><br><span class="line">Input: <span class="number">2</span>, [[<span class="number">1</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">1</span>]]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: There are a total of <span class="number">2</span> courses to take.</span><br><span class="line">             To take course <span class="number">1</span> you should have finished course <span class="number">0</span>, <span class="keyword">and</span> to take course <span class="number">0</span> you should</span><br><span class="line">             also have finished course <span class="number">1.</span> So it <span class="keyword">is</span> impossible.</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The input prerequisites <span class="keyword">is</span> a graph represented by a list of edges, <span class="keyword">not</span> adjacency matrices. Read more about how a graph <span class="keyword">is</span> represented.</span><br><span class="line">You may assume that there are no duplicate edges <span class="keyword">in</span> the input prerequisites.</span><br></pre></td></tr></table></figure></p>
<p>思路：其实是问拓扑顺序存不存在，具体实现得看答案<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canFinish</span><span class="params">(self, numCourses, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prerequisites) == <span class="number">0</span> <span class="keyword">or</span> len(prerequisites[<span class="number">0</span>]) == <span class="number">0</span> <span class="keyword">or</span> len(prerequisites[<span class="number">0</span>]) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        graph = &#123;&#125;</span><br><span class="line">        inBound = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> prereqs <span class="keyword">in</span> prerequisites:</span><br><span class="line">            <span class="keyword">for</span> index, course <span class="keyword">in</span> enumerate(prereqs):</span><br><span class="line">                <span class="keyword">if</span> course <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">                    graph[course] = []</span><br><span class="line">                <span class="keyword">if</span> course <span class="keyword">not</span> <span class="keyword">in</span> inBound:</span><br><span class="line">                    inBound[course] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> index &lt; len(prereqs) - <span class="number">1</span>:</span><br><span class="line">                    graph[course].append(prereqs[index + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                    inBound[course] += <span class="number">1</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> inBound:</span><br><span class="line">            <span class="keyword">if</span> inBound[key] == <span class="number">0</span>:</span><br><span class="line">                q.append(key)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            course = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[course]:</span><br><span class="line">                inBound[neighbor] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inBound[neighbor] == <span class="number">0</span>:</span><br><span class="line">                    q.append(neighbor)</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> inBound:</span><br><span class="line">            <span class="keyword">if</span> inBound[key] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：有向图有环则拓扑顺序不存在，题可以变为如何检测有向图有环的问题。算法的核心是计算所有节点的入度，然后做类似上题的 BFS，每遍历一次邻居，入度减一，如果遍历完以后还有点的入度 &gt; 0，则图有环。具体实现两个 dict，一个存节点和邻居们， 一个存节点和入度， 再加个 queue; 注意下 prerequisites 是个 list of list 别的没什么</p>
<h3 id="210-Course-Schedule-II-Medium"><a href="#210-Course-Schedule-II-Medium" class="headerlink" title="210. Course Schedule II (Medium)"></a><a href="https://leetcode.com/problems/course-schedule-ii/description/" target="_blank" rel="noopener">210. Course Schedule II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">There are a total of n courses you have to take, labeled from 0 to n-1.</span><br><span class="line"></span><br><span class="line">Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]</span><br><span class="line"></span><br><span class="line">Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.</span><br><span class="line"></span><br><span class="line">There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: 2, [[1,0]]</span><br><span class="line">Output: [0,1]</span><br><span class="line">Explanation: There are a total of 2 courses to take. To take course 1 you should have finished   </span><br><span class="line">             course 0. So the correct course order is [0,1] .</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: 4, [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">Output: [0,1,2,3] or [0,2,1,3]</span><br><span class="line">Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both     </span><br><span class="line">             courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.</span><br><span class="line">             So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.</span><br><span class="line">You may assume that there are no duplicate edges in the input prerequisites.</span><br></pre></td></tr></table></figure>
<p>思路：是前两道题的延伸，既要计算所有节点的入度， BFS，又要做拓扑排序，记下拓扑的顺序。 如果结束时还有入度 &gt; 0 的节点，则图有环，无解<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findOrder</span><span class="params">(self, numCourses, prerequisites)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type numCourses: int</span></span><br><span class="line"><span class="string">        :type prerequisites: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> len(prerequisites) == <span class="number">0</span> <span class="keyword">or</span> len(prerequisites[<span class="number">0</span>]) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">                ans.append(i)</span><br><span class="line">            <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br><span class="line">        graph = &#123;&#125;</span><br><span class="line">        inBound = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> prereqs <span class="keyword">in</span> prerequisites:</span><br><span class="line">            <span class="keyword">for</span> index, course <span class="keyword">in</span> enumerate(prereqs):</span><br><span class="line">                <span class="keyword">if</span> course <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">                    graph[course] = []</span><br><span class="line">                <span class="keyword">if</span> course <span class="keyword">not</span> <span class="keyword">in</span> inBound:</span><br><span class="line">                    inBound[course] = <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> index &lt; len(prereqs) - <span class="number">1</span>:</span><br><span class="line">                    graph[course].append(prereqs[index + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">if</span> index &gt; <span class="number">0</span>:</span><br><span class="line">                    inBound[course] += <span class="number">1</span></span><br><span class="line">        q = collections.deque()</span><br><span class="line">        <span class="keyword">for</span> course <span class="keyword">in</span> inBound:</span><br><span class="line">            <span class="keyword">if</span> inBound[course] == <span class="number">0</span>:</span><br><span class="line">                ans.append(course)</span><br><span class="line">                q.append(course)</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            course = q.popleft()</span><br><span class="line">            <span class="keyword">for</span> neighbor <span class="keyword">in</span> graph[course]:</span><br><span class="line">                inBound[neighbor] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> inBound[neighbor] == <span class="number">0</span>:</span><br><span class="line">                    ans.append(neighbor)</span><br><span class="line">                    q.append(neighbor)</span><br><span class="line">        <span class="keyword">for</span> course <span class="keyword">in</span> inBound:</span><br><span class="line">            <span class="keyword">if</span> inBound[course] &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(numCourses):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> inBound:</span><br><span class="line">                ans.append(i)</span><br><span class="line">        <span class="keyword">return</span> ans[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：值得做的题的边缘，要满足些很琐碎的细节才能 AC，和 Course Schedule 题不同点在于这题需要用 numCourses。如果有些节点在 prerequisites 里不出现的话，需要在答案里加进去</p>
<h3 id="LinC-605-Sequence-Reconstruction-Medium"><a href="#LinC-605-Sequence-Reconstruction-Medium" class="headerlink" title="LinC 605. Sequence Reconstruction (Medium)"></a><a href="https://www.lintcode.com/problem/sequence-reconstruction/description" target="_blank" rel="noopener">LinC 605. Sequence Reconstruction (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Check whether the original sequence org can be uniquely reconstructed from the sequences in seqs. The org sequence is a permutation of the integers from 1 to n, with 1 ≤ n ≤ 10^4. Reconstruction means building a shortest common supersequence of the sequences in seqs (i.e., a shortest sequence so that all sequences in seqs are subsequences of it). Determine whether there is only one sequence that can be reconstructed from seqs and it is the org sequence.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given org = [1,2,3], seqs = [[1,2],[1,3]]</span><br><span class="line">Return false</span><br><span class="line">Explanation:</span><br><span class="line">[1,2,3] is not the only one sequence that can be reconstructed, because [1,3,2] is also a valid sequence that can be reconstructed.</span><br><span class="line"></span><br><span class="line">Given org = [1,2,3], seqs = [[1,2]]</span><br><span class="line">Return false</span><br><span class="line">Explanation:</span><br><span class="line">The reconstructed sequence can only be [1,2].</span><br><span class="line"></span><br><span class="line">Given org = [1,2,3], seqs = [[1,2],[1,3],[2,3]]</span><br><span class="line">Return true</span><br><span class="line">Explanation:</span><br><span class="line">The sequences [1,2], [1,3], and [2,3] can uniquely reconstruct the original sequence [1,2,3].</span><br><span class="line"></span><br><span class="line">Given org = [4,1,5,2,6,3], seqs = [[5,2,6,3],[4,1,5,2]]</span><br><span class="line">Return true</span><br></pre></td></tr></table></figure>
<p>思路：没什么思路，被考点吸引，如何构建图，如何拓扑排序.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param org: a permutation of the integers from 1 to n</span></span><br><span class="line"><span class="string">    @param seqs: a list of sequences</span></span><br><span class="line"><span class="string">    @return: true if it can be reconstructed only one or false</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sequenceReconstruction</span><span class="params">(self, org, seqs)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(seqs) == <span class="number">0</span> <span class="keyword">and</span> len(org) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> len(seqs) == <span class="number">0</span> <span class="keyword">and</span> len(org) != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(seqs) != <span class="number">0</span> <span class="keyword">and</span> len(org) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        graph = &#123;&#125;</span><br><span class="line">        indegree = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> seq <span class="keyword">in</span> seqs:</span><br><span class="line">            <span class="keyword">if</span> len(seq) &gt; len(org):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> seq:</span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span> graph:</span><br><span class="line">                    graph[val] = []</span><br><span class="line">                <span class="keyword">if</span> val <span class="keyword">not</span> <span class="keyword">in</span></span><br></pre></td></tr></table></figure></p>
<p>总结：看了网上答案，记录入度，记录邻居，拓扑排序拓扑排序出来要有唯一解（q 每次长度都是 1）和 org 的相应位置的值要相等结束才能返回 True。写了一半实在是不想写了。 回头在写吧。todo item</p>
<h1 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS 深度优先搜索"></a>DFS 深度优先搜索</h1><h2 id="Binary-Tree-amp-Tree-based-DFS-二叉树与树上的深度优先搜索"><a href="#Binary-Tree-amp-Tree-based-DFS-二叉树与树上的深度优先搜索" class="headerlink" title="Binary Tree &amp; Tree-based DFS 二叉树与树上的深度优先搜索"></a>Binary Tree &amp; Tree-based DFS 二叉树与树上的深度优先搜索</h2><h3 id="104-Maximum-Depth-of-Binary-Tree-Easy"><a href="#104-Maximum-Depth-of-Binary-Tree-Easy" class="headerlink" title="104. Maximum Depth of Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, find its maximum depth.</span><br><span class="line"></span><br><span class="line">The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Given binary tree [3,9,20,null,null,15,7],</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">return its depth = 3.</span><br></pre></td></tr></table></figure>
<p>思路：先热身，递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Divide and Conquer 分治</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        left = self.maxDepth(root.left)</span><br><span class="line">        right = self.maxDepth(root.right)</span><br><span class="line">        <span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Traverse 遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = <span class="number">0</span></span><br><span class="line">        self.helper(root, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, curDepth)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.ans = max(self.ans, curDepth)</span><br><span class="line">        self.helper(root.left, curDepth + <span class="number">1</span>)</span><br><span class="line">        self.helper(root.right, curDepth + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：热身:), 非递归据说需要 postorder traversal (Hard)<br>二刷：一刷的递归用的是分治， 当时没看出来而已, 加了遍历方法。</p>
<h3 id="226-Invert-Binary-Tree-Easy"><a href="#226-Invert-Binary-Tree-Easy" class="headerlink" title="226. Invert Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/invert-binary-tree/description/" target="_blank" rel="noopener">226. Invert Binary Tree (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Invert a binary tree.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">Output:</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br><span class="line">Trivia:</span><br><span class="line">This problem was inspired by this original tweet by Max Howell:</span><br><span class="line">Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off.</span><br></pre></td></tr></table></figure>
<p>思路：咋一看略懵逼，看了下三年前的答案，两层循环。。。<br>二刷：还有递归的 DFS 写法。非递归更像 BFS<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        processQ = []</span><br><span class="line">        processQ.append(root)</span><br><span class="line">        <span class="keyword">while</span> processQ:</span><br><span class="line">            nextLevel = []</span><br><span class="line">            <span class="keyword">for</span> node <span class="keyword">in</span> processQ:</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nextLevel.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nextLevel.append(node.right)</span><br><span class="line">                node.left, node.right = node.right, node.left</span><br><span class="line">            processQ = nextLevel</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"><span class="comment"># DFS 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">invertTree</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        self.dfs(root)</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.dfs(root.left)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.dfs(root.right)</span><br></pre></td></tr></table></figure></p>
<p>总结：三年前还是挺牛逼的。。。二刷加了 DFS 递归写法。</p>
<h3 id="701-Insert-into-a-Binary-Search-Tree-Medium"><a href="#701-Insert-into-a-Binary-Search-Tree-Medium" class="headerlink" title="701. Insert into a Binary Search Tree (Medium)"></a><a href="https://leetcode.com/problems/insert-into-a-binary-search-tree/description/" target="_blank" rel="noopener">701. Insert into a Binary Search Tree (Medium)</a></h3><p><a href="http://www.lintcode.com/problem/insert-node-in-a-binary-search-tree/" target="_blank" rel="noopener">LinC Insert Node in a Binary Search Tree</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.</span><br><span class="line"></span><br><span class="line">Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.</span><br><span class="line"></span><br><span class="line">For example,</span><br><span class="line"></span><br><span class="line">Given the tree:</span><br><span class="line">        4</span><br><span class="line">       / \</span><br><span class="line">      2   7</span><br><span class="line">     / \</span><br><span class="line">    1   3</span><br><span class="line">And the value to insert: 5</span><br><span class="line">You can return this binary search tree:</span><br><span class="line"></span><br><span class="line">         4</span><br><span class="line">       /   \</span><br><span class="line">      2     7</span><br><span class="line">     / \   /</span><br><span class="line">    1   3 5</span><br><span class="line">This tree is also valid:</span><br><span class="line"></span><br><span class="line">         5</span><br><span class="line">       /   \</span><br><span class="line">      2     7</span><br><span class="line">     / \   </span><br><span class="line">    1   3</span><br><span class="line">         \</span><br><span class="line">          4</span><br></pre></td></tr></table></figure></p>
<p>思路：没什么思路，看答案好像就是根据 BST 的性质二分查找下去，这跟二分查找没关系啊。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span><span class="params">(self, root, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        node = TreeNode(val)</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> cur.val != node.val:</span><br><span class="line">            <span class="keyword">if</span> cur.val &lt; node.val:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.right:</span><br><span class="line">                    cur.right = node</span><br><span class="line">                cur = cur.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> cur.left:</span><br><span class="line">                    cur.left = node</span><br><span class="line">                cur = cur.left</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>总结：不懂为什么 Leetcode 要标 medium 难度。我把这题放热身区</p>
<h3 id="257-Binary-Tree-Paths-Easy"><a href="#257-Binary-Tree-Paths-Easy" class="headerlink" title="257. Binary Tree Paths (Easy)"></a><a href="https://leetcode.com/problems/binary-tree-paths/description/" target="_blank" rel="noopener">257. Binary Tree Paths (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return all root-to-leaf paths.</span><br><span class="line"></span><br><span class="line">Note: A leaf is a node with no children.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line"></span><br><span class="line">   1</span><br><span class="line"> /   \</span><br><span class="line">2     3</span><br><span class="line"> \</span><br><span class="line">  5</span><br><span class="line"></span><br><span class="line">Output: ["1-&gt;2-&gt;5", "1-&gt;3"]</span><br><span class="line"></span><br><span class="line">Explanation: All root-to-leaf paths are: 1-&gt;2-&gt;5, 1-&gt;3</span><br></pre></td></tr></table></figure>
<p>思路：既然是 DFS 环节，看着就是 DFS 的解法。实现应该有坑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        self.helper(root, <span class="string">''</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, path, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>:</span><br><span class="line">            ans.append(path + str(root.val))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> root.left != <span class="keyword">None</span>:</span><br><span class="line">            self.helper(root.left, path + str(root.val) + <span class="string">'-&gt;'</span>, ans)</span><br><span class="line">        <span class="keyword">if</span> root.right != <span class="keyword">None</span>:</span><br><span class="line">            self.helper(root.right, path + str(root.val) + <span class="string">'-&gt;'</span>, ans)</span><br></pre></td></tr></table></figure></p>
<p>总结：递归的模板需要记，需要 path， 总答案 ans，每次进入递归函数时：1.如果已经到底，将 path append 上 root.val 并加入到 ans；2.如有左边递归左边，如有右边递归右边。注意 python + string 要先把 int 变成 str</p>
<h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium" class="headerlink" title="236. Lowest Common Ancestor of a Binary Tree (Medium)"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/" target="_blank" rel="noopener">236. Lowest Common Ancestor of a Binary Tree (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</span><br><span class="line"></span><br><span class="line">According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”</span><br><span class="line"></span><br><span class="line">Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]</span><br><span class="line"></span><br><span class="line">        _______3______</span><br><span class="line">       /              \</span><br><span class="line">    ___5__          ___1__</span><br><span class="line">   /      \        /      \</span><br><span class="line">   6      _2       0       8</span><br><span class="line">         /  \</span><br><span class="line">         7   4</span><br><span class="line">Example 1:</span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The LCA of of nodes 5 and 1 is 3.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself</span><br><span class="line">             according to the LCA definition.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">All of the nodes' values will be unique.</span><br><span class="line">p and q are different and both values will exist in the binary tree.</span><br></pre></td></tr></table></figure>
<p>思路：很久没刷过题了，这题第一感觉是 DFS 回溯，但是没有多的灵感。看答案。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span> <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        l = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        r = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">if</span> (l == p <span class="keyword">and</span> r == q) <span class="keyword">or</span> (l == q <span class="keyword">and</span> r == p):</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> l != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> l</span><br><span class="line">        <span class="keyword">if</span> r != <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> r</span><br></pre></td></tr></table></figure></p>
<p>总结：答案的算法是 DFS，从叶子节点向上，如果子树中有目标节点，返回目标节点。否则为 None。如果左右子树都有目标节点，则找到 LCA，如果在 p 为跟节点的子树中有 q，则 p 为 LCA 反之亦然。最后为子树返回目标节点非常 tricky，必须要用 l != None。 直觉上更好理解的 l == p or l == q 过不了， 不知道为什么。 已经在<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/162142/Can&#39;t-tell-the-difference-between-two-versions-of-my-code-one-ac-one-fail" target="_blank" rel="noopener">讨论区问了</a></p>
<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy" class="headerlink" title="235. Lowest Common Ancestor of a Binary Search Tree (Easy)"></a><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/" target="_blank" rel="noopener">235. Lowest Common Ancestor of a Binary Search Tree (Easy)</a></h3><p>思路：跟上题一样，除了多一个 BST 树的条件， 将题变成了一个二分查找的题<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span><span class="params">(self, root, p, q)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type p: TreeNode</span></span><br><span class="line"><span class="string">        :type q: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span> <span class="keyword">or</span> root == p <span class="keyword">or</span> root == q:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; p.val <span class="keyword">and</span> root.val &gt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        <span class="keyword">elif</span> root.val &lt; p.val <span class="keyword">and</span> root.val &lt; q.val:</span><br><span class="line">            <span class="keyword">return</span> self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure></p>
<p>总结：稍微看一下就行。 不值得刷的题。</p>
<h3 id="144-Binary-Tree-Preorder-Traversal-Medium"><a href="#144-Binary-Tree-Preorder-Traversal-Medium" class="headerlink" title="144. Binary Tree Preorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/description/" target="_blank" rel="noopener">144. Binary Tree Preorder Traversal (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return the preorder traversal of its nodes' values.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,2,3]</span><br><span class="line">Follow up: Recursive solution is trivial, could you do it iteratively?</span><br></pre></td></tr></table></figure>
<p>思路：递归写熟了确实是简单。<br>二刷：看了下 traverse 背后的逻辑，“拿着一个记事本, 顺着二叉树走, 走过一个, 在本子上面记下来”<br><img src="/images/leetode_144_bina_1.jpeg" alt="preorder-traverse-logic-image"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归 Traverse</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        self.helper(root, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        self.helper(root.left, ans)</span><br><span class="line">        self.helper(root.right, ans)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span>   </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>             </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(root)</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            n = stack.pop()</span><br><span class="line">            ans.append(n.val)</span><br><span class="line">            <span class="keyword">if</span> n.right:</span><br><span class="line">                stack.append(n.right)</span><br><span class="line">            <span class="keyword">if</span> n.left:</span><br><span class="line">                stack.append(n.left)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># Divide and Conquer 分治</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span><span class="params">(self, root)</span>:</span>   </span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>    </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        left = self.preorderTraversal(root.left)</span><br><span class="line">        right = self.preorderTraversal(root.right)</span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        ans.extend(left)</span><br><span class="line">        ans.extend(right)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：非递归要记住 pop，push right， push left 这个算法。就可以写对.<br>二刷：因为栈是先进后出，所以先 push right。分治的代码里要用 extend 来把 list 填充到另一个 list 里。</p>
<h3 id="94-Binary-Tree-Inorder-Traversal-Medium"><a href="#94-Binary-Tree-Inorder-Traversal-Medium" class="headerlink" title="94. Binary Tree Inorder Traversal (Medium)"></a><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/" target="_blank" rel="noopener">94. Binary Tree Inorder Traversal (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, return the inorder traversal of its nodes' values.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,null,2,3]</span><br><span class="line">   1</span><br><span class="line">    \</span><br><span class="line">     2</span><br><span class="line">    /</span><br><span class="line">   3</span><br><span class="line"></span><br><span class="line">Output: [1,3,2]</span><br><span class="line">Follow up: Recursive solution is trivial, could you do it iteratively?</span><br></pre></td></tr></table></figure>
<p>思路：递归和用栈各写一遍<br>二刷：递归如果不想用 instance variable，就将 ans 传到 helper 里去。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二刷递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>   </span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        self.helper(root, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.helper(root.left, ans)</span><br><span class="line">        ans.append(root.val)</span><br><span class="line">        self.helper(root.right, ans)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归 / stack</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: List[int]</span></span><br><span class="line"><span class="string">        """</span>   </span><br><span class="line">        stack = []</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> ans</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            ans.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">                <span class="keyword">while</span> node:</span><br><span class="line">                    stack.append(node)</span><br><span class="line">                    node = node.left</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：递归好理解的方法需要用一个全局变量， 目前还没有想到不用 class 变量的方法。非递归 / stack 需要记住套路：<strong>1.从 root 往左全入栈；2. pop 栈，ans.append(node.val)；3.有右子节点的话走到右子节点，将右子节点及所有左子节点全入栈</strong><br>二刷：不用 class 变量就把 ans 传入 helper / dfs 函数, 把一刷的递归去掉了，看题的时候方便点。</p>
<h3 id="LinC-448-Inorder-Successor-in-BST-Medium"><a href="#LinC-448-Inorder-Successor-in-BST-Medium" class="headerlink" title="LinC 448. Inorder Successor in BST (Medium)"></a><a href="http://www.lintcode.com/problem/inorder-successor-in-binary-search-tree/" target="_blank" rel="noopener">LinC 448. Inorder Successor in BST (Medium)</a></h3><p>Leetcode 285. Inorder Successor in BST 带锁<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Given a binary search tree and a node in it, find the in-order successor of that node in the BST.</span><br><span class="line"></span><br><span class="line">If the given node has no in-order successor in the tree, return null.</span><br><span class="line"></span><br><span class="line">It's guaranteed p is one node in the given tree. (You can directly compare the memory address to find p)</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given tree = [2,1] and node = 1:</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> /</span><br><span class="line">1</span><br><span class="line">return node 2.</span><br><span class="line"></span><br><span class="line">Given tree = [2,1,3] and node = 2:</span><br><span class="line"></span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br><span class="line">return node 3.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">O(h), where h is the height of the BST.</span><br></pre></td></tr></table></figure></p>
<p>思路：DFS 找这个 node， 返回这个 node inorder 的下一个 node<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition for a binary tree node.</span></span><br><span class="line"><span class="string">class TreeNode(object):</span></span><br><span class="line"><span class="string">    def __init__(self, x):</span></span><br><span class="line"><span class="string">        self.val = x</span></span><br><span class="line"><span class="string">        self.left = None</span></span><br><span class="line"><span class="string">        self.right = None</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: root: The root of the BST.</span></span><br><span class="line"><span class="string">    @param: p: You need find the successor node of p.</span></span><br><span class="line"><span class="string">    @return: Successor of p.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderSuccessor</span><span class="params">(self, root, p)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        found = <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            n = stack.pop()</span><br><span class="line">            <span class="keyword">if</span> found:</span><br><span class="line">                <span class="keyword">return</span> n</span><br><span class="line">            <span class="keyword">if</span> n.val == p.val:</span><br><span class="line">                found = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> n.right:</span><br><span class="line">                n = n.right</span><br><span class="line">                <span class="keyword">while</span> n:</span><br><span class="line">                    stack.append(n)</span><br><span class="line">                    n = n.left</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>总结：递归怎么都写不对， 先抄一个非递归能理解的。 todo 二刷的时候刷个能理解的递归 DFS 方法。</p>
<h3 id="98-Validate-Binary-Search-Tree-Medium"><a href="#98-Validate-Binary-Search-Tree-Medium" class="headerlink" title="98. Validate Binary Search Tree (Medium)"></a><a href="https://leetcode.com/problems/validate-binary-search-tree/description/" target="_blank" rel="noopener">98. Validate Binary Search Tree (Medium)</a><a id="leetcode-98"></a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, determine if it is a valid binary search tree (BST).</span><br><span class="line"></span><br><span class="line">Assume a BST is defined as follows:</span><br><span class="line"></span><br><span class="line">The left subtree of a node contains only nodes with keys less than the node's key.</span><br><span class="line">The right subtree of a node contains only nodes with keys greater than the node's key.</span><br><span class="line">Both the left and right subtrees must also be binary search trees.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">Output: false</span><br><span class="line">Explanation: The input is: [5,1,4,null,null,3,6]. The root node's value</span><br><span class="line">             is 5 but its right child's value is 4.</span><br></pre></td></tr></table></figure>
<p>思路：感觉是二叉树 DFS 加两个判断，如果左边不比 root 小就 false，如果右边不比 root 大就 false，遍历结束返回 true<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 九章的 inorder traversal 写法。虽然有点流氓但是优雅。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span> <span class="keyword">or</span> (root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        self.lastVal = <span class="keyword">None</span></span><br><span class="line">        self.ans = <span class="keyword">True</span></span><br><span class="line">        self.inOrder(root)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inOrder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span> <span class="keyword">or</span> self.ans == <span class="keyword">False</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.inOrder(root.left)</span><br><span class="line">        <span class="keyword">if</span> self.lastVal != <span class="keyword">None</span> <span class="keyword">and</span> self.lastVal &gt;= root.val:</span><br><span class="line">            self.ans = <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.lastVal = root.val</span><br><span class="line">        self.inOrder(root.right)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Divide and conquer 分治</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span> <span class="keyword">or</span> (root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root, -sys.maxsize, sys.maxsize)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, minVal, maxVal)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= minVal <span class="keyword">or</span> root.val &gt;= maxVal:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root.left, minVal, min(root.val, maxVal)) <span class="keyword">and</span> self.helper(root.right, max(root.val, minVal), maxVal)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归 / DFS 方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span> <span class="keyword">or</span> (root.left == <span class="keyword">None</span> <span class="keyword">and</span> root.right == <span class="keyword">None</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        lastN = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            n = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> lastN <span class="keyword">and</span> lastN.val &gt;= n.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            lastN = n</span><br><span class="line">            <span class="keyword">if</span> n.right:</span><br><span class="line">                n = n.right</span><br><span class="line">                <span class="keyword">while</span> n:</span><br><span class="line">                    stack.append(n)</span><br><span class="line">                    n = n.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                n = stack.pop()</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> stack[<span class="number">-1</span>].right == n:</span><br><span class="line">                    n = stack.pop()</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：看答案大多是 Divide and Conquer，一次用递归写不对，因为没有考虑子树里 valid 但是放到上面一级不 valid 的情况，比如这棵树：[10,5,15,null,null,6,20]。<br>九章的 python 答案用了一个 class variable 记 last val 然后 inorder traversal 中序遍历这样只要 last val &gt;= root.val 就不是 valid BST，好流氓，但是好喜欢，撸之。测一下那个子树 valid 但是上面一级不 valid 的数就能写对。<br>正确的 Divide and Conquer / 分治方法是将当前 root 允许的 max 和 min 值传下去；注意：1.分治最后一句 minVal 和 maxVal 的传法是 return f(root.left, minVal, min(root.val, maxVal)) and f(root.right, max(root.val, minVal), maxVal) 思考方法为，如果从 最上面的 root 下来，传下来的是 -max 和 max，如何处理，就能写对；2.min max 是函数名，变量名要用 minVal maxVal<br>DFS 的解法最后一部分非常关键：1.如果有 lastN and lastN.val &gt;= n.val: return False, lastN = n; 2.if n.right: DFS 套路，往右走一个然后往左到底 3. else: n = stack.pop() <strong>while stack and stack[-1].right == n: n = stack.pop()</strong> 这部分没办法，todo 反复写 :(。</p>
<h3 id="230-Kth-Smallest-Element-in-a-BST-Medium"><a href="#230-Kth-Smallest-Element-in-a-BST-Medium" class="headerlink" title="230. Kth Smallest Element in a BST (Medium)"></a><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/" target="_blank" rel="noopener">230. Kth Smallest Element in a BST (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">You may assume k is always valid, 1 ≤ k ≤ BST's total elements.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: root = [3,1,4,null,2], k = 1</span><br><span class="line">   3</span><br><span class="line">  / \</span><br><span class="line"> 1   4</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">     3   6</span><br><span class="line">    / \</span><br><span class="line">   2   4</span><br><span class="line">  /</span><br><span class="line"> 1</span><br><span class="line">Output: 3</span><br><span class="line">Follow up:</span><br><span class="line">What if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?</span><br></pre></td></tr></table></figure>
<p>思路：第一感觉是一直往下，找到最小，然后利用 BST 左边比 root 小，root 不大于右边的特性找到 K。 具体怎么实现得看答案。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次写能 ac 的土递归办法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    ans = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.helper(root, k)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.helper(root.left, k)</span><br><span class="line">        self.cnt += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.cnt == k:</span><br><span class="line">            self.ans = root.val</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.helper(root.right, k)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非递归 / 栈</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthSmallest</span><span class="params">(self, root, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cnt == k:</span><br><span class="line">                <span class="keyword">return</span> node.val</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">                <span class="keyword">while</span> node:</span><br><span class="line">                    stack.append(node)</span><br><span class="line">                    node = node.left</span><br></pre></td></tr></table></figure></p>
<p>总结：答案基本就是中序遍历，统计当前遍历的步数，到 k 返回。递归算法还是需要全局变量:(。非递归 / 栈算法用上题的套路加一个 counter 就很容易写对。 Follow up: 二叉树经常被修改 如何优化 kthSmallest 这个操作? 在 TreeNode 中增加一个 counter，代表整个树的节点个数，也可以用一个 HashMap&lt;TreeNode, Integer&gt; 来存储某个节点为代表的子树的节点个数。在增删查改的过程中记录不断更新受影响节点的 counter， 在 kthSmallest 的实现中用类似 Quick Select 的算法去找到 kth smallest element 时间复杂度为 O(h)，h 为树的高度。</p>
<h3 id="173-Binary-Search-Tree-Iterator-Medium"><a href="#173-Binary-Search-Tree-Iterator-Medium" class="headerlink" title="173. Binary Search Tree Iterator (Medium)"></a><a href="https://leetcode.com/problems/binary-search-tree-iterator/description/" target="_blank" rel="noopener">173. Binary Search Tree Iterator (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.</span><br><span class="line"></span><br><span class="line">Calling next() will return the next smallest number in the BST.</span><br><span class="line"></span><br><span class="line">Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.</span><br></pre></td></tr></table></figure>
<p>思路：看了代码 “Your BSTIterator will be called like this” 后感觉这个 iterator 需要存一个中序遍历的队列, next() 就 popleft，hasNext() 就返回该队列是否为空。use O(h) 内存暂时不知道怎么实现<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a  binary tree node</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span><span class="params">(object)</span>:</span></span><br><span class="line">    q = collections.deque()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            stack.append(root)</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            self.q.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                node = node.right</span><br><span class="line">                <span class="keyword">while</span> node:</span><br><span class="line">                    stack.append(node)</span><br><span class="line">                    node = node.left</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> len(self.q) &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.q.popleft()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your BSTIterator will be called like this:</span></span><br><span class="line"><span class="comment"># i, v = BSTIterator(root), []</span></span><br><span class="line"><span class="comment"># while i.hasNext(): v.append(i.next())</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意全局变量（和 class method）前面加 self.，别的没什么，想好了比较好写的题</p>
<h3 id="LinC-900-Closest-Binary-Search-Tree-Value-Easy"><a href="#LinC-900-Closest-Binary-Search-Tree-Value-Easy" class="headerlink" title="LinC 900. Closest Binary Search Tree Value (Easy)"></a><a href="https://www.lintcode.com/problem/closest-binary-search-tree-value/description" target="_blank" rel="noopener">LinC 900. Closest Binary Search Tree Value (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a non-empty binary search tree and a target value, find the value in the BST that is closest to the target.</span><br><span class="line"></span><br><span class="line">Given target value is a floating point.</span><br><span class="line">You are guaranteed to have only one unique value in the BST that is closest to the target.</span><br><span class="line">Example</span><br><span class="line">Given root = &#123;1&#125;, target = 4.428571, return 1.</span><br></pre></td></tr></table></figure>
<p>思路：如果中序遍历的话是从小到大，这题要找离 target 最近的点，中序遍历以后可以用二分查找直接找到那个点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param root: the given BST</span></span><br><span class="line"><span class="string">    @param target: the given target</span></span><br><span class="line"><span class="string">    @return: the value in the BST that is closest to the target</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 最直观</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestValue</span><span class="params">(self, root, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        ans = root.val</span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> abs(root.val - target) &lt; abs(ans - target):</span><br><span class="line">                ans = root.val</span><br><span class="line">            <span class="keyword">if</span> root.val &lt; target:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 递归回溯</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">closestValue</span><span class="params">(self, root, target)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        tempA = root.val</span><br><span class="line">        <span class="keyword">if</span> tempA &lt; target:</span><br><span class="line">            root = root.right</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            root = root.left</span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span> tempA</span><br><span class="line">        tempB = self.closestValue(root, target)</span><br><span class="line">        <span class="keyword">if</span> abs(tempA - target) &lt; abs(tempB - target):</span><br><span class="line">            <span class="keyword">return</span> tempA</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> tempB</span><br></pre></td></tr></table></figure></p>
<p>总结：看了答案以后，最直观的还是根据 BST 性质二分查找；除此之外还有递归（回溯），迭代 / stack / todo 中序遍历（还要维护一个最小值），多种写法。直观写法需要注意：1.ans 赋值的条件；2.root 往哪边走的条件。 递归（回溯）写法要注意：1.返回的条件放的位置（在决定往哪边走之后）；递归完之后还要判断最后返回哪个值</p>
<h3 id="LinC-11-Search-Range-in-Binary-Search-Tree-Medium"><a href="#LinC-11-Search-Range-in-Binary-Search-Tree-Medium" class="headerlink" title="LinC 11.Search Range in Binary Search Tree (Medium)"></a><a href="http://www.lintcode.com/problem/search-range-in-binary-search-tree/" target="_blank" rel="noopener">LinC 11.Search Range in Binary Search Tree (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a binary search tree and a range [k1, k2], return all elements in the given range.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">If k1 = 10 and k2 = 22, then your function should return [12, 20, 22].</span><br><span class="line"></span><br><span class="line">    20</span><br><span class="line">   /  \</span><br><span class="line">  8   22</span><br><span class="line"> / \</span><br><span class="line">4   12</span><br></pre></td></tr></table></figure>
<p>思路：inorder traversal 的话出来的是从小到大，把符合 k1, k2 条件的返回就行了。 至于 DFS 没啥思路。看看 inorder traversal 的 DFS<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of TreeNode:</span></span><br><span class="line"><span class="string">class TreeNode:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left, self.right = None, None</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="comment"># first attempt DFS</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param root: param root: The root of the binary search tree</span></span><br><span class="line"><span class="string">    @param k1: An integer</span></span><br><span class="line"><span class="string">    @param k2: An integer</span></span><br><span class="line"><span class="string">    @return: return: Return all keys that k1&lt;=key&lt;=k2 in ascending order</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, root, k1, k2)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(root, k1, k2, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, root, k1, k2, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.dfs(root.left, k1, k2, ans)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt;= k2 <span class="keyword">and</span> root.val &gt;= k1:</span><br><span class="line">            ans.append(root.val)</span><br><span class="line">        self.dfs(root.right, k1, k2, ans)</span><br></pre></td></tr></table></figure></p>
<p>总结：放个测试数据就能写对。其实是 inorder :’(… BST inorder 是从小到大。。。哎。。。这么基本的问题，好伤。。。 todo 二刷用非递归</p>
<h2 id="Combination-based-DFS-基于组合的深度优先搜索"><a href="#Combination-based-DFS-基于组合的深度优先搜索" class="headerlink" title="Combination based DFS - 基于组合的深度优先搜索"></a>Combination based DFS - 基于组合的深度优先搜索</h2><h3 id="78-Subsets-Medium"><a href="#78-Subsets-Medium" class="headerlink" title="78. Subsets (Medium)"></a><a href="https://leetcode.com/problems/subsets/description/" target="_blank" rel="noopener">78. Subsets (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Given a set of distinct integers, nums, return all possible subsets (the power set).</span><br><span class="line"></span><br><span class="line">Note: The solution set must not contain duplicate subsets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：不太擅长组合和排列的题。这道题确实更像排列题，子集全排。DFS 模板：1.遍历输入元素；2.将当前元素加入 path；3。遍历递归当前元素之后的元素 i + 1；4：剪枝，将最后一个元素从 path 中去掉<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    ans = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs([], <span class="number">0</span>, nums)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, path, index, nums)</span>:</span></span><br><span class="line">        self.ans.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> innerIndex <span class="keyword">in</span> range(index, len(nums)):</span><br><span class="line">            path.append(nums[innerIndex])</span><br><span class="line">            self.dfs(path, innerIndex + <span class="number">1</span>, nums)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：在 dfs 里，往 self.ans 添加答案的时候需要用 deep copy，不然的话会发生 self.ans 里面全是空的状况（感觉是因为最后剪枝的原因）。时间复杂度为 O(n*2^n) 指数级时间， 因为产生 2^n 个子 list，每个 list 的长度是 n 级的<br>二刷：这类 combination 的题要用 start，遍历递归时递归 i + 1 元素; 模板不直接遍历元素了， 下一题 permutation 三刷把代码改成模板，就没有 confusion 了。</p>
<h3 id="39-Combination-Sum-Medium"><a href="#39-Combination-Sum-Medium" class="headerlink" title="39. Combination Sum (Medium)"></a><a href="https://leetcode.com/problems/combination-sum/description/" target="_blank" rel="noopener">39. Combination Sum (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</span><br><span class="line"></span><br><span class="line">The same repeated number may be chosen from candidates unlimited number of times.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All numbers (including target) will be positive integers.</span><br><span class="line">The solution set must not contain duplicate combinations.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: candidates = [2,3,6,7], target = 7,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: candidates = [2,3,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [2,2,2,2],</span><br><span class="line">  [2,3,3],</span><br><span class="line">  [3,5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：看了下答案，DFS 模板搞定，和上一题的区别是允许重复使用一个数， 把入递归的时候 innerIndex + 1 改为 innerIndex 就行了。答案说需要排序， 我想先试试看不排序会出什么样的错<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        <span class="keyword">if</span> len(candidates) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.ans</span><br><span class="line">        self.dfs(candidates, target, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, path, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span>:</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> innerIndex <span class="keyword">in</span> range(index, len(candidates)):</span><br><span class="line">            path.append(candidates[innerIndex])</span><br><span class="line">            self.dfs(candidates, target - candidates[innerIndex], path, innerIndex)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：注意不要在进入递归前改变 target, 因为 target 在后面几次循环中还需要使用。不需要把 input list 排序也能 AC，欧耶。</p>
<h3 id="40-Combination-Sum-II-Medium"><a href="#40-Combination-Sum-II-Medium" class="headerlink" title="40. Combination Sum II (Medium)"></a><a href="https://leetcode.com/problems/combination-sum-ii/description/" target="_blank" rel="noopener">40. Combination Sum II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.</span><br><span class="line"></span><br><span class="line">Each number in candidates may only be used once in the combination.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All numbers (including target) will be positive integers.</span><br><span class="line">The solution set must not contain duplicate combinations.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1, 7],</span><br><span class="line">  [1, 2, 5],</span><br><span class="line">  [2, 6],</span><br><span class="line">  [1, 1, 6]</span><br><span class="line">]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: candidates = [2,5,2,1,2], target = 5,</span><br><span class="line">A solution set is:</span><br><span class="line">[</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [5]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：第一反应感觉跟上题比只差个进递归的 innerIndex 和 innerIndex + 1 的区别，可能写了才知道坑在哪<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum2</span><span class="params">(self, candidates, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type candidates: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        <span class="keyword">if</span> len(candidates) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.ans</span><br><span class="line">        self.dfs(sorted(candidates), target, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, candidates, target, path, index)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> target &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> target == <span class="number">0</span> <span class="keyword">and</span> path <span class="keyword">not</span> <span class="keyword">in</span> self.ans:</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> innerIndex <span class="keyword">in</span> range(index, len(candidates)):</span><br><span class="line">            path.append(candidates[innerIndex])</span><br><span class="line">            self.dfs(candidates, target - candidates[innerIndex], path, innerIndex + <span class="number">1</span>)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：没他大问题， 注意：1.这时就需要 sort 了， 因为要 append 到 self.ans 的时候要去重<br>二刷：去重容易钻到 if i and candidates[i] == candidates[i - 1]: continue 这个坑里， 这题注意用 if target == 0 and path not in ans: 来去重</p>
<h3 id="216-Combination-Sum-III-Medium"><a href="#216-Combination-Sum-III-Medium" class="headerlink" title="216. Combination Sum III (Medium)"></a><a href="https://leetcode.com/problems/combination-sum-iii/description/" target="_blank" rel="noopener">216. Combination Sum III (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">All numbers will be positive integers.</span><br><span class="line">The solution set must not contain duplicate combinations.</span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: k = 3, n = 7</span><br><span class="line">Output: [[1,2,4]]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: k = 3, n = 9</span><br><span class="line">Output: [[1,2,6], [1,3,5], [2,3,4]]</span><br></pre></td></tr></table></figure>
<p>思路：纯凭感觉写的，有前面两题做铺垫，这题可以直接写出来<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combinationSum3</span><span class="params">(self, k, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(k, n, [], <span class="number">1</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, k, n, path, start, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == k:</span><br><span class="line">            <span class="keyword">if</span> sum(path) == n:</span><br><span class="line">                ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, <span class="number">10</span>):</span><br><span class="line">            path.append(i)</span><br><span class="line">            self.dfs(k, n, path, i + <span class="number">1</span>, ans)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：基本一次写对，注意 append(path[:]) 要 deep copy</p>
<h3 id="131-Palindrome-Partitioning-Medium"><a href="#131-Palindrome-Partitioning-Medium" class="headerlink" title="131. Palindrome Partitioning (Medium)"></a><a href="https://leetcode.com/problems/palindrome-partitioning/description/" target="_blank" rel="noopener">131. Palindrome Partitioning (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a string s, partition s such that every substring of the partition is a palindrome.</span><br><span class="line"></span><br><span class="line">Return all possible palindrome partitioning of s.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: "aab"</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  ["aa","b"],</span><br><span class="line">  ["a","a","b"]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：看了下答案， 唯一不太好懂的地方是 start &gt;= len(s) 才入 self.ans， 写好以后用测试数据看看为什么<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[List[str]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.ans</span><br><span class="line">        self.dfs(s, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= len(s):</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(start, len(s)):</span><br><span class="line">            subS = s[start:index + <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> self.isPalindrome(subS):</span><br><span class="line">                path.append(subS)</span><br><span class="line">                self.dfs(s, path, index + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> s == s[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：注意：1.subStr[0:1] 返回第一个 char，[0:2] 返回 [0][1] 位置的 subStr；2.python 检查 palindrom 可以用 s == s[::-1]；3.self.ans.append(path[:]) 以后记得 return; 4.range(start, len(s)) 可以通过测试数据纠正。之所以用 start &gt;= len(s) 是因为要把 s 拆完一遍才能入 self.ans</p>
<h3 id="93-Restore-IP-Addresses-Medium"><a href="#93-Restore-IP-Addresses-Medium" class="headerlink" title="93. Restore IP Addresses (Medium)"></a><a href="https://leetcode.com/problems/restore-ip-addresses/description/" target="_blank" rel="noopener">93. Restore IP Addresses (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given a string containing only digits, restore it by returning all possible valid IP address combinations.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: "25525511135"</span><br><span class="line">Output: ["255.255.11.135", "255.255.111.35"]</span><br></pre></td></tr></table></figure>
<p>思路：从上面的 131. Palindrome Partitioning (Medium) 和 LinC 680. Split String (Easy) 获得了灵感<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">restoreIpAddresses</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">12</span> <span class="keyword">or</span> len(s) &lt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(s, <span class="string">''</span>, <span class="number">0</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path, start, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> path.count(<span class="string">'.'</span>) &gt; <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == len(s) + <span class="number">4</span>:</span><br><span class="line">            ans.append(path[:<span class="number">-1</span>])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(s)):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(s[start:i + <span class="number">1</span>]):</span><br><span class="line">                path += s[start:i + <span class="number">1</span>] + <span class="string">'.'</span></span><br><span class="line">                self.dfs(s, path, i + <span class="number">1</span>, ans)</span><br><span class="line">                path = path[:-(i + <span class="number">2</span> - start)]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &gt; <span class="number">1</span> <span class="keyword">and</span> s[<span class="number">0</span>] == <span class="string">'0'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> int(s) &gt;= <span class="number">0</span> <span class="keyword">and</span> int(s) &lt;= <span class="number">255</span></span><br></pre></td></tr></table></figure></p>
<p>总结：很多细节：1. start 跟着 i 走，没有前进；2. 遍历字符串取子串的时候要 range(, len + 1)， 不然会取不到最后一个字符<br>不算二刷，以上注意的第 2 点可以简化为取 s[start:i + 1]; 从 131. Palindrome Partitioning (Medium) 学的。</p>
<h3 id="LinC-680-Split-String-Easy"><a href="#LinC-680-Split-String-Easy" class="headerlink" title="LinC 680. Split String (Easy)"></a><a href="https://www.lintcode.com/problem/split-string/description" target="_blank" rel="noopener">LinC 680. Split String (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Give a string, you can choose to split the string after one character or two adjacent characters, and make the string to be composed of only one character or two characters. Output all possible results.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given the string "123"</span><br><span class="line">return [["1","2","3"],["12","3"],["1","23"]]</span><br></pre></td></tr></table></figure>
<p>思路：看了下答案，主要的文章就在递归退出的条件和 DFS 中 for 循环的起始条件。边写边想。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: : a string to be split</span></span><br><span class="line"><span class="string">    @return: all possible split string array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">splitString</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> [[]]</span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(s, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start &gt;= len(s):</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(start, start + <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">if</span> index &lt; len(s):</span><br><span class="line">                path.append(s[start:index + <span class="number">1</span>])</span><br><span class="line">                self.dfs(s, path, index + <span class="number">1</span>)</span><br><span class="line">                path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：空输入的输出有点 wacky，for 循环内注意查越界（可以通过测试一个数据实现）</p>
<h3 id="77-Combinations-Medium"><a href="#77-Combinations-Medium" class="headerlink" title="77. Combinations (Medium)"></a><a href="https://leetcode.com/problems/combinations/description/" target="_blank" rel="noopener">77. Combinations (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: n = 4, k = 2</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：和 combination sum I, II 类似， 但是又有点不同：没有重复输入， 同一个数不能用两次<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">combine</span><span class="params">(self, n, k)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :type k: int</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        self.dfs(n, k, [], <span class="number">0</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, n, k, path, start, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == k:</span><br><span class="line">            ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, n):</span><br><span class="line">            path.append(i + <span class="number">1</span>)</span><br><span class="line">            self.dfs(n, k, path, i + <span class="number">1</span>, ans)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：注意 dfs 中需要 start; dfs 内循环需要 for i in range(start, n); 调用 dfs 时， start 参数为 i + 1 来实现同一个数不用两次。</p>
<h3 id="90-Subsets-II-Medium"><a href="#90-Subsets-II-Medium" class="headerlink" title="90. Subsets II (Medium)"></a><a href="https://leetcode.com/problems/subsets-ii/description/" target="_blank" rel="noopener">90. Subsets II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).</span><br><span class="line"></span><br><span class="line">Note: The solution set must not contain duplicate subsets.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：经典 subset 的延伸，允许 input 中有重复元素<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        nums.sort()</span><br><span class="line">        self.dfs(nums, [], <span class="number">0</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, path, start, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> path <span class="keyword">not</span> <span class="keyword">in</span> ans:</span><br><span class="line">            ans.append(path[:])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(start, len(nums)):</span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            self.dfs(nums, path, i + <span class="number">1</span>, ans)</span><br><span class="line">            path.pop()</span><br></pre></td></tr></table></figure></p>
<p>总结：permutation 要记 visited, permutation 有 dup 的要 i and nums[i] == nums[i - 1] and visited…: continue 避免重复的元素被重复选为起始元素。subset / combination 去重用的 not in ans。注意：not in ans: ans.append <strong>以后不能 return!</strong>， 否则会导致递归在此退出，因为这是 dfs 递归进来无条件做的第一件事。input 要 sort，不然如：[4,4,4,4,4,1,4,4] 这种情况会出错，因为需要产生的是 set, 顺序不重要。</p>
<h2 id="Permutation-based-DFS-基于排列的深度优先搜索"><a href="#Permutation-based-DFS-基于排列的深度优先搜索" class="headerlink" title="Permutation based DFS - 基于排列的深度优先搜索"></a>Permutation based DFS - 基于排列的深度优先搜索</h2><h3 id="46-Permutations-Medium"><a href="#46-Permutations-Medium" class="headerlink" title="46. Permutations (Medium)"></a><a href="https://leetcode.com/problems/permutations/description/" target="_blank" rel="noopener">46. Permutations (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of distinct integers, return all possible permutations.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,2,3]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：答案说要记具体某个点是否已经被访问过。写写看有没有什么坑<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans = []</span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            self.visited[i] = <span class="keyword">False</span></span><br><span class="line">        self.dfs(nums, [], ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, path, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == len(nums):</span><br><span class="line">            ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> self.visited[i]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            path.append(nums[i])</span><br><span class="line">            self.visited[i] = <span class="keyword">True</span></span><br><span class="line">            self.dfs(nums, path, ans)</span><br><span class="line">            path.pop()</span><br><span class="line">            self.visited[i] = <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：思路 OK 的话貌似没有什么明显的坑<br>二刷：和 subset 和 combination sum 不同点在于排列进入 dfs 不需要 start 这个参数; 记得要有 self.visited, 存 path 的时候要 deep copy<br>三刷：遍历进递归的循环走 i, 和其他 DFS 模板保持一致。这题可以通过 if self.visited[i]: continue 来记需要一个 self.visited</p>
<h3 id="47-Permutations-II-Medium"><a href="#47-Permutations-II-Medium" class="headerlink" title="47. Permutations II (Medium)"></a><a href="https://leetcode.com/problems/permutations-ii/description/" target="_blank" rel="noopener">47. Permutations II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given a collection of numbers that might contain duplicates, return all possible unique permutations.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: [1,1,2]</span><br><span class="line">Output:</span><br><span class="line">[</span><br><span class="line">  [1,1,2],</span><br><span class="line">  [1,2,1],</span><br><span class="line">  [2,1,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：看了下答案，比上一题要多处理的两件事：1.要排序；2.对于相同的数在 for 循环里跳过；此处 for 循环要用 index 了因为有重复的数，要用 dict 统计该位置是否被用过<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permuteUnique</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: List[List[int]]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        <span class="keyword">if</span> len(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.ans</span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            self.visited[i] = <span class="keyword">False</span></span><br><span class="line">        self.dfs(sorted(nums), [])</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, nums, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == len(nums):</span><br><span class="line">            self.ans.append(path[:])</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.visited[i]:</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> self.visited[i - <span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                self.visited[i] = <span class="keyword">True</span></span><br><span class="line">                self.dfs(nums, path)</span><br><span class="line">                path.pop()</span><br><span class="line">                self.visited[i] = <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意相同数的跳过方法，需要用 if i &gt; 0 and nums[i] == nums[i - 1] and not visited[i - 1] i.e. 如果相等，需要前面的已经用过了才能用（相等且 i - 1 用过了就<strong>不</strong> continue，就是说这个重复的数是给前面的轮次在用）<br>二刷：和 combination sum II 的类似之处是 input 都可能有重复的元素。 和 permutation 类似之处是也需要 visited 记录已使用的元素。不同是 iterate 的时候要用 i, 还要 i == i - 1 and visited[i - 1] == False 来去重; dfs 里 iterate 的时候记得 if not self.visited；要细心，…and visited[i - 1] == false</p>
<h3 id="LinC-862-Next-Closest-Time-Medium"><a href="#LinC-862-Next-Closest-Time-Medium" class="headerlink" title="LinC 862. Next Closest Time (Medium)"></a><a href="https://www.lintcode.com/problem/next-closest-time/description" target="_blank" rel="noopener">LinC 862. Next Closest Time (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Given a time represented in the format "HH:MM", form the next closest time by reusing the current digits. There is no limit on how many times a digit can be reused.</span><br><span class="line"></span><br><span class="line">You may assume the given input string is always valid. For example, "01:34", "12:09" are all valid. "1:34", "12:9" are all invalid.</span><br><span class="line"></span><br><span class="line">Example：</span><br><span class="line">Given time = "19:34", return "19:39".</span><br><span class="line">Explanation:</span><br><span class="line">The next closest time choosing from digits 1, 9, 3, 4, is 19:39, which occurs 5 minutes later.  It is not 19:33, because this occurs 23 hours and 59 minutes later.</span><br><span class="line"></span><br><span class="line">Given time = "23:59", return "22:22".</span><br><span class="line">Explanation:</span><br><span class="line">The next closest time choosing from digits 2, 3, 5, 9, is 22:22. It may be assumed that the returned time is next day's time since it is smaller than the input time numerically.</span><br></pre></td></tr></table></figure>
<p>思路：属于对我来说现场想很费时的题。直接看答案找思路<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param time: the given time</span></span><br><span class="line"><span class="string">    @return: the next closest time</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nextClosestTime</span><span class="params">(self, time)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        s = set(time)</span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> time</span><br><span class="line">        digits = time[<span class="number">0</span>:<span class="number">2</span>] + time[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">        self.ans = <span class="string">''</span></span><br><span class="line">        self.minDiff = sys.maxsize</span><br><span class="line">        self.target = int(time[<span class="number">0</span>:<span class="number">2</span>]) * <span class="number">60</span> + int(time[<span class="number">3</span>:<span class="number">5</span>])</span><br><span class="line">        self.dfs(digits, <span class="string">''</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, digits, path, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == <span class="number">4</span>:</span><br><span class="line">            <span class="comment"># path 产生了一个合法的时间，判断和 target 距离 diff 和 self.minDiff 的关系</span></span><br><span class="line">            m = int(path[<span class="number">0</span>:<span class="number">2</span>]) * <span class="number">60</span> + int(path[<span class="number">2</span>:<span class="number">4</span>])</span><br><span class="line">            diff = m - self.target</span><br><span class="line">            <span class="keyword">if</span> diff == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">if</span> diff &lt; <span class="number">0</span>:</span><br><span class="line">                diff = <span class="number">24</span> * <span class="number">60</span> + diff</span><br><span class="line">            <span class="keyword">if</span> diff &lt; self.minDiff:</span><br><span class="line">                self.minDiff = diff</span><br><span class="line">                self.ans = path[<span class="number">0</span>:<span class="number">2</span>] + <span class="string">':'</span> + path[<span class="number">2</span>:<span class="number">4</span>]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> digit <span class="keyword">in</span> digits:</span><br><span class="line">            <span class="comment"># 处理 path, 把不合适的时间都 continue 过去, 但是怎么判断现在处理的是哪个位置？看了下答案， 其实不需要 enumerate</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">0</span> <span class="keyword">and</span> int(digit) &gt; <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">1</span> <span class="keyword">and</span> int(path) * <span class="number">10</span> + int(digit) &gt; <span class="number">23</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">2</span> <span class="keyword">and</span> int(digit) &gt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> start == <span class="number">3</span> <span class="keyword">and</span> int(path[<span class="number">2</span>:<span class="number">3</span>]) * <span class="number">10</span> + int(digit) &gt; <span class="number">59</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.dfs(digits, path + digit, start + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：python3 把 sys.maxint 改成 sys.maxsize 了。要一次对的话，很多取数的细节需要留心。1.input time 要取 [0:2] [3:5] 来跳过 ‘:’; 2.diff 是负数的时候要用 24 * 60 + diff（而不是 -）；3.for 循环里面的 digit 记得包上 int()</p>
<h3 id="22-Generate-Parentheses-Medium"><a href="#22-Generate-Parentheses-Medium" class="headerlink" title="22. Generate Parentheses (Medium)"></a><a href="https://leetcode.com/problems/generate-parentheses/description/" target="_blank" rel="noopener">22. Generate Parentheses (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</span><br><span class="line"></span><br><span class="line">For example, given n = 3, a solution set is:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  "((()))",</span><br><span class="line">  "(()())",</span><br><span class="line">  "(())()",</span><br><span class="line">  "()(())",</span><br><span class="line">  "()()()"</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>思路：既然是 backtracking / permutation based dfs 的题，先看看套路。有两个可能的路径， 第一种是：先 n 对括号的全排列，然后留 valid；第二种是：直接从 n 对括号里拼 valid 的排列，先试试第一种， 比较直观好理解。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        s = <span class="string">'('</span> * n + <span class="string">')'</span> * n</span><br><span class="line">        self.visited = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n * <span class="number">2</span>):</span><br><span class="line">            self.visited[i] = <span class="keyword">False</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        self.dfs(s, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, s, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(path) == len(s):</span><br><span class="line">            <span class="keyword">if</span> self.isValid(path):</span><br><span class="line">                self.ans.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">and</span> s[i] == s[i - <span class="number">1</span>] <span class="keyword">and</span> <span class="keyword">not</span> self.visited[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            self.visited[i] = <span class="keyword">True</span></span><br><span class="line">            path += s[i]</span><br><span class="line">            self.dfs(s, path)</span><br><span class="line">            path = path[:<span class="number">-1</span>]</span><br><span class="line">            self.visited[i] = <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, path)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> path[<span class="number">0</span>] == <span class="string">')'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        stack = []</span><br><span class="line">        <span class="keyword">for</span> paren <span class="keyword">in</span> path:</span><br><span class="line">            <span class="keyword">if</span> paren == <span class="string">'('</span>:</span><br><span class="line">                stack.append(paren)</span><br><span class="line">            <span class="keyword">if</span> paren == <span class="string">')'</span>:</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    stack.pop()</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> len(stack) == <span class="number">0</span>       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 二刷，稍微妖一点的 DFS 解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span>       </span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        ans =[]</span><br><span class="line">        self.dfs(n, n, <span class="string">''</span>, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, left, right, path, ans)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="number">0</span> <span class="keyword">and</span> right == <span class="number">0</span>:</span><br><span class="line">            ans.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> left &gt; <span class="number">0</span>:</span><br><span class="line">            self.dfs(left - <span class="number">1</span>, right, path + <span class="string">'('</span>, ans)</span><br><span class="line">        <span class="keyword">if</span> right &gt; <span class="number">0</span> <span class="keyword">and</span> left &lt; right:</span><br><span class="line">            self.dfs(left, right - <span class="number">1</span>, path + <span class="string">')'</span>, ans)</span><br></pre></td></tr></table></figure>
<p>总结：还挺佩服我自己的，调试下居然能过。。。虽然效率及其低下。。。立刻二刷吧。。。<br>二刷没什么好说的，left &lt; right ( 比 ) 数量多就 paren 就 valid。</p>
<h2 id="Graph-based-DFS-基于图的深度优先搜索"><a href="#Graph-based-DFS-基于图的深度优先搜索" class="headerlink" title="Graph based DFS 基于图的深度优先搜索"></a>Graph based DFS 基于图的深度优先搜索</h2><h3 id="17-Letter-Combinations-of-a-Phone-Number-Medium"><a href="#17-Letter-Combinations-of-a-Phone-Number-Medium" class="headerlink" title="17. Letter Combinations of a Phone Number (Medium)"></a><a href="https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/" target="_blank" rel="noopener">17. Letter Combinations of a Phone Number (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</span><br><span class="line"></span><br><span class="line">A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</span><br></pre></td></tr></table></figure>
<p><img src="/images/leetcode_17_lett_1.png" alt="keypad example"><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: "23"</span><br><span class="line">Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Although the above answer is in lexicographical order, your answer could be in any order you want.</span><br></pre></td></tr></table></figure></p>
<p>思路：看着像 DFS，但是没有特别具体的思路，看答案。看了下三年前写的代码，还挺牛逼的。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type digits: str</span></span><br><span class="line"><span class="string">        :rtype: List[str]</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.ans = []</span><br><span class="line">        <span class="keyword">if</span> len(digits) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> self.ans</span><br><span class="line">        self.mapping = &#123;</span><br><span class="line">            <span class="string">'2'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],</span><br><span class="line">            <span class="string">'3'</span>: [<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>],</span><br><span class="line">            <span class="string">'4'</span>: [<span class="string">'g'</span>, <span class="string">'h'</span>, <span class="string">'i'</span>],</span><br><span class="line">            <span class="string">'5'</span>: [<span class="string">'j'</span>, <span class="string">'k'</span>, <span class="string">'l'</span>],</span><br><span class="line">            <span class="string">'6'</span>: [<span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'o'</span>],</span><br><span class="line">            <span class="string">'7'</span>: [<span class="string">'p'</span>, <span class="string">'q'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>],</span><br><span class="line">            <span class="string">'8'</span>: [<span class="string">'t'</span>, <span class="string">'u'</span>, <span class="string">'v'</span>],</span><br><span class="line">            <span class="string">'9'</span>: [<span class="string">'w'</span>, <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        self.dfs(digits, <span class="string">''</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> self.ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, digits, path, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == len(digits):</span><br><span class="line">            self.ans.append(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> letter <span class="keyword">in</span> self.mapping[digits[start]]:</span><br><span class="line">            self.dfs(digits, path + letter, start + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：只能说三年前写的还挺牛逼的。。。</p>
<h3 id="79-Word-Search-Medium"><a href="#79-Word-Search-Medium" class="headerlink" title="79. Word Search (Medium)"></a><a href="https://leetcode.com/problems/word-search/description/" target="_blank" rel="noopener">79. Word Search (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given a 2D board and a word, find if the word exists in the grid.</span><br><span class="line"></span><br><span class="line">The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  ['A','B','C','E'],</span><br><span class="line">  ['S','F','C','S'],</span><br><span class="line">  ['A','D','E','E']</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = "ABCCED", return true.</span><br><span class="line">Given word = "SEE", return true.</span><br><span class="line">Given word = "ABCB", return false.</span><br></pre></td></tr></table></figure>
<p>思路：知道是 DFS 以后超级明显的一道题，两年多前居然写过。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board, word)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type board: List[List[str]]</span></span><br><span class="line"><span class="string">        :type word: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">0</span>, len(board)):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">0</span>, len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> self.dfs(board, row, col, word, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(self, board, row, col, word, start)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> start == len(word):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> row &lt; <span class="number">0</span> <span class="keyword">or</span> row &gt; len(board) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> col &lt; <span class="number">0</span> <span class="keyword">or</span> col &gt; len(board[<span class="number">0</span>]) - <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">if</span> board[row][col] != word[start]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        board[row][col] = <span class="string">'#'</span></span><br><span class="line">        <span class="comment"># up</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, row - <span class="number">1</span>, col, word, start + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># down</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, row + <span class="number">1</span>, col, word, start + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># left</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, row, col - <span class="number">1</span>, word, start + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># right</span></span><br><span class="line">        <span class="keyword">if</span> self.dfs(board, row, col + <span class="number">1</span>, word, start + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        board[row][col] = word[start]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure></p>
<p>总结：已经决定了不喜欢 x, y 千万不要动摇，row, col 到底。注意越界判断的时候要用 len(board) - 1 和 len(board[0]) - 1 而非 word。这次用了新写法，比两年多前的版本少了大约 10 行左右代码。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="Binary-Tree-amp-Divide-Conquer-二叉树与分治"><a href="#Binary-Tree-amp-Divide-Conquer-二叉树与分治" class="headerlink" title="Binary Tree &amp; Divide Conquer 二叉树与分治"></a>Binary Tree &amp; Divide Conquer 二叉树与分治</h2><h3 id="110-Balanced-Binary-Tree-Easy"><a href="#110-Balanced-Binary-Tree-Easy" class="headerlink" title="110. Balanced Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">110. Balanced Binary Tree (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, determine if it is height-balanced.</span><br><span class="line"></span><br><span class="line">For this problem, a height-balanced binary tree is defined as:</span><br><span class="line"></span><br><span class="line">a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Given the following tree [3,9,20,null,null,15,7]:</span><br><span class="line"></span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">Return true.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Given the following tree [1,2,2,3,3,null,null,4,4]:</span><br><span class="line"></span><br><span class="line">       1</span><br><span class="line">      / \</span><br><span class="line">     2   2</span><br><span class="line">    / \</span><br><span class="line">   3   3</span><br><span class="line">  / \</span><br><span class="line"> 4   4</span><br><span class="line">Return false.</span><br></pre></td></tr></table></figure>
<p>思路：没什么思路，但是这种左右子树都得符合某种条件的题型感觉得用分治<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, balanced, maxDepth)</span>:</span></span><br><span class="line">        self.isBalanced = balanced</span><br><span class="line">        self.maxDepth = maxDepth</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.helper(root).isBalanced</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> ResultType(<span class="keyword">True</span>, <span class="number">0</span>)</span><br><span class="line">        left = self.helper(root.left)</span><br><span class="line">        right = self.helper(root.right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> left.isBalanced <span class="keyword">or</span> <span class="keyword">not</span> right.isBalanced:</span><br><span class="line">            <span class="keyword">return</span> ResultType(<span class="keyword">False</span>, <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> abs(left.maxDepth - right.maxDepth) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> ResultType(<span class="keyword">False</span>, <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> ResultType(<span class="keyword">True</span>, max(left.maxDepth, right.maxDepth) + <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：加了 ResultType(isBalanced, maxDepth)，就好办很多， 记住递归 helper 函数最后一句；return ResultType(True, max(left.maxDepth, right.maxDepth) + 1)</p>
<h3 id="114-Flatten-Binary-Tree-to-Linked-List-Medium"><a href="#114-Flatten-Binary-Tree-to-Linked-List-Medium" class="headerlink" title="114. Flatten Binary Tree to Linked List (Medium)"></a><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/description/" target="_blank" rel="noopener">114. Flatten Binary Tree to Linked List (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Given a binary tree, flatten it to a linked list in-place.</span><br><span class="line"></span><br><span class="line">For example, given the following tree:</span><br><span class="line"></span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   5</span><br><span class="line"> / \   \</span><br><span class="line">3   4   6</span><br><span class="line">The flattened tree should look like:</span><br><span class="line"></span><br><span class="line">1</span><br><span class="line"> \</span><br><span class="line">  2</span><br><span class="line">   \</span><br><span class="line">    3</span><br><span class="line">     \</span><br><span class="line">      4</span><br><span class="line">       \</span><br><span class="line">        5</span><br><span class="line">         \</span><br><span class="line">          6</span><br></pre></td></tr></table></figure>
<p>思路：看着像典型的 DFS，不知道有什么坑，直接写吧<br>二刷：网上比较靠谱的思路，先把左右子树flattern了, 再把root的右接左子树, 左子树的最后接右子树<br><img src="/images/leetcode_114_flat.jpeg" alt="114graph"><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">flatten</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify root in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.flatten(root.left)</span><br><span class="line">        self.flatten(root.right)</span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="keyword">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        p = root.left</span><br><span class="line">        <span class="keyword">while</span> p.right:</span><br><span class="line">            p = p.right</span><br><span class="line">        p.right = root.right</span><br><span class="line">        root.right = root.left</span><br><span class="line">        root.left = <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<p>总结：基本靠套路。1.None 既 return，左右到底， 左边为空既 return 2. 到左边一个，往右到底， 套路：p.right = root.right; root.right = root.left; root.left = null i.e.：将 root 右边接到 p（尾巴上）, root 右节点变为 root 左节点， root 左节点置空</p>
<h2 id="Stack-栈"><a href="#Stack-栈" class="headerlink" title="Stack 栈"></a>Stack 栈</h2><h3 id="20-Valid-Parentheses-Easy"><a href="#20-Valid-Parentheses-Easy" class="headerlink" title="20. Valid Parentheses (Easy)"></a><a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">20. Valid Parentheses (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Given a string containing just the characters '(', ')', '&#123;', '&#125;', '[' and ']', determine if the input string is valid.</span><br><span class="line"></span><br><span class="line">An input string is valid if:</span><br><span class="line"></span><br><span class="line">Open brackets must be closed by the same type of brackets.</span><br><span class="line">Open brackets must be closed in the correct order.</span><br><span class="line">Note that an empty string is also considered valid.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: "()"</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: "()[]&#123;&#125;"</span><br><span class="line">Output: true</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: "(]"</span><br><span class="line">Output: false</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: "([)]"</span><br><span class="line">Output: false</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line">Input: "&#123;[]&#125;"</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>
<p>思路：stack 题，open 的就入栈，close 的就出栈，对不上就 return false，栈空就 true<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValid</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">if</span> len(s) % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mapping = &#123;<span class="string">'('</span>: <span class="string">')'</span>, <span class="string">'&#123;'</span>: <span class="string">'&#125;'</span>, <span class="string">'['</span>: <span class="string">']'</span>&#125;</span><br><span class="line">        stack = []</span><br><span class="line">        stack.append(s[<span class="number">0</span>])</span><br><span class="line">        cur = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            <span class="keyword">if</span> cur &gt; len(s) - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> s[cur] <span class="keyword">in</span> mapping.keys():</span><br><span class="line">                stack.append(s[cur])</span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmp = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> tmp <span class="keyword">not</span> <span class="keyword">in</span> mapping:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">if</span> s[cur] != mapping[tmp]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                cur += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意一开始就是 ), }，] 这类的，会被初始化到 stack 里，需要加判断 tmp not in mapping: false</p>
<h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2><h3 id="LinC-642-Moving-Average-from-Data-Stream-Easy"><a href="#LinC-642-Moving-Average-from-Data-Stream-Easy" class="headerlink" title="LinC 642. Moving Average from Data Stream (Easy)"></a><a href="https://www.lintcode.com/problem/moving-average-from-data-stream/description" target="_blank" rel="noopener">LinC 642. Moving Average from Data Stream (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">MovingAverage m = new MovingAverage(3);</span><br><span class="line">m.next(1) = 1 // return 1.00000</span><br><span class="line">m.next(10) = (1 + 10) / 2 // return 5.50000</span><br><span class="line">m.next(3) = (1 + 10 + 3) / 3 // return 4.66667</span><br><span class="line">m.next(5) = (10 + 3 + 5) / 3 // return 6.00000</span><br></pre></td></tr></table></figure>
<p>思路：建个 window size 的队列，返回队列的平均值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MovingAverage</span>:</span></span><br><span class="line">    q = collections.deque()</span><br><span class="line">    sum = <span class="number">0</span></span><br><span class="line">    maxLen = <span class="number">0</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: size: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, size)</span>:</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.maxLen = size</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: val: An integer</span></span><br><span class="line"><span class="string">    @return:  </span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        self.q.append(val)</span><br><span class="line">        self.sum += val</span><br><span class="line">        <span class="keyword">if</span> len(self.q) &gt; self.maxLen:</span><br><span class="line">            temp = self.q.popleft()</span><br><span class="line">            self.sum -= temp</span><br><span class="line">        avg = self.sum / len(self.q)</span><br><span class="line">        <span class="keyword">return</span> avg</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your MovingAverage object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = MovingAverage(size)</span></span><br><span class="line"><span class="comment"># param = obj.next(val)</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意 class 变量要加 self，另外 sum 不要每次都 loop 一遍算， 直接放到 class 变量里，每次只增 and / or 减一次。</p>
<h2 id="Hash-哈希表"><a href="#Hash-哈希表" class="headerlink" title="Hash 哈希表"></a>Hash 哈希表</h2><h3 id="290-Word-Pattern-Easy"><a href="#290-Word-Pattern-Easy" class="headerlink" title="290. Word Pattern (Easy)"></a><a href="https://leetcode.com/problems/word-pattern/description/" target="_blank" rel="noopener">290. Word Pattern (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Given a pattern and a string str, find if str follows the same pattern.</span><br><span class="line"></span><br><span class="line">Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: pattern = "abba", str = "dog cat cat dog"</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input:pattern = "abba", str = "dog cat cat fish"</span><br><span class="line">Output: false</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: pattern = "aaaa", str = "dog cat cat dog"</span><br><span class="line">Output: false</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: pattern = "abba", str = "dog dog dog dog"</span><br><span class="line">Output: false</span><br><span class="line">Notes:</span><br><span class="line">You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.</span><br></pre></td></tr></table></figure>
<p>思路：关键在于懂得建立 pattern 里每个字母和 str 里每个 word 的映射。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wordPattern</span><span class="params">(self, pattern, str)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type pattern: str</span></span><br><span class="line"><span class="string">        :type str: str</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        words = str.split(<span class="string">' '</span>)</span><br><span class="line">        <span class="keyword">if</span> len(words) != len(pattern):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        mapping = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, char <span class="keyword">in</span> enumerate(pattern):</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">in</span> mapping:</span><br><span class="line">                <span class="keyword">if</span> mapping[char] != words[i]:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> words[i] <span class="keyword">in</span> mapping.values():</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                mapping[char] = words[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p>
<p>总结：注意需要用 enumerate， 因为要同时遍历 pattern 和 str. 很好的哈希表热身题。Word Pattern II 的 str 里没有空格了，不能直接 split，难度直接推到 Hard。目前刷题的水平先跳过吧 :(</p>
<h3 id="387-First-Unique-Character-in-a-String-Easy"><a href="#387-First-Unique-Character-in-a-String-Easy" class="headerlink" title="387. First Unique Character in a String (Easy)"></a><a href="https://leetcode.com/problems/first-unique-character-in-a-string/description/" target="_blank" rel="noopener">387. First Unique Character in a String (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.</span><br><span class="line"></span><br><span class="line">Examples:</span><br><span class="line"></span><br><span class="line">s = "leetcode"</span><br><span class="line">return 0.</span><br><span class="line"></span><br><span class="line">s = "loveleetcode",</span><br><span class="line">return 2.</span><br><span class="line">Note: You may assume the string contain only lowercase letters.</span><br></pre></td></tr></table></figure>
<p>思路：过两遍，第一遍数出现多少次， 第二遍把第一个为 1 的 index 返回<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUniqChar</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> dict:</span><br><span class="line">                dict[char] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dict[char] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> index, char <span class="keyword">in</span> enumerate(s):</span><br><span class="line">            <span class="keyword">if</span> dict[char] == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：基本题，注意 dict entry 初始化为 1 的情况</p>
<h3 id="409-Longest-Palindrome-Easy"><a href="#409-Longest-Palindrome-Easy" class="headerlink" title="409. Longest Palindrome (Easy)"></a><a href="https://leetcode.com/problems/longest-palindrome/description/" target="_blank" rel="noopener">409. Longest Palindrome (Easy)</a><a id="leetcode-409"></a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.</span><br><span class="line"></span><br><span class="line">This is case sensitive, for example "Aa" is not considered a palindrome here.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line">Assume the length of given string will not exceed 1,010.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">"abccccdd"</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">One longest palindrome that can be built is "dccaccd", whose length is 7.</span><br></pre></td></tr></table></figure>
<p>思路：得知道每个字母出现的次数，每出现两次就放两边（长度加 2），最后用一个变量记单数的个数，&gt; 0 就长度加 1，O(n); 写到一半发现这题更适合放 hashmap，先写了再看双指针写法。<br>二刷 DP: f 为该位置能组最长回文的长度；<del>f[0] = 1， f[1] = 2 if f[1] 有偶数个 else f[1] = f[0]， f[2] = f[1] + 2 if s[i] 有偶数个 else f[2] = f[1]， else f[1], f[3] = f[2] +  f[i] = f[i - 1] + 2 if s[i] 能和 s[0, i - 1] 形成回文， else f[i - 1]</del><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(s) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> len(s)</span><br><span class="line">        singleCounter = <span class="number">0</span></span><br><span class="line">        hashMap = &#123;&#125;</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> hashMap:</span><br><span class="line">                hashMap[char] = <span class="number">1</span></span><br><span class="line">                singleCounter += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashMap[char] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashMap[char] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    singleCounter -= <span class="number">1</span></span><br><span class="line">                    ans += <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    singleCounter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> singleCounter &gt; <span class="number">0</span>:</span><br><span class="line">            ans += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二刷 DP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        n = len(s)</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        f = [<span class="number">0</span>] * n</span><br><span class="line">        hashmap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> s[i] <span class="keyword">in</span> hashmap:</span><br><span class="line">                hashmap[s[i]] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> hashmap[s[i]] % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">                    f[i] = f[i - <span class="number">1</span>] + <span class="number">2</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    f[i] = f[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hashmap[s[i]] = <span class="number">1</span></span><br><span class="line">                f[i] = f[i - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> hashmap.values():</span><br><span class="line">            <span class="keyword">if</span> value % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> f[n - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：hashmap 没毛病，看看双指针答案。靠，九章答案根本就不是双指针。hashmap 题<br>二刷：<del>注意 f[i] = f[i - 1] + 1 或 f[i - 1] 不要搞错;</del> 第一感觉是有问题的， 拿 ‘abc’, ‘abb’, ‘bbb’，就能测出来，需要用 f[i] = f[i - 1] + 2 如果是偶数个 else f[i] = f[i - 1]， 初始都是 0， 返回的时候过一遍 map， 如果有单数的，返回 f[n - 1] + 1. 不然返回 f[n - 1]; 还要注意 s[i] 在不在 map 里，f[i] 都要 = f[i - 1]（在 map 里有两种情况）</p>
<h3 id="380-Insert-Delete-GetRandom-O-1-Medium"><a href="#380-Insert-Delete-GetRandom-O-1-Medium" class="headerlink" title="380. Insert Delete GetRandom O(1) (Medium)"></a><a href="https://leetcode.com/problems/insert-delete-getrandom-o1/description/" target="_blank" rel="noopener">380. Insert Delete GetRandom O(1) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Design a data structure that supports all following operations in average O(1) time.</span><br><span class="line"></span><br><span class="line">insert(val): Inserts an item val to the set if not already present.</span><br><span class="line">remove(val): Removes an item val from the set if present.</span><br><span class="line">getRandom: Returns a random element from current set of elements. Each element must have the same probability of being returned.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">// Init an empty set.</span><br><span class="line">RandomizedSet randomSet = new RandomizedSet();</span><br><span class="line"></span><br><span class="line">// Inserts 1 to the set. Returns true as 1 was inserted successfully.</span><br><span class="line">randomSet.insert(1);</span><br><span class="line"></span><br><span class="line">// Returns false as 2 does not exist in the set.</span><br><span class="line">randomSet.remove(2);</span><br><span class="line"></span><br><span class="line">// Inserts 2 to the set, returns true. Set now contains [1,2].</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// getRandom should return either 1 or 2 randomly.</span><br><span class="line">randomSet.getRandom();</span><br><span class="line"></span><br><span class="line">// Removes 1 from the set, returns true. Set now contains [2].</span><br><span class="line">randomSet.remove(1);</span><br><span class="line"></span><br><span class="line">// 2 was already in the set, so return false.</span><br><span class="line">randomSet.insert(2);</span><br><span class="line"></span><br><span class="line">// Since 2 is the only number in the set, getRandom always return 2.</span><br><span class="line">randomSet.getRandom();</span><br></pre></td></tr></table></figure>
<p>思路：看答案知道需要用 list 和 dictionary，因为要满足 O(1), 因为仅有 list 的 in 操作不能满足 O(1)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Initialize your data structure here.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.list = []</span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Inserts a value to the set. Returns true if the set did not already contain the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.list.append(val)</span><br><span class="line">            self.dict[val] = len(self.list) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Removes a value from the set. Returns true if the set contained the specified element.</span></span><br><span class="line"><span class="string">        :type val: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">in</span> self.dict:</span><br><span class="line">            index, lastVal = self.dict[val], self.list[len(self.list) - <span class="number">1</span>]</span><br><span class="line">            self.list[index], self.dict[lastVal] = lastVal, index</span><br><span class="line">            self.list.pop()</span><br><span class="line">            self.dict.pop(val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getRandom</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Get a random element from the set.</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> self.list[random.randint(<span class="number">0</span>, len(self.list) - <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Your RandomizedSet object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># obj = RandomizedSet()</span></span><br><span class="line"><span class="comment"># param_1 = obj.insert(val)</span></span><br><span class="line"><span class="comment"># param_2 = obj.remove(val)</span></span><br><span class="line"><span class="comment"># param_3 = obj.getRandom()</span></span><br></pre></td></tr></table></figure></p>
<p>总结：可能是用 python 的原因，搞明白问什么了一次过</p>
<h3 id="LinC-960-First-Unique-Number-in-a-Stream-II-Medium"><a href="#LinC-960-First-Unique-Number-in-a-Stream-II-Medium" class="headerlink" title="LinC 960. First Unique Number in a Stream II (Medium)"></a><a href="960. First Unique Number in a Stream II">LinC 960. First Unique Number in a Stream II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Description</span><br><span class="line">We need to implement a data structure named DataStream. There are two methods required to be implemented:</span><br><span class="line"></span><br><span class="line">void add(number) // add a new number</span><br><span class="line">int firstUnique() // return first unique number</span><br><span class="line">You can assume that there must be at least one unique number in the stream when calling the firstUnique.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">add(1)</span><br><span class="line">add(2)</span><br><span class="line">firstUnique() =&gt; 1</span><br><span class="line">add(1)</span><br><span class="line">firstUnique() =&gt; 2</span><br></pre></td></tr></table></figure>
<p>思路：维持一个 deque / queue，碰到相同的就 popleft 出去<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataStream</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.q = collections.deque()</span><br><span class="line">        self.dict = &#123;&#125;</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param num: next number in stream</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">if</span> num <span class="keyword">in</span> self.dict:</span><br><span class="line">            self.dict[num] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.dict[num] = <span class="number">1</span></span><br><span class="line">            self.q.append(num)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @return: the first unique number in stream</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstUnique</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">while</span> len(self.q) &gt; <span class="number">0</span> <span class="keyword">and</span> self.dict[self.q[<span class="number">0</span>]] &gt; <span class="number">1</span>:</span><br><span class="line">                self.q.popleft()</span><br><span class="line">        <span class="keyword">return</span> self.q[<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：1.popleft 要在 firstUnique 里面，不然有些 testcase 过不了；2.注意 popleft 的条件要用 while， 用 for 会出错</p>
<h2 id="Heap-Priority-Queue"><a href="#Heap-Priority-Queue" class="headerlink" title="Heap (Priority Queue)"></a>Heap (Priority Queue)</h2><h3 id="264-Ugly-Number-II-Medium"><a href="#264-Ugly-Number-II-Medium" class="headerlink" title="264. Ugly Number II (Medium)"></a><a href="https://leetcode.com/problems/ugly-number-ii/description/" target="_blank" rel="noopener">264. Ugly Number II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Write a program to find the n-th ugly number.</span><br><span class="line"></span><br><span class="line">Ugly numbers are positive numbers whose prime factors only include 2, 3, 5.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input: n = 10</span><br><span class="line">Output: 12</span><br><span class="line">Explanation: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 is the sequence of the first 10 ugly numbers.</span><br><span class="line">Note:  </span><br><span class="line"></span><br><span class="line">1 is typically treated as an ugly number.</span><br><span class="line">n does not exceed 1690.</span><br></pre></td></tr></table></figure>
<p>思路：九章的 python 答案可以 work，但是实在是不好理解。写个好理解一点的版本。heapq 和 hashMap, 从 heapq 中取 n - 1 次（第一个数为 1），每取一次将原始 ugly numbers 2, 3, 5 过一遍<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        primes = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        q = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">        hashMap = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            hashMap[q[i]] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        ans = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n - <span class="number">1</span>):</span><br><span class="line">            ans = heapq.heappop(q)</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                new_val = ans * primes[j]</span><br><span class="line">                <span class="keyword">if</span> new_val <span class="keyword">not</span> <span class="keyword">in</span> hashMap:</span><br><span class="line">                    heapq.heappush(q, new_val)</span><br><span class="line">                    hashMap[new_val] = <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：可以 AC，也可以理解，good enough</p>
<h3 id="LinC-612-K-Closest-Points-Medium"><a href="#LinC-612-K-Closest-Points-Medium" class="headerlink" title="LinC 612. K Closest Points (Medium)"></a><a href="https://www.lintcode.com/problem/k-closest-points/description" target="_blank" rel="noopener">LinC 612. K Closest Points (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Given some points and a point origin in two dimensional space, find k points out of the some points which are nearest to origin.</span><br><span class="line">Return these points sorted by distance, if they are same with distance, sorted by x-axis, otherwise sorted by y-axis.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given points = [[4,6],[4,7],[4,4],[2,5],[1,1]], origin = [0, 0], k = 3</span><br><span class="line">return [[1,1],[2,5],[4,4]]</span><br></pre></td></tr></table></figure>
<p>思路：看了下答案，比较可理解的方法是用一个 heapq 存 distance 的 <strong> 2 的负值，这样 &gt; K 以后就开始 pop（最小值就是最远的点）, 所有点过完一遍以后将 heapq 里的点都 pop 出来然后 reverse 就是从小到大的顺序了，需要写一个 class PointDis 里面有 <strong>init</strong> 和 <strong>lt</strong> 正常写。 getDis() 返回 distance 的 </strong> 2 负值<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition for a point.</span></span><br><span class="line"><span class="string">class Point:</span></span><br><span class="line"><span class="string">    def __init__(self, a=0, b=0):</span></span><br><span class="line"><span class="string">        self.x = a</span></span><br><span class="line"><span class="string">        self.y = bDefinition for a point.</span></span><br><span class="line"><span class="string">class Point:</span></span><br><span class="line"><span class="string">    def __init__(self, a=0, b=0):</span></span><br><span class="line"><span class="string">        self.x = a</span></span><br><span class="line"><span class="string">        self.y = b</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PointDis</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, dist, point)</span>:</span></span><br><span class="line">        self.dist = dist</span><br><span class="line">        self.point = point</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.dist != other.dist:</span><br><span class="line">            <span class="keyword">return</span> self.dist &lt; other.dist</span><br><span class="line">        <span class="keyword">if</span> self.point.x != other.point.x:</span><br><span class="line">            <span class="keyword">return</span> self.point.x &gt; other.point.x</span><br><span class="line">        <span class="keyword">return</span> self.point.y &gt; other.point.y</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param points: a list of points</span></span><br><span class="line"><span class="string">    @param origin: a point</span></span><br><span class="line"><span class="string">    @param k: An integer</span></span><br><span class="line"><span class="string">    @return: the k closest points</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kClosest</span><span class="params">(self, points, origin, k)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        q = []</span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heapify(q)</span><br><span class="line">        <span class="keyword">for</span> point <span class="keyword">in</span> points:</span><br><span class="line">            negD2 = self.getNegDis2(point, origin)</span><br><span class="line">            heapq.heappush(q, PointDis(negD2, point))</span><br><span class="line">            <span class="keyword">if</span> len(q) &gt; k:</span><br><span class="line">                heapq.heappop(q)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(k):</span><br><span class="line">            ans.append(heapq.heappop(q).point)</span><br><span class="line">        ans.reverse()</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getNegDis2</span><span class="params">(self, point, origin)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> - (point.x - origin.x) ** <span class="number">2</span> - (point.y - origin.y) **<span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>总结：有个地方要注意， 当 dist 用的是距离平方的负数来比较产生 max heap 的时候，如果距离相等时比 x 和 x 相等时比 y 的 &lt; 符号就要反过来了。 看着还是很别扭的。 name dist 用距离平方的负数还不如就直接用距离的平方然后把 PointDis class 里比方向距离的 &lt; 符号反一下。不过已经 AC 了就不改了。</p>
<h3 id="LinC-545-Top-k-Largest-Numbers-II-Medium"><a href="#LinC-545-Top-k-Largest-Numbers-II-Medium" class="headerlink" title="LinC 545. Top k Largest Numbers II (Medium)"></a><a href="https://www.lintcode.com/problem/top-k-largest-numbers-ii/description" target="_blank" rel="noopener">LinC 545. Top k Largest Numbers II (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Implement a data structure, provide two interfaces:</span><br><span class="line">add(number). Add a new number in the data structure.</span><br><span class="line">topk(). Return the top k largest numbers in this data structure. k is given when we create the data structure.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">s = new Solution(3);</span><br><span class="line">&gt;&gt; create a new data structure.</span><br><span class="line">s.add(3)</span><br><span class="line">s.add(10)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [10, 3]</span><br><span class="line">s.add(1000)</span><br><span class="line">s.add(-99)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [1000, 10, 3]</span><br><span class="line">s.add(4)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [1000, 10, 4]</span><br><span class="line">s.add(100)</span><br><span class="line">s.topk()</span><br><span class="line">&gt;&gt; return [1000, 100, 10]</span><br></pre></td></tr></table></figure>
<p>思路：看着是非常直观的 min heap 问题。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: k: An integer</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        <span class="comment"># do intialization if necessary</span></span><br><span class="line">        self.k = k</span><br><span class="line">        self.q = []</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param: num: Number to be added</span></span><br><span class="line"><span class="string">    @return: nothing</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, num)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        heapq.heappush(self.q, num)</span><br><span class="line">        <span class="keyword">if</span> len(self.q) &gt; self.k:</span><br><span class="line">            heapq.heappop(self.q)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @return: Top k element</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">return</span> sorted(self.q, reverse = <span class="keyword">True</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：一句 sorted(self.q, reverse = True) 完爆。。。哎， python 的 buit-in function 返回一个 sorted new list…学习了。</p>
<h3 id="LinC-486-Merge-K-Sorted-Arrays-Medium"><a href="#LinC-486-Merge-K-Sorted-Arrays-Medium" class="headerlink" title="LinC 486. Merge K Sorted Arrays (Medium)"></a><a href="#lintcode-486">LinC 486. Merge K Sorted Arrays (Medium)</a></h3><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h2><h3 id="LinC-6-Merge-Two-Sorted-Arrays-Easy"><a href="#LinC-6-Merge-Two-Sorted-Arrays-Easy" class="headerlink" title="LinC 6. Merge Two Sorted Arrays (Easy)"></a><a href="https://www.lintcode.com/problem/merge-two-sorted-arrays/description" target="_blank" rel="noopener">LinC 6. Merge Two Sorted Arrays (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Merge two given sorted integer array A and B into a new sorted integer array.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">A=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">B=[2,4,5,6]</span><br><span class="line"></span><br><span class="line">return [1,2,2,3,4,4,5,6]</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">How can you optimize your algorithm if one array is very large and the other is very small?</span><br></pre></td></tr></table></figure>
<p>思路：热身题，直接做<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param A: sorted integer array A</span></span><br><span class="line"><span class="string">    @param B: sorted integer array B</span></span><br><span class="line"><span class="string">    @return: A new sorted integer array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeSortedArray</span><span class="params">(self, A, B)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        ans = []</span><br><span class="line">        indexA = <span class="number">0</span></span><br><span class="line">        indexB = <span class="number">0</span></span><br><span class="line">        indexC = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> indexC &lt; len(A) + len(B):</span><br><span class="line">            <span class="keyword">if</span> indexA == len(A) <span class="keyword">or</span> indexB == len(B):</span><br><span class="line">                <span class="keyword">if</span> indexA == len(A):</span><br><span class="line">                    ans.append(B[indexB])</span><br><span class="line">                    indexB += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append(A[indexA])</span><br><span class="line">                    indexA += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> A[indexA] &lt; B[indexB]:</span><br><span class="line">                    ans.append(A[indexA])</span><br><span class="line">                    indexA += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    ans.append(B[indexB])</span><br><span class="line">                    indexB += <span class="number">1</span></span><br><span class="line">            indexC += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：非常值得刷的一道热身题， 需要考虑两个 array 越界的问题。看了下答案用三个 while 循环也可以。</p>
<h3 id="88-Merge-Sorted-Array-Easy"><a href="#88-Merge-Sorted-Array-Easy" class="headerlink" title="88. Merge Sorted Array (Easy)"></a><a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">88. Merge Sorted Array (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">The number of elements initialized in nums1 and nums2 are m and n respectively.</span><br><span class="line">You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Input:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">Output: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure>
<p>思路：直觉上想不太出来怎么不创建新的存储空间把小数组 merge 到大数组里。看了答案，如果 nums1 后面空着这么些空，就从后面开始填。哎，曾经是能自主想的出的。。。正着困难的话就反着试试<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(nums1) == len(nums2):</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums2)):</span><br><span class="line">                nums1[i] = nums2[i]</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        index1 = m - <span class="number">1</span></span><br><span class="line">        index2 = n - <span class="number">1</span></span><br><span class="line">        index3 = len(nums1) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> index3 &gt;= <span class="number">0</span> <span class="keyword">and</span> index2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> index1 &lt; <span class="number">0</span>:</span><br><span class="line">                nums1[index3] = nums2[index2]</span><br><span class="line">                index2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums1[index1] &lt; nums2[index2]:</span><br><span class="line">                    nums1[index3] = nums2[index2]</span><br><span class="line">                    index2 -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    nums1[index3] = nums1[index1]</span><br><span class="line">                    index1 -= <span class="number">1</span></span><br><span class="line">            index3 -= <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>总结：虽然是 easy 题，要考虑情况：1.nums1 和 nums2 一样大的话需要逐个考过去；2.index2 如果走到最前面就可以结束了。注意题目的输入包含了 m 和 n 要利用好</p>
<h3 id="LinC-839-Merge-Two-Sorted-Interval-Lists-Easy"><a href="#LinC-839-Merge-Two-Sorted-Interval-Lists-Easy" class="headerlink" title="LinC 839. Merge Two Sorted Interval Lists (Easy)"></a><a href="https://www.lintcode.com/problem/merge-two-sorted-interval-lists/description" target="_blank" rel="noopener">LinC 839. Merge Two Sorted Interval Lists (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Merge two sorted (ascending) lists of interval and return it as a new sorted list. The new sorted list should be made by splicing together the intervals of the two lists and sorted in ascending order.</span><br><span class="line"></span><br><span class="line">The intervals in the given list do not overlap.</span><br><span class="line">The intervals in different lists may overlap.</span><br><span class="line">Example</span><br><span class="line">Given list1 = [(1,2),(3,4)] and list2 = [(2,3),(5,6)], return [(1,4),(5,6)].</span><br></pre></td></tr></table></figure>
<p>思路：非常不擅长的提醒，todo 需要寻找并练习这类题。看了答案以后明白 merge 函数只需要判断 res 的最后一个区间的 end 是否 &gt;= 被 merge interval 的 start, 是的话就将该 end 设为 max(该 end, interval 的 end)， 否的话直接 res.append(interval)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Definition of Interval.</span></span><br><span class="line"><span class="string">class Interval(object):</span></span><br><span class="line"><span class="string">    def __init__(self, start, end):</span></span><br><span class="line"><span class="string">        self.start = start</span></span><br><span class="line"><span class="string">        self.end = end</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param list1: one of the given list</span></span><br><span class="line"><span class="string">    @param list2: another list</span></span><br><span class="line"><span class="string">    @return: the new sorted list of interval</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTwoInterval</span><span class="params">(self, list1, list2)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        index1, index2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> index1 &lt; len(list1) <span class="keyword">or</span> index2 &lt; len(list2):</span><br><span class="line">            <span class="keyword">if</span> index1 == len(list1):</span><br><span class="line">                self.merge(ans, list2[index2])</span><br><span class="line">                index2 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> index2 == len(list2):</span><br><span class="line">                self.merge(ans, list1[index1])</span><br><span class="line">                index1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> list1[index1].start &lt; list2[index2].start:</span><br><span class="line">                self.merge(ans, list1[index1])</span><br><span class="line">                index1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.merge(ans, list2[index2])</span><br><span class="line">                index2 += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, ans, interval)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> ans:</span><br><span class="line">            ans.append(interval)</span><br><span class="line">        <span class="keyword">elif</span> ans[<span class="number">-1</span>].end &gt;= interval.start:</span><br><span class="line">            ans[<span class="number">-1</span>].end = max(ans[<span class="number">-1</span>].end, interval.end)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ans.append(interval)</span><br></pre></td></tr></table></figure></p>
<p>总结：懂的将早开始的先送进 ans，merge 的时候只需要判断 ans 最后一个的 end 是否 &gt;= interval.start 这个核心算法比较重要。</p>
<h3 id="LinC-486-Merge-K-Sorted-Arrays-Medium-1"><a href="#LinC-486-Merge-K-Sorted-Arrays-Medium-1" class="headerlink" title="LinC 486. Merge K Sorted Arrays (Medium)"></a><a href="https://www.lintcode.com/problem/merge-k-sorted-arrays/description" target="_blank" rel="noopener">LinC 486. Merge K Sorted Arrays (Medium)</a><a id="lintcode-486"></a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Given k sorted integer arrays, merge them into one sorted array.</span><br><span class="line"></span><br><span class="line">Example</span><br><span class="line">Given 3 sorted arrays:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1, 3, 5, 7],</span><br><span class="line">  [2, 4, 6],</span><br><span class="line">  [0, 8, 9, 10, 11]</span><br><span class="line">]</span><br><span class="line">return [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line">Do it in O(N log k).</span><br><span class="line"></span><br><span class="line">N is the total number of integers.</span><br><span class="line">k is the number of arrays.</span><br></pre></td></tr></table></figure>
<p>思路：看答案，用 heap 屌爆了。加了链接到上面 heap 的部分<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    @param arrays: k sorted integer arrays</span></span><br><span class="line"><span class="string">    @return: a sorted array</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergekSortedArrays</span><span class="params">(self, arrays)</span>:</span></span><br><span class="line">        <span class="comment"># write your code here</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        q = []</span><br><span class="line">        <span class="keyword">for</span> level, array <span class="keyword">in</span> enumerate(arrays):</span><br><span class="line">            <span class="keyword">if</span> len(array) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            heapq.heappush(q, (array[<span class="number">0</span>], level, <span class="number">0</span>))</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            cur, level, index = heapq.heappop(q)</span><br><span class="line">            ans.append(cur)</span><br><span class="line">            <span class="keyword">if</span> index + <span class="number">1</span> &lt; len(arrays[level]):</span><br><span class="line">                heapq.heappush(q, (arrays[level][index + <span class="number">1</span>], level, index + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：只能说 python 的 heapq 屌爆了</p>
<h3 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/" target="_blank" rel="noopener">121. Best Time to Buy and Sell Stock (Easy)</a><a id="leetcode-121"></a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Say you have an array for which the ith element is the price of a given stock on day i.</span><br><span class="line"></span><br><span class="line">If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.</span><br><span class="line"></span><br><span class="line">Note that you cannot sell a stock before you buy one.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line">Input: [7,1,5,3,6,4]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</span><br><span class="line">             Not 7-1 = 6, as selling price needs to be larger than buying price.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [7,6,4,3,1]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: In this case, no transaction is done, i.e. max profit = 0.</span><br></pre></td></tr></table></figure>
<p>思路：寻找左边值比右边值小的最大的差值，感觉是双指针问题，看了九章的答案，比较不直观<br>二刷：DP, f 为目前为止的最大收益，f[i] = f[i - 1] 如果 f[i] &lt; f[i - 1] else: f[i] = prices[i] - lowest,  初始均为 0， lowest 初始为 f[0], 遍历最后更新 lowest<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        low, ans = sys.maxint, <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            <span class="keyword">if</span> price &lt; low:</span><br><span class="line">                low = price</span><br><span class="line">            <span class="keyword">if</span> price - low &gt; ans:</span><br><span class="line">                ans = price - low</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二刷 DP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span><span class="params">(self, prices)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type prices: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(prices) &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        f = []</span><br><span class="line">        n = len(prices)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            f.append(<span class="number">0</span>)</span><br><span class="line">        lowest = prices[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> prices[i] &lt; prices[i - <span class="number">1</span>]:</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                f[i] = max(prices[i] - lowest, f[i - <span class="number">1</span>])</span><br><span class="line">            lowest = min(lowest, prices[i])</span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure></p>
<p>总结：不能 sort 这个数组，双指针好像也不太好使。看了答案得用比较土的办法 sys.maxint; 或者用 dp；dp 单独找个时间再刷吧<br>二刷：看来还是要保存最低点，返回 f[n - 1], 注意：1. 检查输入为空；2. 计算 f[i] 时要判断 prices[i] 和 prices[i - 1] 的关系</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><h3 id="208-Implement-Trie-Prefix-Tree-Medium"><a href="#208-Implement-Trie-Prefix-Tree-Medium" class="headerlink" title="208. Implement Trie (Prefix Tree) (Medium)"></a><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/" target="_blank" rel="noopener">208. Implement Trie (Prefix Tree) (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Implement a trie with insert, search, and startsWith methods.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Trie trie = new Trie();</span><br><span class="line"></span><br><span class="line">trie.insert("apple");</span><br><span class="line">trie.search("apple");   // returns true</span><br><span class="line">trie.search("app");     // returns false</span><br><span class="line">trie.startsWith("app"); // returns true</span><br><span class="line">trie.insert("app");   </span><br><span class="line">trie.search("app");     // returns true</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">You may assume that all inputs are consist of lowercase letters a-z.</span><br><span class="line">All inputs are guaranteed to be non-empty strings.</span><br></pre></td></tr></table></figure>
<p>思路：没啥思路，看答案<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span>:</span></span><br><span class="line">    <span class="comment"># Initialize your data structure here.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.word=<span class="keyword">False</span></span><br><span class="line">        self.children=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.root = TrieNode()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; word</span></span><br><span class="line">    <span class="comment"># @return &#123;void&#125;</span></span><br><span class="line">    <span class="comment"># Inserts a word into the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        node=self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                node.children[i]=TrieNode()</span><br><span class="line">            node=node.children[i]</span><br><span class="line">        node.word=<span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; word</span></span><br><span class="line">    <span class="comment"># @return &#123;boolean&#125;</span></span><br><span class="line">    <span class="comment"># Returns if the word is in the trie.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, word)</span>:</span></span><br><span class="line">        node=self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> word:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            node=node.children[i]</span><br><span class="line">        <span class="keyword">return</span> node.word</span><br><span class="line"></span><br><span class="line">    <span class="comment"># @param &#123;string&#125; prefix</span></span><br><span class="line">    <span class="comment"># @return &#123;boolean&#125;</span></span><br><span class="line">    <span class="comment"># Returns if there is any word in the trie</span></span><br><span class="line">    <span class="comment"># that starts with the given prefix.</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">startsWith</span><span class="params">(self, prefix)</span>:</span></span><br><span class="line">        node=self.root</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> prefix:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> node.children:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            node=node.children[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Your Trie object will be instantiated and called as such:</span></span><br><span class="line">    <span class="comment"># obj = Trie()</span></span><br><span class="line">    <span class="comment"># obj.insert(word)</span></span><br><span class="line">    <span class="comment"># param_2 = obj.search(word)</span></span><br><span class="line">    <span class="comment"># param_3 = obj.startsWith(prefix)</span></span><br></pre></td></tr></table></figure></p>
<p>总结：1.需要加 TrieNode 2. Leetcode 的 python3 找不到 class 是个 bug</p>
<h1 id="Bit-Manipulation"><a href="#Bit-Manipulation" class="headerlink" title="Bit Manipulation"></a>Bit Manipulation</h1><h3 id="231-Power-of-Two-Easy"><a href="#231-Power-of-Two-Easy" class="headerlink" title="231. Power of Two (Easy)"></a><a href="https://leetcode.com/problems/power-of-two/description/" target="_blank" rel="noopener">231. Power of Two (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Given an integer, write a function to determine if it is a power of two.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 1</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 2^0 = 1</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 16</span><br><span class="line">Output: true</span><br><span class="line">Explanation: 2^4 = 16</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: 218</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>
<p>思路：既然是 bit manipulation 的题，肯定是变成 bits 操作，稍微看一下 2 的倍数都是 1 后面全是 0。怎么用 python 检查这个比较没思路。。。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPowerOfTwo</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> bin(n)[<span class="number">2</span>:] == <span class="string">'1'</span>.ljust(len(bin(n)) - <span class="number">2</span>, <span class="string">'0'</span>)</span><br></pre></td></tr></table></figure></p>
<p>总结：看了三年前比较屌的 trick 是 return n &amp; n - 1, 当然 bin 这种土办法也 OK 的。</p>
<h1 id="DP-Dynamic-Programming-动态规划"><a href="#DP-Dynamic-Programming-动态规划" class="headerlink" title="DP Dynamic Programming 动态规划"></a>DP Dynamic Programming 动态规划</h1><p>题型多为： 1. 求最大值或者最小值 2. 判断方案是否可行 3. 统计方案的个数<br>DP 四要素：1. 状态 state，也就是f[i]或者f[i][j]的物理意义是什么 2. 方程 function，也就是f[i]和f[i - 1]的关系 3. 初始化 initialization，这个方程涉及2个相邻state所以对于state 0肯定是需要初始化的 4. 答案 最大的状态是什么？规划的重点是什么？</p>
<h3 id="70-Climbing-Stairs-Easy"><a href="#70-Climbing-Stairs-Easy" class="headerlink" title="70. Climbing Stairs (Easy)"></a><a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">70. Climbing Stairs (Easy)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">You are climbing a stair case. It takes n steps to reach to the top.</span><br><span class="line"></span><br><span class="line">Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</span><br><span class="line"></span><br><span class="line">Note: Given n will be a positive integer.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure>
<p>思路：f[n] 是为 n 时的方案数，f[1] 是为 1 时的方案数 = 1。<strong>那么爬到第n层的方法要么是从第n-1层一步上来的，要不就是从n-2层2步上来的</strong>，所以递推公式非常容易的就得出了：f[n] = f[n - 1] + f[n - 2]<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">climbStairs</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> n</span><br><span class="line">        f = [<span class="number">0</span>] * (n + <span class="number">1</span>)</span><br><span class="line">        f[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        f[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> f[n]</span><br></pre></td></tr></table></figure></p>
<p>总结：和三年前比没有变化，呵呵呵</p>
<h3 id="120-Triangle-Medium"><a href="#120-Triangle-Medium" class="headerlink" title="120. Triangle (Medium)"></a><a href="https://leetcode.com/problems/triangle/description/" target="_blank" rel="noopener">120. Triangle (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</span><br><span class="line"></span><br><span class="line">For example, given the following triangle</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br><span class="line">The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).</span><br><span class="line"></span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle.</span><br></pre></td></tr></table></figure>
<p>思路：看了 top down 的 DP， 还是比较好理解的。f 代表到达 row 和 col 位置的最小 sum，f[i][j] 和 f[i - 1][j - 1] 的关系是：f[i][j] = mins(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j]. 规划的目标是最后一行中的最小值。；DP 以外还有三种解法，DFS：Traverse， DFS：Divide and Conquer， DFS：Divide and Conquer 加 memorization todo 估计也不会刷 DFS 了， Divide and Conquer 有点可能性吧<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span><span class="params">(self, triangle)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type triangle: List[List[int]]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(triangle) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> len(triangle) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">        f = []</span><br><span class="line">        f.append([triangle[<span class="number">0</span>][<span class="number">0</span>]])</span><br><span class="line">        n = len(triangle)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            f.append([<span class="number">0</span>] * (i + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            f[i][<span class="number">0</span>] = f[i - <span class="number">1</span>][<span class="number">0</span>] + triangle[i][<span class="number">0</span>]</span><br><span class="line">            f[i][i] = f[i - <span class="number">1</span>][i - <span class="number">1</span>] + triangle[i][i]</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> range(<span class="number">1</span>, row):</span><br><span class="line">                f[row][col] = min(f[row - <span class="number">1</span>][col - <span class="number">1</span>], f[row - <span class="number">1</span>][col]) + triangle[row][col]</span><br><span class="line">        ans = f[n - <span class="number">1</span>][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            ans = min(ans, f[n - <span class="number">1</span>][i])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure></p>
<p>总结：填充 f 每行第一个和最后一个的时候别忘了 + triangle[i][0] 和 triangle[i][i]</p>
<h3 id="409-Longest-Palindrome-Easy-1"><a href="#409-Longest-Palindrome-Easy-1" class="headerlink" title="409. Longest Palindrome (Easy)"></a><a href="#leetcode-409">409. Longest Palindrome (Easy)</a></h3><h3 id="121-Best-Time-to-Buy-and-Sell-Stock-Easy-1"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy-1" class="headerlink" title="121. Best Time to Buy and Sell Stock (Easy)"></a><a href="#leetcode-121">121. Best Time to Buy and Sell Stock (Easy)</a></h3><h1 id="skipped"><a href="#skipped" class="headerlink" title="skipped"></a>skipped</h1><h2 id="Binary-Tree-amp-Divide-and-Conquer-分治"><a href="#Binary-Tree-amp-Divide-and-Conquer-分治" class="headerlink" title="Binary Tree &amp; Divide and Conquer 分治"></a>Binary Tree &amp; Divide and Conquer 分治</h2><p><a href="https://stomachache007.wordpress.com/2017/03/12/%E4%B9%9D%E7%AB%A0%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0-3-binary-tree-divide-conquer/" target="_blank" rel="noopener">九章曾经有个专题是这个</a>，可以看一下，把常见的题型刷一刷。</p>
<h3 id="98-Validate-Binary-Search-Tree-Medium-1"><a href="#98-Validate-Binary-Search-Tree-Medium-1" class="headerlink" title="98. Validate Binary Search Tree (Medium)"></a>98. Validate Binary Search Tree (Medium)</h3><h3 id="94-Binary-Tree-Inorder-Traversal-Medium-1"><a href="#94-Binary-Tree-Inorder-Traversal-Medium-1" class="headerlink" title="94. Binary Tree Inorder Traversal (Medium)"></a>94. Binary Tree Inorder Traversal (Medium)</h3><h3 id="120-Triangle-Medium-1"><a href="#120-Triangle-Medium-1" class="headerlink" title="120. Triangle (Medium)"></a><a href="https://leetcode.com/problems/triangle/description/" target="_blank" rel="noopener">120. Triangle (Medium)</a></h3><h3 id="LinC-649-Binary-Tree-Upside-Down-Medium"><a href="#LinC-649-Binary-Tree-Upside-Down-Medium" class="headerlink" title="LinC 649. Binary Tree Upside Down (Medium)"></a><a href="https://lintcode.com/problem/binary-tree-upside-down/description" target="_blank" rel="noopener">LinC 649. Binary Tree Upside Down (Medium)</a></h3><p>Leetcode 156. Binary Tree Upside Down 加锁了。可能是我傻逼，也可能是题傻逼。浪费了很多时间，网上非递归的答案都不能 AC。一气之下给挪到 skipped 的部分了。 等有高人指导了再研究下。</p>
<h2 id="DP-Dynamic-Programming-动态规划-1"><a href="#DP-Dynamic-Programming-动态规划-1" class="headerlink" title="DP Dynamic Programming 动态规划"></a>DP Dynamic Programming 动态规划</h2><h3 id="Best-Time-to-Buy-and-Sell-Stock-II-amp-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-II-amp-III" class="headerlink" title="Best Time to Buy and Sell Stock II &amp; III"></a>Best Time to Buy and Sell Stock II &amp; III</h3><h3 id="53-Maximum-Subarray-Easy"><a href="#53-Maximum-Subarray-Easy" class="headerlink" title="53. Maximum Subarray (Easy)"></a><a href="https://leetcode.com/problems/maximum-subarray/description/" target="_blank" rel="noopener">53. Maximum Subarray (Easy)</a></h3><h3 id="Minimum-Path-Sum"><a href="#Minimum-Path-Sum" class="headerlink" title="Minimum Path Sum"></a>Minimum Path Sum</h3><h3 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h3><h3 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h3><h3 id="Word-Break"><a href="#Word-Break" class="headerlink" title="Word Break"></a>Word Break</h3><h3 id="Longest-Common-Subsequence"><a href="#Longest-Common-Subsequence" class="headerlink" title="Longest Common Subsequence"></a>Longest Common Subsequence</h3><h3 id="44-Wildcard-Matching-Hard"><a href="#44-Wildcard-Matching-Hard" class="headerlink" title="44. Wildcard Matching (Hard)"></a><a href="https://leetcode.com/problems/wildcard-matching/description/" target="_blank" rel="noopener">44. Wildcard Matching (Hard)</a></h3><p>也可以用 DFS, 双指针解</p>
<h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><h3 id="240-Search-a-2D-Matrix-II-Medium"><a href="#240-Search-a-2D-Matrix-II-Medium" class="headerlink" title="240. Search a 2D Matrix II (Medium)"></a><a href="https://leetcode.com/problems/search-a-2d-matrix-ii/description/" target="_blank" rel="noopener">240. Search a 2D Matrix II (Medium)</a></h3><p><a href="http://www.lintcode.com/en/problem/search-a-2d-matrix-ii/" target="_blank" rel="noopener">LinC Search a 2D Matrix II</a><br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</span><br><span class="line"></span><br><span class="line">Integers in each row are sorted in ascending from left to right.</span><br><span class="line">Integers in each column are sorted in ascending from top to bottom.</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">Consider the following matrix:</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,   4,  7, 11, 15],</span><br><span class="line">  [2,   5,  8, 12, 19],</span><br><span class="line">  [3,   6,  9, 16, 22],</span><br><span class="line">  [10, 13, 14, 17, 24],</span><br><span class="line">  [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">Given target = 5, return true.</span><br><span class="line"></span><br><span class="line">Given target = 20, return false.</span><br></pre></td></tr></table></figure></p>
<p>思路：感觉还是 binary search 吧，虽然九章说是 two pointers<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Bit-Manipulation-1"><a href="#Bit-Manipulation-1" class="headerlink" title="Bit Manipulation"></a>Bit Manipulation</h2><h3 id="29-Divide-Two-Integers-Medium"><a href="#29-Divide-Two-Integers-Medium" class="headerlink" title="29. Divide Two Integers (Medium)"></a><a href="https://leetcode.com/problems/divide-two-integers/description/" target="_blank" rel="noopener">29. Divide Two Integers (Medium)</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator.</span><br><span class="line"></span><br><span class="line">Return the quotient after dividing dividend by divisor.</span><br><span class="line"></span><br><span class="line">The integer division should truncate toward zero.</span><br><span class="line"></span><br><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: dividend = 10, divisor = 3</span><br><span class="line">Output: 3</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: dividend = 7, divisor = -3</span><br><span class="line">Output: -2</span><br><span class="line">Note:</span><br><span class="line"></span><br><span class="line">Both dividend and divisor will be 32-bit signed integers.</span><br><span class="line">The divisor will never be 0.</span><br><span class="line">Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. For the purpose of this problem, assume that your function returns 2^31 − 1 when the division result overflows.</span><br></pre></td></tr></table></figure>
<p>思路：算法还是略妖的。先把除数位移放大到比被除数大，然后将这个数一步步位移缩小，并且用被除数的绝对值减这个数直到被除数的绝对值小于除数为止 ans += level<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(self, dividend, divisor)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type dividend: int</span></span><br><span class="line"><span class="string">        :type divisor: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        """</span></span><br></pre></td></tr></table></figure></p>
<p>总结：</p>
<h2 id="Trie-1"><a href="#Trie-1" class="headerlink" title="Trie"></a>Trie</h2><h3 id="211-Add-and-Search-Word-Data-structure-design-Medium"><a href="#211-Add-and-Search-Word-Data-structure-design-Medium" class="headerlink" title="211. Add and Search Word - Data structure design (Medium)"></a><a href="https://leetcode.com/problems/add-and-search-word-data-structure-design/description/" target="_blank" rel="noopener">211. Add and Search Word - Data structure design (Medium)</a></h3><p>Trie 和 DFS 组合题</p>
<h2 id="Two-pointers-1"><a href="#Two-pointers-1" class="headerlink" title="Two pointers"></a>Two pointers</h2><h3 id="LinC-Sort-Colors-II-medium"><a href="#LinC-Sort-Colors-II-medium" class="headerlink" title="LinC Sort Colors II (medium)"></a><a href="https://www.lintcode.com/problem/sort-colors-ii/description" target="_blank" rel="noopener">LinC Sort Colors II (medium)</a></h3><p>快排：<a href="https://github.com/awangdev/LintCode/blob/master/Java/Sort%20Colors%20II.java" target="_blank" rel="noopener">https://github.com/awangdev/LintCode/blob/master/Java/Sort%20Colors%20II.java</a> 桶排：<a href="https://www.cnblogs.com/yuzhangcmu/p/4177326.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuzhangcmu/p/4177326.html</a></p>
<h3 id="Interleaving-Positive-and-Negative-Numbers-Medium"><a href="#Interleaving-Positive-and-Negative-Numbers-Medium" class="headerlink" title="Interleaving Positive and Negative Numbers (Medium)"></a><a href="http://www.lintcode.com/problem/interleaving-positive-and-negative-numbers/" target="_blank" rel="noopener">Interleaving Positive and Negative Numbers (Medium)</a></h3><h3 id="Sort-Letters-by-Case-Medium"><a href="#Sort-Letters-by-Case-Medium" class="headerlink" title="Sort Letters by Case (Medium)"></a><a href="http://www.lintcode.com/problem/sort-letters-by-case/" target="_blank" rel="noopener">Sort Letters by Case (Medium)</a></h3><h3 id="600-Smallest-Rectangle-Enclosing-Black-Pixels-Hard"><a href="#600-Smallest-Rectangle-Enclosing-Black-Pixels-Hard" class="headerlink" title="600. Smallest Rectangle Enclosing Black Pixels (Hard)"></a><a href="https://www.lintcode.com/problem/smallest-rectangle-enclosing-black-pixels/description" target="_blank" rel="noopener">600. Smallest Rectangle Enclosing Black Pixels (Hard)</a></h3><h2 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h2><h3 id="577-Merge-K-Sorted-Interval-Lists-Medium"><a href="#577-Merge-K-Sorted-Interval-Lists-Medium" class="headerlink" title="577. Merge K Sorted Interval Lists (Medium)"></a><a href="https://www.lintcode.com/problem/merge-k-sorted-interval-lists/description" target="_blank" rel="noopener">577. Merge K Sorted Interval Lists (Medium)</a></h3><h3 id="347-Top-K-Frequent-Elements-Medium"><a href="#347-Top-K-Frequent-Elements-Medium" class="headerlink" title="347. Top K Frequent Elements (Medium)"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="noopener">347. Top K Frequent Elements (Medium)</a></h3><p>related:<br>• <a href="http://www.lintcode.com/problem/top-k-largest-numbers/" target="_blank" rel="noopener">http://www.lintcode.com/problem/top-k-largest-numbers/</a><br>• <a href="http://www.lintcode.com/problem/kth-smallest-number-in-sorted-matrix/" target="_blank" rel="noopener">http://www.lintcode.com/problem/kth-smallest-number-in-sorted-matrix/</a></p>
<h3 id="23-Merge-k-Sorted-Lists-Hard"><a href="#23-Merge-k-Sorted-Lists-Hard" class="headerlink" title="23. Merge k Sorted Lists (Hard)"></a><a href="https://leetcode.com/problems/merge-k-sorted-lists/description/" target="_blank" rel="noopener">23. Merge k Sorted Lists (Hard)</a></h3><p>三种方法，都需要练习. 方法一:使用 PriorityQueue 方法二:类似归并排序的分治算法 方法三:自底向上的两两归并算法. 时间复杂度均为 O(NlogK) Strong Hire: 能够用至少2种方法进行实现，代码无大 BUG</p>
<h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="349-Intersection-of-Two-Arrays-Easy"><a href="#349-Intersection-of-Two-Arrays-Easy" class="headerlink" title="349. Intersection of Two Arrays (Easy)"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays/description/" target="_blank" rel="noopener">349. Intersection of Two Arrays (Easy)</a></h3><h3 id="350-Intersection-of-Two-Arrays-II-Easy"><a href="#350-Intersection-of-Two-Arrays-II-Easy" class="headerlink" title="350. Intersection of Two Arrays II (Easy)"></a><a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener">350. Intersection of Two Arrays II (Easy)</a></h3><p>• <a href="http://www.lintcode.com/problem/subarray-sum/" target="_blank" rel="noopener">http://www.lintcode.com/problem/subarray-sum/</a><br>• <a href="http://www.lintcode.com/problem/copy-list-with-random-pointer/" target="_blank" rel="noopener">http://www.lintcode.com/problem/copy-list-with-random-pointer/</a><br>• <a href="http://www.lintcode.com/problem/anagrams/" target="_blank" rel="noopener">http://www.lintcode.com/problem/anagrams/</a><br>• <a href="http://www.lintcode.com/problem/longest-consecutive-sequence/" target="_blank" rel="noopener">http://www.lintcode.com/problem/longest-consecutive-sequence/</a></p>
<h3 id="146-LRU-Cache-Hard"><a href="#146-LRU-Cache-Hard" class="headerlink" title="146. LRU Cache (Hard)"></a><a href="https://leetcode.com/problems/lru-cache/description/" target="_blank" rel="noopener">146. LRU Cache (Hard)</a></h3><p><a href="https://www.jiuzhang.com/solutions/lru-cache/#tag-highlight-lang-python" target="_blank" rel="noopener">九章的答案</a>是单向列表，在 Hash 中存储 Singly List 中的 prev node，如 linked list = dummy-&gt;1-&gt;2-&gt;3-&gt;null 时 hash[1] = dummy, hash[2] = node1 …<br><a href="https://www.cnblogs.com/yuzhangcmu/p/4113462.html" target="_blank" rel="noopener">双向链表</a>要容易写一点</p>
<h2 id="Combination-DFS"><a href="#Combination-DFS" class="headerlink" title="Combination DFS"></a>Combination DFS</h2><p>九章：DFS算法的掌握，主要在练习; 一个题第一遍不顺利，就要写第二遍，第三遍; 像 Word Break II 纯 DFS 版本 和 Regular Expression Matching 这样的问题，要练到 30 分钟内在 LintCode 上 AC。做不到就反复再练。</p>
<h3 id="LinC-90-k-Sum-II-Medium"><a href="#LinC-90-k-Sum-II-Medium" class="headerlink" title="LinC  90. k Sum II (Medium)"></a><a href="https://www.lintcode.com/problem/k-sum-ii/description" target="_blank" rel="noopener">LinC  90. k Sum II (Medium)</a></h3><p>和 combination sum 类似的题</p>
<h3 id="140-Word-Break-II-Hard"><a href="#140-Word-Break-II-Hard" class="headerlink" title="140. Word Break II (Hard)"></a><a href="https://leetcode.com/problems/word-break-ii/description/" target="_blank" rel="noopener">140. Word Break II (Hard)</a></h3><p>Strong Hire: DFS+DP优化<br>Hire / Weak Hire: DFS 能写完，且 Bug free or Bug 不多，不需要提示 or 需要少量提示</p>
<h3 id="44-Wildcard-Matching-Hard-1"><a href="#44-Wildcard-Matching-Hard-1" class="headerlink" title="44. Wildcard Matching (Hard)"></a><a href="https://leetcode.com/problems/wildcard-matching/description/" target="_blank" rel="noopener">44. Wildcard Matching (Hard)</a></h3><h3 id="10-Regular-Expression-Matching-Hard"><a href="#10-Regular-Expression-Matching-Hard" class="headerlink" title="10. Regular Expression Matching (Hard)"></a><a href="https://leetcode.com/problems/regular-expression-matching/description/" target="_blank" rel="noopener">10. Regular Expression Matching (Hard)</a></h3><h2 id="Permutation-DFS"><a href="#Permutation-DFS" class="headerlink" title="Permutation DFS"></a>Permutation DFS</h2><h3 id="51-N-Queens-Hard"><a href="#51-N-Queens-Hard" class="headerlink" title="51. N-Queens (Hard)"></a><a href="https://leetcode.com/problems/n-queens/description/" target="_blank" rel="noopener">51. N-Queens (Hard)</a></h3><p>还有 N-Queens II，问方案总数</p>
<h3 id="31-Next-Permutation-Medium"><a href="#31-Next-Permutation-Medium" class="headerlink" title="31. Next Permutation (Medium)"></a><a href="https://leetcode.com/problems/next-permutation/description/" target="_blank" rel="noopener">31. Next Permutation (Medium)</a></h3><p>答案很妖，没有用 DFS 模板。还有 Next Permutation II (Medium)</p>
<h3 id="197-Permutation-Index-Easy"><a href="#197-Permutation-Index-Easy" class="headerlink" title="197. Permutation Index (Easy)"></a><a href="http://www.lintcode.com/problem/permutation-index/" target="_blank" rel="noopener">197. Permutation Index (Easy)</a></h3><p>肯定不是 easy, 没有用 DFS 模板。还有 II：<a href="http://www.lintcode.com/problem/permutation-index-ii/" target="_blank" rel="noopener">http://www.lintcode.com/problem/permutation-index-ii/</a></p>
<h2 id="Graph-DFS"><a href="#Graph-DFS" class="headerlink" title="Graph DFS"></a>Graph DFS</h2><h3 id="212-Word-Search-II-Hard"><a href="#212-Word-Search-II-Hard" class="headerlink" title="212. Word Search II (Hard)"></a><a href="https://leetcode.com/problems/word-search-ii/description/" target="_blank" rel="noopener">212. Word Search II (Hard)</a></h3><h3 id="126-Word-Ladder-II-Hard"><a href="#126-Word-Ladder-II-Hard" class="headerlink" title="126. Word Ladder II (Hard)"></a><a href="https://leetcode.com/problems/word-ladder-ii/description/" target="_blank" rel="noopener">126. Word Ladder II (Hard)</a></h3><p>Word Ladder 是 BFS，II 是 DFS</p>
<h3 id="LinC-829-Word-Pattern-II-Hard"><a href="#LinC-829-Word-Pattern-II-Hard" class="headerlink" title="LinC 829. Word Pattern II (Hard)"></a><a href="https://www.lintcode.com/problem/word-pattern-ii/description" target="_blank" rel="noopener">LinC 829. Word Pattern II (Hard)</a></h3><p>做法和 Wildcard Match / Regular Expression Match 类似</p>
<h2 id="DFS-backtracking-回溯"><a href="#DFS-backtracking-回溯" class="headerlink" title="DFS / backtracking 回溯"></a>DFS / backtracking 回溯</h2><h3 id="LinC-901-Closest-Binary-Search-Tree-Value-II-Hard"><a href="#LinC-901-Closest-Binary-Search-Tree-Value-II-Hard" class="headerlink" title="LinC 901. Closest Binary Search Tree Value II (Hard)"></a><a href="https://www.lintcode.com/problem/closest-binary-search-tree-value-ii/" target="_blank" rel="noopener">LinC 901. Closest Binary Search Tree Value II (Hard)</a></h3><p>这个双栈答案看着比较优雅：<a href="http://www.cnblogs.com/grandyang/p/5247398.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/5247398.html</a> O(logn + k) 时间复杂度 O(logn) 空间复杂度</p>
<h3 id="postorder-traversal-Hard-后序遍历"><a href="#postorder-traversal-Hard-后序遍历" class="headerlink" title="postorder traversal (Hard) 后序遍历"></a>postorder traversal (Hard) 后序遍历</h3><h3 id="104-Maximum-Depth-of-Binary-Tree-Easy-1"><a href="#104-Maximum-Depth-of-Binary-Tree-Easy-1" class="headerlink" title="104. Maximum Depth of Binary Tree (Easy)"></a><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/description/" target="_blank" rel="noopener">104. Maximum Depth of Binary Tree (Easy)</a></h3><p><a href="https://articles.leetcode.com/maximum-height-of-binary-tree/" target="_blank" rel="noopener">非递归需要用 postorder traversal (Hard)</a> 或者 <a href="http://www.cnblogs.com/grandyang/p/6058061.html" target="_blank" rel="noopener">http://www.cnblogs.com/grandyang/p/6058061.html</a></p>
<h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><h3 id="矩阵上的BFS-LinC-Build-Post-Office-II-Hard"><a href="#矩阵上的BFS-LinC-Build-Post-Office-II-Hard" class="headerlink" title="矩阵上的BFS LinC Build Post Office II (Hard)"></a><a href="http://www.lintcode.com/problem/build-post-office-ii/" target="_blank" rel="noopener">矩阵上的BFS LinC Build Post Office II (Hard)</a></h3><h3 id="LinC-892-Alien-Dictionary-Hard"><a href="#LinC-892-Alien-Dictionary-Hard" class="headerlink" title="LinC 892. Alien Dictionary (Hard)"></a><a href="https://www.lintcode.com/problem/alien-dictionary/description" target="_blank" rel="noopener">LinC 892. Alien Dictionary (Hard)</a></h3><h3 id="LinC-7-Serialize-and-Deserialize-Binary-Tree-Medium"><a href="#LinC-7-Serialize-and-Deserialize-Binary-Tree-Medium" class="headerlink" title="LinC 7. Serialize and Deserialize Binary Tree (Medium)"></a><a href="https://www.lintcode.com/problem/serialize-and-deserialize-binary-tree/description" target="_blank" rel="noopener">LinC 7. Serialize and Deserialize Binary Tree (Medium)</a></h3><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="LinC-944-Maximum-Submatrix-Medium"><a href="#LinC-944-Maximum-Submatrix-Medium" class="headerlink" title="LinC 944. Maximum Submatrix (Medium)"></a><a href="https://www.lintcode.com/problem/maximum-submatrix/description" target="_blank" rel="noopener">LinC 944. Maximum Submatrix (Medium)</a></h3><p>某家 sb 公司的电面，只写出了最傻的方法。挂了。<a href="https://www.jiuzhang.com/solution/maximum-submatrix/#tag-highlight" target="_blank" rel="noopener">九章有比较优化的方法</a></p>
<h3 id="57-Insert-Interval-Hard"><a href="#57-Insert-Interval-Hard" class="headerlink" title="57. Insert Interval (Hard)"></a><a href="https://leetcode.com/problems/insert-interval/description/" target="_blank" rel="noopener">57. Insert Interval (Hard)</a></h3><h3 id="8-String-to-Integer-atoi-Medium"><a href="#8-String-to-Integer-atoi-Medium" class="headerlink" title="8. String to Integer (atoi) (Medium)"></a><a href="https://leetcode.com/problems/string-to-integer-atoi/description/" target="_blank" rel="noopener">8. String to Integer (atoi) (Medium)</a></h3>
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/03/2018-五一假期日本大阪京都奈良-6-天-5-晚/" rel="next" title="2018 五一假期日本大阪京都奈良 6 天 5 晚">
                <i class="fa fa-chevron-left"></i> 2018 五一假期日本大阪京都奈良 6 天 5 晚
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alan</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://www.linkedin.com/in/alantang" target="_blank" title="LinkedIn"><i class="fa fa-fw fa-linkedin"></i>LinkedIn</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://github.com/alant" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://stackoverflow.com/users/3781358/alant" target="_blank" title="StackOverflow"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://www.zhihu.com/people/tang-hao-3" target="_blank" title="知乎"><i class="fa fa-fw fa-globe"></i>知乎</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Binary-Search-amp-LogN-Algorithm"><span class="nav-number">1.</span> <span class="nav-text">Binary Search &amp; LogN Algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#704-Binary-Search-Easy"><span class="nav-number">1.0.1.</span> <span class="nav-text">704. Binary Search (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-14-First-Position-of-Target-Easy"><span class="nav-number">1.0.2.</span> <span class="nav-text">LinC 14. First Position of Target (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#278-First-Bad-Version-Easy"><span class="nav-number">1.0.3.</span> <span class="nav-text">278. First Bad Version (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#34-Find-First-and-Last-Position-of-Element-in-Sorted-Array-Medium"><span class="nav-number">1.0.4.</span> <span class="nav-text">34. Find First and Last Position of Element in Sorted Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-61-Search-for-a-Range-Medium"><span class="nav-number">1.0.5.</span> <span class="nav-text">LinC 61. Search for a Range (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-460-Find-K-Closest-Elements-Medium"><span class="nav-number">1.0.6.</span> <span class="nav-text">LinC 460. Find K Closest Elements (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-585-Maximum-Number-in-Mountain-Sequence-Medium"><span class="nav-number">1.0.7.</span> <span class="nav-text">LinC 585. Maximum Number in Mountain Sequence (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#162-Find-Peak-Element-Medium"><span class="nav-number">1.0.8.</span> <span class="nav-text">162. Find Peak Element (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#74-Search-a-2D-Matrix-Medium"><span class="nav-number">1.0.9.</span> <span class="nav-text">74. Search a 2D Matrix (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#153-Find-Minimum-in-Rotated-Sorted-Array-Medium"><span class="nav-number">1.0.10.</span> <span class="nav-text">153. Find Minimum in Rotated Sorted Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#33-Search-in-Rotated-Sorted-Array-Medium"><span class="nav-number">1.0.11.</span> <span class="nav-text">33. Search in Rotated Sorted Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-140-Fast-Power-Medium"><span class="nav-number">1.0.12.</span> <span class="nav-text">LinC 140. Fast Power (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#50-Pow-x-n-Medium"><span class="nav-number">1.0.13.</span> <span class="nav-text">50. Pow(x, n) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#228-Summary-Ranges-Medium"><span class="nav-number">1.0.14.</span> <span class="nav-text">228. Summary Ranges (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Two-pointers"><span class="nav-number">2.</span> <span class="nav-text">Two pointers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-373-Partition-Array-by-Odd-and-Even-Easy"><span class="nav-number">2.0.1.</span> <span class="nav-text">LinC 373. Partition Array by Odd and Even (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#26-Remove-Duplicates-from-Sorted-Array-Easy"><span class="nav-number">2.0.2.</span> <span class="nav-text">26. Remove Duplicates from Sorted Array (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#28-Implement-strStr-Easy"><span class="nav-number">2.0.3.</span> <span class="nav-text">28. Implement strStr() (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#160-Intersection-of-Two-Linked-Lists-Easy"><span class="nav-number">2.0.4.</span> <span class="nav-text">160. Intersection of Two Linked Lists (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#141-Linked-List-Cycle-Easy"><span class="nav-number">2.0.5.</span> <span class="nav-text">141. Linked List Cycle (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#142-Linked-List-Cycle-II-Medium"><span class="nav-number">2.0.6.</span> <span class="nav-text">142. Linked List Cycle II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#125-Valid-Palindrome-Easy"><span class="nav-number">2.0.7.</span> <span class="nav-text">125. Valid Palindrome (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#680-Valid-Palindrome-II-Easy"><span class="nav-number">2.0.8.</span> <span class="nav-text">680. Valid Palindrome II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Two-Sum-Easy"><span class="nav-number">2.0.9.</span> <span class="nav-text">1. Two Sum (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#167-Two-Sum-II-Input-array-is-sorted-Easy"><span class="nav-number">2.0.10.</span> <span class="nav-text">167. Two Sum II - Input array is sorted (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-607-Two-Sum-III-Data-structure-design-Easy"><span class="nav-number">2.0.11.</span> <span class="nav-text">LinC 607. Two Sum III - Data structure design (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-3Sum-Medium"><span class="nav-number">2.0.12.</span> <span class="nav-text">15. 3Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-382-Triangle-Count-Medium"><span class="nav-number">2.0.13.</span> <span class="nav-text">LinC 382. Triangle Count (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-3Sum-Closest-Medium"><span class="nav-number">2.0.14.</span> <span class="nav-text">16. 3Sum Closest (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#86-Partition-List-Medium"><span class="nav-number">2.0.15.</span> <span class="nav-text">86. Partition List (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-31-Partition-Array-Medium"><span class="nav-number">2.0.16.</span> <span class="nav-text">LinC 31. Partition Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#215-Kth-Largest-Element-in-an-Array-Medium"><span class="nav-number">2.0.17.</span> <span class="nav-text">215. Kth Largest Element in an Array (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#75-Sort-Colors-Medium"><span class="nav-number">2.0.18.</span> <span class="nav-text">75. Sort Colors (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#658-Find-K-Closest-Elements-Medium"><span class="nav-number">2.0.19.</span> <span class="nav-text">658. Find K Closest Elements (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-4Sum-Medium"><span class="nav-number">2.0.20.</span> <span class="nav-text">18. 4Sum (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#BFS-广度优先搜索"><span class="nav-number">3.</span> <span class="nav-text">BFS 广度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#695-Max-Area-of-Island-Easy"><span class="nav-number">3.0.1.</span> <span class="nav-text">695. Max Area of Island (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#102-Binary-Tree-Level-Order-Traversal-Medium"><span class="nav-number">3.0.2.</span> <span class="nav-text">102. Binary Tree Level Order Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#103-Binary-Tree-Zigzag-Level-Order-Traversal-Medium"><span class="nav-number">3.0.3.</span> <span class="nav-text">103. Binary Tree Zigzag Level Order Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#133-Clone-Graph-Medium"><span class="nav-number">3.0.4.</span> <span class="nav-text">133. Clone Graph (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#127-Word-Ladder-Medium"><span class="nav-number">3.0.5.</span> <span class="nav-text">127. Word Ladder (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#200-Number-of-Islands-Medium"><span class="nav-number">3.0.6.</span> <span class="nav-text">200. Number of Islands (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-611-Knight-Shortest-Path-Medium"><span class="nav-number">3.0.7.</span> <span class="nav-text">LinC 611. Knight Shortest Path (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#785-Is-Graph-Bipartite-Medium"><span class="nav-number">3.0.8.</span> <span class="nav-text">785. Is Graph Bipartite? (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-178-Graph-Valid-Tree-Medium"><span class="nav-number">3.0.9.</span> <span class="nav-text">LinC 178. Graph Valid Tree (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Topological-sorting-拓扑排序"><span class="nav-number">3.1.</span> <span class="nav-text">Topological sorting 拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-127-Topological-Sorting-Medium"><span class="nav-number">3.1.1.</span> <span class="nav-text">LinC 127. Topological Sorting (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#210-Course-Schedule-II-Medium"><span class="nav-number">3.1.2.</span> <span class="nav-text">210. Course Schedule II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-605-Sequence-Reconstruction-Medium"><span class="nav-number">3.1.3.</span> <span class="nav-text">LinC 605. Sequence Reconstruction (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DFS-深度优先搜索"><span class="nav-number">4.</span> <span class="nav-text">DFS 深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree-amp-Tree-based-DFS-二叉树与树上的深度优先搜索"><span class="nav-number">4.1.</span> <span class="nav-text">Binary Tree &amp; Tree-based DFS 二叉树与树上的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree-Easy"><span class="nav-number">4.1.1.</span> <span class="nav-text">104. Maximum Depth of Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#226-Invert-Binary-Tree-Easy"><span class="nav-number">4.1.2.</span> <span class="nav-text">226. Invert Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#701-Insert-into-a-Binary-Search-Tree-Medium"><span class="nav-number">4.1.3.</span> <span class="nav-text">701. Insert into a Binary Search Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#257-Binary-Tree-Paths-Easy"><span class="nav-number">4.1.4.</span> <span class="nav-text">257. Binary Tree Paths (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree-Medium"><span class="nav-number">4.1.5.</span> <span class="nav-text">236. Lowest Common Ancestor of a Binary Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree-Easy"><span class="nav-number">4.1.6.</span> <span class="nav-text">235. Lowest Common Ancestor of a Binary Search Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#144-Binary-Tree-Preorder-Traversal-Medium"><span class="nav-number">4.1.7.</span> <span class="nav-text">144. Binary Tree Preorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-Binary-Tree-Inorder-Traversal-Medium"><span class="nav-number">4.1.8.</span> <span class="nav-text">94. Binary Tree Inorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-448-Inorder-Successor-in-BST-Medium"><span class="nav-number">4.1.9.</span> <span class="nav-text">LinC 448. Inorder Successor in BST (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#98-Validate-Binary-Search-Tree-Medium"><span class="nav-number">4.1.10.</span> <span class="nav-text">98. Validate Binary Search Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#230-Kth-Smallest-Element-in-a-BST-Medium"><span class="nav-number">4.1.11.</span> <span class="nav-text">230. Kth Smallest Element in a BST (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#173-Binary-Search-Tree-Iterator-Medium"><span class="nav-number">4.1.12.</span> <span class="nav-text">173. Binary Search Tree Iterator (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-900-Closest-Binary-Search-Tree-Value-Easy"><span class="nav-number">4.1.13.</span> <span class="nav-text">LinC 900. Closest Binary Search Tree Value (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-11-Search-Range-in-Binary-Search-Tree-Medium"><span class="nav-number">4.1.14.</span> <span class="nav-text">LinC 11.Search Range in Binary Search Tree (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Combination-based-DFS-基于组合的深度优先搜索"><span class="nav-number">4.2.</span> <span class="nav-text">Combination based DFS - 基于组合的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#78-Subsets-Medium"><span class="nav-number">4.2.1.</span> <span class="nav-text">78. Subsets (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#39-Combination-Sum-Medium"><span class="nav-number">4.2.2.</span> <span class="nav-text">39. Combination Sum (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#40-Combination-Sum-II-Medium"><span class="nav-number">4.2.3.</span> <span class="nav-text">40. Combination Sum II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#216-Combination-Sum-III-Medium"><span class="nav-number">4.2.4.</span> <span class="nav-text">216. Combination Sum III (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#131-Palindrome-Partitioning-Medium"><span class="nav-number">4.2.5.</span> <span class="nav-text">131. Palindrome Partitioning (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#93-Restore-IP-Addresses-Medium"><span class="nav-number">4.2.6.</span> <span class="nav-text">93. Restore IP Addresses (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-680-Split-String-Easy"><span class="nav-number">4.2.7.</span> <span class="nav-text">LinC 680. Split String (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#77-Combinations-Medium"><span class="nav-number">4.2.8.</span> <span class="nav-text">77. Combinations (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#90-Subsets-II-Medium"><span class="nav-number">4.2.9.</span> <span class="nav-text">90. Subsets II (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Permutation-based-DFS-基于排列的深度优先搜索"><span class="nav-number">4.3.</span> <span class="nav-text">Permutation based DFS - 基于排列的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#46-Permutations-Medium"><span class="nav-number">4.3.1.</span> <span class="nav-text">46. Permutations (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#47-Permutations-II-Medium"><span class="nav-number">4.3.2.</span> <span class="nav-text">47. Permutations II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-862-Next-Closest-Time-Medium"><span class="nav-number">4.3.3.</span> <span class="nav-text">LinC 862. Next Closest Time (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#22-Generate-Parentheses-Medium"><span class="nav-number">4.3.4.</span> <span class="nav-text">22. Generate Parentheses (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph-based-DFS-基于图的深度优先搜索"><span class="nav-number">4.4.</span> <span class="nav-text">Graph based DFS 基于图的深度优先搜索</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#17-Letter-Combinations-of-a-Phone-Number-Medium"><span class="nav-number">4.4.1.</span> <span class="nav-text">17. Letter Combinations of a Phone Number (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#79-Word-Search-Medium"><span class="nav-number">4.4.2.</span> <span class="nav-text">79. Word Search (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据结构"><span class="nav-number">5.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree-amp-Divide-Conquer-二叉树与分治"><span class="nav-number">5.1.</span> <span class="nav-text">Binary Tree &amp; Divide Conquer 二叉树与分治</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#110-Balanced-Binary-Tree-Easy"><span class="nav-number">5.1.1.</span> <span class="nav-text">110. Balanced Binary Tree (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#114-Flatten-Binary-Tree-to-Linked-List-Medium"><span class="nav-number">5.1.2.</span> <span class="nav-text">114. Flatten Binary Tree to Linked List (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stack-栈"><span class="nav-number">5.2.</span> <span class="nav-text">Stack 栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#20-Valid-Parentheses-Easy"><span class="nav-number">5.2.1.</span> <span class="nav-text">20. Valid Parentheses (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-队列"><span class="nav-number">5.3.</span> <span class="nav-text">Queue 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-642-Moving-Average-from-Data-Stream-Easy"><span class="nav-number">5.3.1.</span> <span class="nav-text">LinC 642. Moving Average from Data Stream (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash-哈希表"><span class="nav-number">5.4.</span> <span class="nav-text">Hash 哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#290-Word-Pattern-Easy"><span class="nav-number">5.4.1.</span> <span class="nav-text">290. Word Pattern (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#387-First-Unique-Character-in-a-String-Easy"><span class="nav-number">5.4.2.</span> <span class="nav-text">387. First Unique Character in a String (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#409-Longest-Palindrome-Easy"><span class="nav-number">5.4.3.</span> <span class="nav-text">409. Longest Palindrome (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#380-Insert-Delete-GetRandom-O-1-Medium"><span class="nav-number">5.4.4.</span> <span class="nav-text">380. Insert Delete GetRandom O(1) (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-960-First-Unique-Number-in-a-Stream-II-Medium"><span class="nav-number">5.4.5.</span> <span class="nav-text">LinC 960. First Unique Number in a Stream II (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap-Priority-Queue"><span class="nav-number">5.5.</span> <span class="nav-text">Heap (Priority Queue)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#264-Ugly-Number-II-Medium"><span class="nav-number">5.5.1.</span> <span class="nav-text">264. Ugly Number II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-612-K-Closest-Points-Medium"><span class="nav-number">5.5.2.</span> <span class="nav-text">LinC 612. K Closest Points (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-545-Top-k-Largest-Numbers-II-Medium"><span class="nav-number">5.5.3.</span> <span class="nav-text">LinC 545. Top k Largest Numbers II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-486-Merge-K-Sorted-Arrays-Medium"><span class="nav-number">5.5.4.</span> <span class="nav-text">LinC 486. Merge K Sorted Arrays (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-数组"><span class="nav-number">5.6.</span> <span class="nav-text">Array 数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-6-Merge-Two-Sorted-Arrays-Easy"><span class="nav-number">5.6.1.</span> <span class="nav-text">LinC 6. Merge Two Sorted Arrays (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#88-Merge-Sorted-Array-Easy"><span class="nav-number">5.6.2.</span> <span class="nav-text">88. Merge Sorted Array (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-839-Merge-Two-Sorted-Interval-Lists-Easy"><span class="nav-number">5.6.3.</span> <span class="nav-text">LinC 839. Merge Two Sorted Interval Lists (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-486-Merge-K-Sorted-Arrays-Medium-1"><span class="nav-number">5.6.4.</span> <span class="nav-text">LinC 486. Merge K Sorted Arrays (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy"><span class="nav-number">5.6.5.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie"><span class="nav-number">5.7.</span> <span class="nav-text">Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#208-Implement-Trie-Prefix-Tree-Medium"><span class="nav-number">5.7.1.</span> <span class="nav-text">208. Implement Trie (Prefix Tree) (Medium)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bit-Manipulation"><span class="nav-number">6.</span> <span class="nav-text">Bit Manipulation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#231-Power-of-Two-Easy"><span class="nav-number">6.0.1.</span> <span class="nav-text">231. Power of Two (Easy)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#DP-Dynamic-Programming-动态规划"><span class="nav-number">7.</span> <span class="nav-text">DP Dynamic Programming 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#70-Climbing-Stairs-Easy"><span class="nav-number">7.0.1.</span> <span class="nav-text">70. Climbing Stairs (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#120-Triangle-Medium"><span class="nav-number">7.0.2.</span> <span class="nav-text">120. Triangle (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#409-Longest-Palindrome-Easy-1"><span class="nav-number">7.0.3.</span> <span class="nav-text">409. Longest Palindrome (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#121-Best-Time-to-Buy-and-Sell-Stock-Easy-1"><span class="nav-number">7.0.4.</span> <span class="nav-text">121. Best Time to Buy and Sell Stock (Easy)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#skipped"><span class="nav-number">8.</span> <span class="nav-text">skipped</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Tree-amp-Divide-and-Conquer-分治"><span class="nav-number">8.1.</span> <span class="nav-text">Binary Tree &amp; Divide and Conquer 分治</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#98-Validate-Binary-Search-Tree-Medium-1"><span class="nav-number">8.1.1.</span> <span class="nav-text">98. Validate Binary Search Tree (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#94-Binary-Tree-Inorder-Traversal-Medium-1"><span class="nav-number">8.1.2.</span> <span class="nav-text">94. Binary Tree Inorder Traversal (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#120-Triangle-Medium-1"><span class="nav-number">8.1.3.</span> <span class="nav-text">120. Triangle (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-649-Binary-Tree-Upside-Down-Medium"><span class="nav-number">8.1.4.</span> <span class="nav-text">LinC 649. Binary Tree Upside Down (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DP-Dynamic-Programming-动态规划-1"><span class="nav-number">8.2.</span> <span class="nav-text">DP Dynamic Programming 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Best-Time-to-Buy-and-Sell-Stock-II-amp-III"><span class="nav-number">8.2.1.</span> <span class="nav-text">Best Time to Buy and Sell Stock II &amp; III</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#53-Maximum-Subarray-Easy"><span class="nav-number">8.2.2.</span> <span class="nav-text">53. Maximum Subarray (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Minimum-Path-Sum"><span class="nav-number">8.2.3.</span> <span class="nav-text">Minimum Path Sum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jump-Game"><span class="nav-number">8.2.4.</span> <span class="nav-text">Jump Game</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-Increasing-Subsequence"><span class="nav-number">8.2.5.</span> <span class="nav-text">Longest Increasing Subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Word-Break"><span class="nav-number">8.2.6.</span> <span class="nav-text">Word Break</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Longest-Common-Subsequence"><span class="nav-number">8.2.7.</span> <span class="nav-text">Longest Common Subsequence</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-Wildcard-Matching-Hard"><span class="nav-number">8.2.8.</span> <span class="nav-text">44. Wildcard Matching (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Search"><span class="nav-number">8.3.</span> <span class="nav-text">Binary Search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#240-Search-a-2D-Matrix-II-Medium"><span class="nav-number">8.3.1.</span> <span class="nav-text">240. Search a 2D Matrix II (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bit-Manipulation-1"><span class="nav-number">8.4.</span> <span class="nav-text">Bit Manipulation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#29-Divide-Two-Integers-Medium"><span class="nav-number">8.4.1.</span> <span class="nav-text">29. Divide Two Integers (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Trie-1"><span class="nav-number">8.5.</span> <span class="nav-text">Trie</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#211-Add-and-Search-Word-Data-structure-design-Medium"><span class="nav-number">8.5.1.</span> <span class="nav-text">211. Add and Search Word - Data structure design (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Two-pointers-1"><span class="nav-number">8.6.</span> <span class="nav-text">Two pointers</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-Sort-Colors-II-medium"><span class="nav-number">8.6.1.</span> <span class="nav-text">LinC Sort Colors II (medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Interleaving-Positive-and-Negative-Numbers-Medium"><span class="nav-number">8.6.2.</span> <span class="nav-text">Interleaving Positive and Negative Numbers (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Sort-Letters-by-Case-Medium"><span class="nav-number">8.6.3.</span> <span class="nav-text">Sort Letters by Case (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#600-Smallest-Rectangle-Enclosing-Black-Pixels-Hard"><span class="nav-number">8.6.4.</span> <span class="nav-text">600. Smallest Rectangle Enclosing Black Pixels (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Heap"><span class="nav-number">8.7.</span> <span class="nav-text">Heap</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#577-Merge-K-Sorted-Interval-Lists-Medium"><span class="nav-number">8.7.1.</span> <span class="nav-text">577. Merge K Sorted Interval Lists (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#347-Top-K-Frequent-Elements-Medium"><span class="nav-number">8.7.2.</span> <span class="nav-text">347. Top K Frequent Elements (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#23-Merge-k-Sorted-Lists-Hard"><span class="nav-number">8.7.3.</span> <span class="nav-text">23. Merge k Sorted Lists (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash"><span class="nav-number">8.8.</span> <span class="nav-text">Hash</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#349-Intersection-of-Two-Arrays-Easy"><span class="nav-number">8.8.1.</span> <span class="nav-text">349. Intersection of Two Arrays (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#350-Intersection-of-Two-Arrays-II-Easy"><span class="nav-number">8.8.2.</span> <span class="nav-text">350. Intersection of Two Arrays II (Easy)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#146-LRU-Cache-Hard"><span class="nav-number">8.8.3.</span> <span class="nav-text">146. LRU Cache (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Combination-DFS"><span class="nav-number">8.9.</span> <span class="nav-text">Combination DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-90-k-Sum-II-Medium"><span class="nav-number">8.9.1.</span> <span class="nav-text">LinC  90. k Sum II (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#140-Word-Break-II-Hard"><span class="nav-number">8.9.2.</span> <span class="nav-text">140. Word Break II (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#44-Wildcard-Matching-Hard-1"><span class="nav-number">8.9.3.</span> <span class="nav-text">44. Wildcard Matching (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-Regular-Expression-Matching-Hard"><span class="nav-number">8.9.4.</span> <span class="nav-text">10. Regular Expression Matching (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Permutation-DFS"><span class="nav-number">8.10.</span> <span class="nav-text">Permutation DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#51-N-Queens-Hard"><span class="nav-number">8.10.1.</span> <span class="nav-text">51. N-Queens (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#31-Next-Permutation-Medium"><span class="nav-number">8.10.2.</span> <span class="nav-text">31. Next Permutation (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#197-Permutation-Index-Easy"><span class="nav-number">8.10.3.</span> <span class="nav-text">197. Permutation Index (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Graph-DFS"><span class="nav-number">8.11.</span> <span class="nav-text">Graph DFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#212-Word-Search-II-Hard"><span class="nav-number">8.11.1.</span> <span class="nav-text">212. Word Search II (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#126-Word-Ladder-II-Hard"><span class="nav-number">8.11.2.</span> <span class="nav-text">126. Word Ladder II (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-829-Word-Pattern-II-Hard"><span class="nav-number">8.11.3.</span> <span class="nav-text">LinC 829. Word Pattern II (Hard)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DFS-backtracking-回溯"><span class="nav-number">8.12.</span> <span class="nav-text">DFS / backtracking 回溯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-901-Closest-Binary-Search-Tree-Value-II-Hard"><span class="nav-number">8.12.1.</span> <span class="nav-text">LinC 901. Closest Binary Search Tree Value II (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#postorder-traversal-Hard-后序遍历"><span class="nav-number">8.12.2.</span> <span class="nav-text">postorder traversal (Hard) 后序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#104-Maximum-Depth-of-Binary-Tree-Easy-1"><span class="nav-number">8.12.3.</span> <span class="nav-text">104. Maximum Depth of Binary Tree (Easy)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BFS"><span class="nav-number">8.13.</span> <span class="nav-text">BFS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#矩阵上的BFS-LinC-Build-Post-Office-II-Hard"><span class="nav-number">8.13.1.</span> <span class="nav-text">矩阵上的BFS LinC Build Post Office II (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-892-Alien-Dictionary-Hard"><span class="nav-number">8.13.2.</span> <span class="nav-text">LinC 892. Alien Dictionary (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-7-Serialize-and-Deserialize-Binary-Tree-Medium"><span class="nav-number">8.13.3.</span> <span class="nav-text">LinC 7. Serialize and Deserialize Binary Tree (Medium)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array"><span class="nav-number">8.14.</span> <span class="nav-text">Array</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#LinC-944-Maximum-Submatrix-Medium"><span class="nav-number">8.14.1.</span> <span class="nav-text">LinC 944. Maximum Submatrix (Medium)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#57-Insert-Interval-Hard"><span class="nav-number">8.14.2.</span> <span class="nav-text">57. Insert Interval (Hard)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-String-to-Integer-atoi-Medium"><span class="nav-number">8.14.3.</span> <span class="nav-text">8. String to Integer (atoi) (Medium)</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alan</span>

  

  
</div>








  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.4.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.4.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.4.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.4.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.4.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.4.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
